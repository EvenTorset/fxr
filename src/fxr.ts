/**
 * Values representing different games supported by the library.
 */
enum Game {
  /**
   * Using this with the {@link FXR.read} function will cause it to try to find
   * out what game the FXR is for automatically.
   * 
   * Using it with the {@link FXR.toArrayBuffer} and {@link FXR.saveAs} methods
   * will cause them to use the {@link FXR.gameHint game hint}, unless the hint
   * is {@link Game.Heuristic}, in which case they will throw an error.
   */
  Heuristic = -2,
  /**
   * Does not represent any specific game.
   * 
   * Using this with the {@link FXR.read} function will cause it to parse
   * everything as generic classes. This means that none of the methods in the
   * library that manipulate things that depend on the game version will work,
   * like the {@link Node.scale} and {@link Node.recolor} methods. It also
   * means that the library will not be able to convert it to work with other
   * games.
   * 
   * This is intended to be used only for research or for parsing modded files
   * that may not be structured correctly.
   * 
   * Note that this does not work with the {@link FXR.toArrayBuffer} and
   * {@link FXR.saveAs} methods unless the FXR only contains generic classes.
   * If it contains any node classes other than {@link GenericNode}, any
   * config classes other than {@link NodeConfig}, or any {@link DataAction}s, it
   * must be given a specific game to write to.
   */
  Generic = -1,
  /**
   * Dark Souls III
   */
  DarkSouls3 = 0,
  /**
   * Sekiro: Shadows Die Twice
   */
  Sekiro = 1,
  /**
   * Elden Ring
   */
  EldenRing = 2,
  /**
   * Armored Core VI Fires of Rubicon
   */
  ArmoredCore6 = 3,
  /**
   * Elden Ring Nightreign
   */
  Nightreign = 4,
}

/**
 * FXR file format version numbers supported by the library.
 */
enum FXRVersion {
  /**
   * Used in Dark Souls 3.
   */
  DarkSouls3 = 4,
  /**
   * Used in Sekiro, Elden Ring, and Armored Core 6.
   */
  Sekiro = 5,
}

/*#Enums start*/
/**
 * Values used to represent different types of FXR actions.
 */
export enum ActionType {
  /**
   * This action does nothing. It fits into most action slots and acts as a way to disable the effects of the other actions that go in those slots.
   */
  None = 0,
  /**
   * Unknown action that *may* exist in Dark Souls 3. It is not used in vanilla, but its name and ID have been found in the game's executable.
   */
  Unk10002_Fluid = 10002,
  /**
   * Unknown action that *may* exist in Dark Souls 3. It is not used in vanilla, but its name and ID have been found in the game's executable.
   */
  Unk10010_Tracer = 10010,
  /**
   * ### Action 1 - NodeAcceleration
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeAcceleration}
   * 
   * Controls the movement of the node. This is the most basic action for controlling the acceleration of nodes.
   */
  NodeAcceleration = 1,
  /**
   * ### Action 15 - NodeTranslation
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeTranslation}
   * 
   * Translates the node using a property, meaning it can be animated. This can be useful if you need the node to follow a specific path.
   */
  NodeTranslation = 15,
  /**
   * ### Action 34 - NodeSpin
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeSpin}
   * 
   * Controls the angular speed of the node.
   */
  NodeSpin = 34,
  /**
   * ### Action 35 - StaticNodeTransform
   * - **Slot**: {@link ActionSlots.NodeTransformAction NodeTransform}
   * - **Class**: {@link StaticNodeTransform}
   * 
   * Controls the translation and rotation of a node.
   */
  StaticNodeTransform = 35,
  /**
   * ### Action 36 - RandomNodeTransform
   * - **Slot**: {@link ActionSlots.NodeTransformAction NodeTransform}
   * - **Class**: {@link RandomNodeTransform}
   * 
   * Controls the translation and rotation of a node, and can also randomize them.
   */
  RandomNodeTransform = 36,
  /**
   * ### Action 46 - NodeAttachToCamera
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeAttachToCamera}
   * 
   * Attaches the node to the camera.
   */
  NodeAttachToCamera = 46,
  /**
   * ### Action 55 - ParticleAcceleration
   * - **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
   * - **Class**: {@link ParticleAcceleration}
   * 
   * Controls the movement of particles. This is the most basic action for controlling the acceleration of particles.
   */
  ParticleAcceleration = 55,
  /**
   * ### Action 60 - ParticleSpeed
   * - **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
   * - **Class**: {@link ParticleSpeed}
   * 
   * Controls the movement of particles. This is the most basic action for controlling the speed of particles.
   */
  ParticleSpeed = 60,
  /**
   * ### Action 64 - ParticleSpeedRandomTurns
   * - **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
   * - **Class**: {@link ParticleSpeedRandomTurns}
   * 
   * Controls the movement of particles. This extends {@link ActionType.ParticleSpeed ParticleSpeed} with the ability to make particles make random turns at a fixed interval.
   */
  ParticleSpeedRandomTurns = 64,
  /**
   * ### Action 65 - ParticleSpeedPartialFollow
   * - **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
   * - **Class**: {@link ParticleSpeedPartialFollow}
   * 
   * Controls the movement of particles. This extends {@link ActionType.ParticleSpeedRandomTurns ParticleSpeedRandomTurns} with the ability to make particles partially follow the parent node.
   */
  ParticleSpeedPartialFollow = 65,
  /**
   * ### Action 75 - NodeSound
   * - **Slot**: {@link ActionSlots.NodeAudioAction NodeAudio}
   * - **Class**: {@link NodeSound}
   * 
   * Plays a sound effect when the node activates.
   */
  NodeSound = 75,
  /**
   * ### Action 81 - EmissionSound
   * - **Slot**: {@link ActionSlots.EmissionAudioAction EmissionAudio}
   * - **Class**: {@link EmissionSound}
   * 
   * Plays a sound effect every time the node emits particles. It only plays the sound once per emission, not once per particle.
   */
  EmissionSound = 81,
  /**
   * ### Action 83 - NodeAccelerationRandomTurns
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeAccelerationRandomTurns}
   * 
   * Controls the movement of the node. This extends {@link ActionType.NodeAcceleration NodeAcceleration} with the ability to make the node turn a random amount at a given interval.
   */
  NodeAccelerationRandomTurns = 83,
  /**
   * ### Action 84 - ParticleAccelerationRandomTurns
   * - **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
   * - **Class**: {@link ParticleAccelerationRandomTurns}
   * 
   * Controls the movement of particles. This extends {@link ActionType.ParticleAcceleration ParticleAcceleration} with the ability to make particles make random turns at a fixed interval.
   */
  ParticleAccelerationRandomTurns = 84,
  /**
   * ### Action 105 - ParticleAccelerationPartialFollow
   * - **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
   * - **Class**: {@link ParticleAccelerationPartialFollow}
   * 
   * Controls the movement of particles. This extends {@link ActionType.ParticleAccelerationRandomTurns ParticleAccelerationRandomTurns} with the ability to make particles partially follow the parent node.
   */
  ParticleAccelerationPartialFollow = 105,
  /**
   * ### Action 106 - NodeAccelerationPartialFollow
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeAccelerationPartialFollow}
   * 
   * Controls the movement of the node. This extends {@link ActionType.NodeAccelerationRandomTurns NodeAccelerationRandomTurns} with the ability to make the node partially follow or exaggerate the parent node's movement.
   */
  NodeAccelerationPartialFollow = 106,
  /**
   * ### Action 113 - NodeAccelerationSpin
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeAccelerationSpin}
   * 
   * Controls the movement of the node. This extends {@link ActionType.NodeAcceleration NodeAcceleration} with the ability to control the node's angular speed.
   */
  NodeAccelerationSpin = 113,
  /**
   * ### Action 120 - NodeSpeed
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeSpeed}
   * 
   * Controls the movement of the node. This is the most basic action for controlling the speed of nodes.
   */
  NodeSpeed = 120,
  /**
   * ### Action 121 - NodeSpeedRandomTurns
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeSpeedRandomTurns}
   * 
   * Controls the movement of the node. This extends {@link ActionType.NodeSpeed NodeSpeed} with the ability to make the node turn a random amount at a given interval.
   */
  NodeSpeedRandomTurns = 121,
  /**
   * ### Action 122 - NodeSpeedPartialFollow
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeSpeedPartialFollow}
   * 
   * Controls the movement of the node. This extends {@link ActionType.NodeSpeedRandomTurns NodeSpeedRandomTurns} with the ability to make the node partially follow or exaggerate the parent node's movement.
   */
  NodeSpeedPartialFollow = 122,
  /**
   * ### Action 123 - NodeSpeedSpin
   * - **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
   * - **Class**: {@link NodeSpeedSpin}
   * 
   * Controls the movement of the node. This extends {@link ActionType.NodeSpeed NodeSpeed} with the ability to control the node's angular speed.
   */
  NodeSpeedSpin = 123,
  /**
   * ### Action 128 - NodeAttributes
   * - **Slot**: {@link ActionSlots.NodeAttributesAction NodeAttributes}
   * - **Class**: {@link NodeAttributes}
   * 
   * Controls various things about the node, like its duration, and how it is attached to the parent node.
   */
  NodeAttributes = 128,
  /**
   * ### Action 129 - ParticleAttributes
   * - **Slot**: {@link ActionSlots.ParticleAttributesAction ParticleAttributes}
   * - **Class**: {@link ParticleAttributes}
   * 
   * Controls the duration of particles emitted by the node, and how the particles are attached to the node.
   */
  ParticleAttributes = 129,
  /**
   * ### Action 130 - Unk130
   * - **Slot**: {@link ActionSlots.Unknown130Action Unknown130}
   * - **Class**: {@link Unk130}
   * 
   * Unknown action that is in every basic config in every game, and still literally nothing is known about it.
   */
  Unk130 = 130,
  /**
   * ### Action 131 - ParticleModifier
   * - **Slot**: {@link ActionSlots.ParticleModifierAction ParticleModifier}
   * - **Class**: {@link ParticleModifier}
   * 
   * Modifies particles in various ways.
   * 
   * Note: This is **not** a {@link Modifier property modifier}, it is an action that modifies particles emitted from the same node.
   */
  ParticleModifier = 131,
  /**
   * ### Action 132 - SFXReference
   * - **Slot**: {@link ActionSlots.SFXReferenceAction SFXReference}
   * - **Class**: {@link SFXReference}
   * 
   * References another SFX by its ID.
   */
  SFXReference = 132,
  /**
   * ### Action 133 - LevelsOfDetailThresholds
   * - **Slot**: {@link ActionSlots.LevelsOfDetailThresholdsAction LevelsOfDetailThresholds}
   * - **Class**: {@link LevelsOfDetailThresholds}
   * 
   * Used in the {@link ConfigType.LevelsOfDetail levels of detail config} to manage the duration and thresholds for the {@link NodeType.LevelsOfDetail levels of detail node}.
   */
  LevelsOfDetailThresholds = 133,
  /**
   * ### Action 199 - StateConfigMap
   * - **Slot**: {@link ActionSlots.StateConfigMapAction StateConfigMap}
   * - **Class**: {@link StateConfigMap}
   * 
   * Maps states to configs in the parent node.
   */
  StateConfigMap = 199,
  /**
   * ### Action 200 - SelectAllNodes
   * - **Slot**: {@link ActionSlots.NodeSelectorAction NodeSelector}
   * - **Class**: {@link SelectAllNodes}
   * 
   * Used in {@link ConfigType.NodeEmitter NodeEmitter configs} to emit all child nodes every emission.
   */
  SelectAllNodes = 200,
  /**
   * ### Action 201 - SelectRandomNode
   * - **Slot**: {@link ActionSlots.NodeSelectorAction NodeSelector}
   * - **Class**: {@link SelectRandomNode}
   * 
   * Used in {@link ConfigType.NodeEmitter NodeEmitter configs} to emit a random child node every emission.
   */
  SelectRandomNode = 201,
  /**
   * ### Action 300 - PeriodicEmitter
   * - **Slot**: {@link ActionSlots.EmitterAction Emitter}
   * - **Class**: {@link PeriodicEmitter}
   * 
   * Emits particles periodically.
   */
  PeriodicEmitter = 300,
  /**
   * ### Action 301 - EqualDistanceEmitter
   * - **Slot**: {@link ActionSlots.EmitterAction Emitter}
   * - **Class**: {@link EqualDistanceEmitter}
   * 
   * Emits particles once it has moved a certain distance from where it last emitted particles.
   */
  EqualDistanceEmitter = 301,
  /**
   * ### Action 399 - OneTimeEmitter
   * - **Slot**: {@link ActionSlots.EmitterAction Emitter}
   * - **Class**: {@link OneTimeEmitter}
   * 
   * Emits one particle once.
   */
  OneTimeEmitter = 399,
  /**
   * ### Action 400 - PointEmitterShape
   * - **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
   * - **Class**: {@link PointEmitterShape}
   * 
   * Makes the emitter a single point.
   */
  PointEmitterShape = 400,
  /**
   * ### Action 401 - DiskEmitterShape
   * - **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
   * - **Class**: {@link DiskEmitterShape}
   * 
   * Makes the emitter disk-shaped.
   */
  DiskEmitterShape = 401,
  /**
   * ### Action 402 - RectangleEmitterShape
   * - **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
   * - **Class**: {@link RectangleEmitterShape}
   * 
   * Makes the emitter rectangular.
   */
  RectangleEmitterShape = 402,
  /**
   * ### Action 403 - SphereEmitterShape
   * - **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
   * - **Class**: {@link SphereEmitterShape}
   * 
   * Makes the emitter spherical.
   */
  SphereEmitterShape = 403,
  /**
   * ### Action 404 - BoxEmitterShape
   * - **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
   * - **Class**: {@link BoxEmitterShape}
   * 
   * Makes the emitter cuboidal.
   */
  BoxEmitterShape = 404,
  /**
   * ### Action 405 - CylinderEmitterShape
   * - **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
   * - **Class**: {@link CylinderEmitterShape}
   * 
   * Makes the emitter cylindrical.
   */
  CylinderEmitterShape = 405,
  /**
   * ### Action 500 - NoSpread
   * - **Slot**: {@link ActionSlots.DirectionSpreadAction DirectionSpread}
   * - **Class**: {@link NoSpread}
   * 
   * Makes all emitted instances have the default initial direction from the emitter. See {@link InitialDirection} for more information.
   */
  NoSpread = 500,
  /**
   * ### Action 501 - CircularSpread
   * - **Slot**: {@link ActionSlots.DirectionSpreadAction DirectionSpread}
   * - **Class**: {@link CircularSpread}
   * 
   * Gives each emitted instance a random initial direction offset within a circular cone. See {@link InitialDirection} for more information.
   */
  CircularSpread = 501,
  /**
   * ### Action 502 - EllipticalSpread
   * - **Slot**: {@link ActionSlots.DirectionSpreadAction DirectionSpread}
   * - **Class**: {@link EllipticalSpread}
   * 
   * Gives each emitted instance a random initial direction offset within an elliptical cone. See {@link InitialDirection} for more information.
   */
  EllipticalSpread = 502,
  /**
   * ### Action 503 - RectangularSpread
   * - **Slot**: {@link ActionSlots.DirectionSpreadAction DirectionSpread}
   * - **Class**: {@link RectangularSpread}
   * 
   * Gives each emitted instance a random initial direction offset within a rectangular cone. See {@link InitialDirection} for more information.
   */
  RectangularSpread = 503,
  /**
   * ### Action 600 - PointSprite
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link PointSprite}
   * 
   * Very basic point sprite particle. Similar to {@link ActionType.BillboardEx BillboardEx}, but far simpler.
   */
  PointSprite = 600,
  /**
   * ### Action 601 - Line
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link Line}
   * 
   * Simple line particle. It automatically rotates to match the direction it's moving.
   */
  Line = 601,
  /**
   * ### Action 602 - QuadLine
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link QuadLine}
   * 
   * Simple rectangular particle, very similar to {@link ActionType.Line Line particles}, but has properties that control the width as well as the length. It automatically rotates to match the direction it's moving.
   */
  QuadLine = 602,
  /**
   * ### Action 603 - BillboardEx
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link BillboardEx}
   * 
   * Particle with a texture that may be animated. This is the most common particle type and it has a lot of useful fields and properties.
   */
  BillboardEx = 603,
  /**
   * ### Action 604 - MultiTextureBillboardEx
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link MultiTextureBillboardEx}
   * 
   * Particle with multiple textures that can scroll.
   */
  MultiTextureBillboardEx = 604,
  /**
   * ### Action 605 - Model
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link Model}
   * 
   * Particle with a 3D model.
   * 
   * Some models don't work properly with this action for some reason. For example, the Carian greatsword model in Elden Ring (88300), gets horribly stretched and distorted when used with this action. If you find a model like this that you want to use, try using the {@link ActionType.RichModel RichModel action} instead.
   */
  Model = 605,
  /**
   * ### Action 606 - LegacyTracer
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link LegacyTracer}
   * 
   * Creates a trail behind moving effects.
   * 
   * This is an older version of {@link Tracer} with fewer features.
   */
  LegacyTracer = 606,
  /**
   * ### Action 607 - Distortion
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link Distortion}
   * 
   * A particle that distorts anything seen through it.
   * 
   * Note: This particle is not visible if the "Effects" setting is set to "Low".
   */
  Distortion = 607,
  /**
   * ### Action 608 - RadialBlur
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link RadialBlur}
   * 
   * A particle that applies a radial blur to anything seen through it.
   * 
   * Note: This particle is not visible if the "Effects" setting is set to "Low".
   */
  RadialBlur = 608,
  /**
   * ### Action 609 - PointLight
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link PointLight}
   * 
   * Point light source.
   */
  PointLight = 609,
  /**
   * ### Action 700 - SimulateTermination
   * - **Slot**: {@link ActionSlots.TerminationAction Termination}
   * - **Class**: {@link SimulateTermination}
   * 
   * Allows the effect to play out once it terminates. Particle emitters will stop emitting new particles, but particles with a finite duration that have already been emitted will stay around for as long as their duration allows them to.
   * 
   * Note: An effect terminates when it reaches {@link State} -1.
   */
  SimulateTermination = 700,
  /**
   * ### Action 701 - FadeTermination
   * - **Slot**: {@link ActionSlots.TerminationAction Termination}
   * - **Class**: {@link FadeTermination}
   * 
   * Allows the effect to continue playing normally after it terminates, but its opacity will gradually fade out over a given duration.
   * 
   * Note: An effect terminates when it reaches {@link State} -1.
   */
  FadeTermination = 701,
  /**
   * ### Action 702 - InstantTermination
   * - **Slot**: {@link ActionSlots.TerminationAction Termination}
   * - **Class**: {@link InstantTermination}
   * 
   * Makes the effect instantly disappear when it terminates.
   * 
   * Note: An effect terminates when it reaches {@link State} -1.
   */
  InstantTermination = 702,
  /**
   * ### Action 731 - NodeForceSpeed
   * - **Slot**: {@link ActionSlots.NodeForceMovementAction NodeForceMovement}
   * - **Class**: {@link NodeForceSpeed}
   * 
   * Controls how the node is affected by forces. For more information about forces that can affect nodes and particles, see:
   * - {@link ActionType.CancelForce CancelForce}
   * - {@link ActionType.WindForce WindForce}
   * - {@link ActionType.GravityForce GravityForce}
   * - {@link ActionType.ForceCollision ForceCollision}
   * - {@link ActionType.TurbulenceForce TurbulenceForce}
   */
  NodeForceSpeed = 731,
  /**
   * ### Action 732 - ParticleForceSpeed
   * - **Slot**: {@link ActionSlots.ParticleForceMovementAction ParticleForceMovement}
   * - **Class**: {@link ParticleForceSpeed}
   * 
   * Controls how the particles emitted by the node is affected by forces. For more information about forces that can affect nodes and particles, see:
   * - {@link ActionType.CancelForce CancelForce}
   * - {@link ActionType.WindForce WindForce}
   * - {@link ActionType.GravityForce GravityForce}
   * - {@link ActionType.ForceCollision ForceCollision}
   * - {@link ActionType.TurbulenceForce TurbulenceForce}
   */
  ParticleForceSpeed = 732,
  /**
   * ### Action 733 - NodeForceAcceleration
   * - **Slot**: {@link ActionSlots.NodeForceMovementAction NodeForceMovement}
   * - **Class**: {@link NodeForceAcceleration}
   * 
   * Controls how the node is affected by forces. For more information about forces that can affect nodes and particles, see:
   * - {@link ActionType.CancelForce CancelForce}
   * - {@link ActionType.WindForce WindForce}
   * - {@link ActionType.GravityForce GravityForce}
   * - {@link ActionType.ForceCollision ForceCollision}
   * - {@link ActionType.TurbulenceForce TurbulenceForce}
   */
  NodeForceAcceleration = 733,
  /**
   * ### Action 734 - ParticleForceAcceleration
   * - **Slot**: {@link ActionSlots.ParticleForceMovementAction ParticleForceMovement}
   * - **Class**: {@link ParticleForceAcceleration}
   * 
   * Controls how the particles emitted by the node is affected by forces. For more information about forces that can affect nodes and particles, see:
   * - {@link ActionType.CancelForce CancelForce}
   * - {@link ActionType.WindForce WindForce}
   * - {@link ActionType.GravityForce GravityForce}
   * - {@link ActionType.ForceCollision ForceCollision}
   * - {@link ActionType.TurbulenceForce TurbulenceForce}
   */
  ParticleForceAcceleration = 734,
  /**
   * ### Action 800 - ParticleForceCollision
   * - **Slot**: {@link ActionSlots.ParticleForceMovementAction ParticleForceMovement}
   * - **Class**: {@link ParticleForceCollision}
   * 
   * Enables particles emitted by the node to collide with surfaces, and controls how those collisions affect the movement of the particles.
   * 
   * Note that this works very differently from the collision-related fields in the GPU particle appearance actions. The collision detection for those are entriely based on the distances between the camera and everything in its view, so if a particle is farther away from the camera than an object, the particle will be able to collide with it. The collision detection used in this action is based on the real 3D geometry of the scene, so particles can collide with anything, even while they are out of view.
   * 
   * Also note that this action seems to cause the game to crash very easily. If a particle affected by this action despawns due to its limited duration, the game will crash no matter what.
   */
  ParticleForceCollision = 800,
  /**
   * ### Action 10000 - GPUStandardParticle
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link GPUStandardParticle}
   * 
   * An entire particle system in a single action. This emits GPU particles, which means thousands of particles can be rendered without much impact on performance.
   * 
   * Note that while this emits particles, it is itself not a particle, and the particles emitted by this action are not affected by everything that affects regular particles.
   * 
   * The name of this action is from Elden Ring's RTTI, where it's called "StandardParticle".
   */
  GPUStandardParticle = 10000,
  /**
   * ### Action 10001 - GPUStandardCorrectParticle
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link GPUStandardCorrectParticle}
   * 
   * Very similar to {@link ActionType.GPUStandardParticle GPUStandardParticle}, with no known differences.
   * 
   * The name of this action is from Elden Ring's RTTI, where it's called "StandardCorrectParticle". An action with the same ID had the name "WanderingVision" in Dark Souls 3, and that action could still exist in DS3, but it is not found in the vanilla game, so testing it is difficult.
   * 
   * Note: This action does not exist in Dark Souls 3 or Sekiro, but it still has unknown fields and properties named after those games. This is because it makes the conversion between this action and {@link ActionType.GPUStandardParticle GPUStandardParticle} much simpler. When written for those two games, this action will be converted to the other action automatically.
   */
  GPUStandardCorrectParticle = 10001,
  /**
   * ### Action 10003 - LightShaft
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link LightShaft}
   * 
   * A pretty simple light shafts effect only used in Dark Souls 3. It shows up if converted for Sekiro, but it doesn't seem to work correctly in that game. It does not seem to work at all in Elden Ring or Armored Core 6.
   */
  LightShaft = 10003,
  /**
   * ### Action 10008 - GPUSparkParticle
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link GPUSparkParticle}
   * 
   * Similar to {@link ActionType.GPUStandardParticle GPUStandardParticle}, this is essentially an entire particle system in a single action. It defines everything about an emitter as well as the particles it emits. The particles emitted by this action are GPU particles, which means that a lot of them can be rendered at the same time without much impact on performance. The particles are also not affected by most things that affect regular particles, like {@link ActionSlots.ParticleMovementAction ParticleMovement actions}.
   * 
   * What makes this different from {@link ActionType.GPUStandardParticle GPUStandardParticle} is that this actions seems to be designed specifically for effects that create sparks. While the other action's particles is more like billboard particles from, for example, {@link ActionType.BillboardEx BillboardEx}, this action's particles are more like {@link ActionType.QuadLine QuadLine} or {@link ActionType.Tracer Tracer} particles. They bend and rotate to align with the direction they are traveling, and they stretch based on how fast they're moving.
   * 
   * The name of this action is from Elden Ring's RTTI, where it's called "SparkParticle".
   * 
   * This action was first used in Armored Core 6, but definitely also works in Sekiro and Elden Ring. It might work in Dark Souls 3, but its structure is at least somewhat different there, and what that structure looks like is unknown. AC6's structure is compatible with Sekiro and ER, but some features may not work due to having been added in later versions.
   */
  GPUSparkParticle = 10008,
  /**
   * ### Action 10009 - GPUSparkCorrectParticle
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link GPUSparkCorrectParticle}
   * 
   * Very similar to {@link ActionType.GPUSparkParticle GPUSparkParticle}, just like how {@link ActionType.GPUStandardCorrectParticle GPUStandardCorrectParticle} is similar to {@link ActionType.GPUStandardParticle GPUStandardParticle}, except these two spark actions have some known differences.
   * 
   * Not all of the differences have been documented yet, but here are some:
   * - This action seems to have swapped some axes of rotation, causing some confusing things to happen when the node is spinning.
   * - The particles from this action are smaller.
   * - The particles from this action move slower. It's possible that this action uses a different unit of distance, since that would explain both the slower movement and the smaller particles.
   * 
   * The name of this action is from Elden Ring's RTTI, where it's called "SparkCorrectParticle".
   */
  GPUSparkCorrectParticle = 10009,
  /**
   * ### Action 10012 - Tracer
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link Tracer}
   * 
   * Creates a trail behind moving effects.
   * 
   * This is a newer version of {@link LegacyTracer} with more features, like being able to make the opacity of the trail be based on the movement speed of the particle.
   */
  Tracer = 10012,
  /**
   * ### Action 10013 - WaterInteraction
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link WaterInteraction}
   * 
   * Simulates an interaction with water, allowing effects to create ripples in nearby water. The interaction basically pushes water in a shape controlled by a texture down to a given depth and holds it there for a duration before releasing it.
   */
  WaterInteraction = 10013,
  /**
   * ### Action 10014 - LensFlare
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link LensFlare}
   * 
   * Creates lens flares with up to 4 textured layers with different colors and sizes.
   */
  LensFlare = 10014,
  /**
   * ### Action 10015 - RichModel
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link RichModel}
   * 
   * Particle with a 3D model. Similar to {@link ActionType.Model Model}, but with some different options.
   * 
   * Some models only work properly with this action and not with the Model action for some unknown reason. A good example of this is the Carian greatsword model in Elden Ring (88300), which gets horribly stretched and distorted when used with the other action, but it works fine with this one.
   * 
   * The name is from Elden Ring's RTTI.
   */
  RichModel = 10015,
  /**
   * ### Action 10100 - Unk10100
   * - **Slot**: {@link ActionSlots.Unknown10100Action Unknown10100}
   * - **Class**: {@link Unk10100}
   * 
   * Unknown root node action.
   */
  Unk10100 = 10100,
  /**
   * ### Action 10200 - CancelForce
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link CancelForce}
   * 
   * Cancels all forces in a volume. This includes wind from weather, and forces from the following actions:
   * - {@link ActionType.WindForce WindForce}
   * - {@link ActionType.GravityForce GravityForce}
   * - {@link ActionType.TurbulenceForce TurbulenceForce}
   * 
   * The name of this action is based on Elden Ring's RTTI, where it's called "ForceFieldCancelArea".
   */
  CancelForce = 10200,
  /**
   * ### Action 10300 - WindForce
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link WindForce}
   * 
   * Creates a directional force in a volume, which is most often useful for creating wind effects. The direction of the force is based on the direction of the node.
   * 
   * The name of this action is based on Elden Ring's RTTI, where it's called "ForceFieldWindArea".
   */
  WindForce = 10300,
  /**
   * ### Action 10301 - GravityForce
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link GravityForce}
   * 
   * Creates a radial force in a volume. This pulls things towards itself, or pushes away if the force is negative.
   * 
   * The name of this action is based on Elden Ring's RTTI, where it's called "ForceFieldGravityArea".
   */
  GravityForce = 10301,
  /**
   * ### Action 10302 - ForceCollision
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link ForceCollision}
   * 
   * Controls the volume used to detect whether or not the node is inside a force volume.
   * 
   * The name of this action is based on Elden Ring's RTTI, where it's called "CollisionFieldArea".
   */
  ForceCollision = 10302,
  /**
   * ### Action 10303 - TurbulenceForce
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link TurbulenceForce}
   * 
   * Creates a chaotic force in a volume.
   * 
   * The name of this action is based on Elden Ring's RTTI, where it's called "ForceFieldTurbulenceArea".
   */
  TurbulenceForce = 10303,
  /**
   * ### Action 10400 - Unk10400
   * - **Slot**: {@link ActionSlots.Unknown10400Action Unknown10400}
   * - **Class**: {@link Unk10400}
   * 
   * Unknown root node action.
   */
  Unk10400 = 10400,
  /**
   * ### Action 10500 - Unk10500
   * - **Slot**: {@link ActionSlots.Unknown10500Action Unknown10500}
   * - **Class**: {@link Unk10500}
   * 
   * Unknown root node action.
   */
  Unk10500 = 10500,
  /**
   * ### Action 11000 - SpotLight
   * - **Slot**: {@link ActionSlots.AppearanceAction Appearance}
   * - **Class**: {@link SpotLight}
   * 
   * Light source with an elliptic cone shape, a spot light.
   */
  SpotLight = 11000,
}

/**
 * Values used to represent different modes of attachment.
 */
export enum AttachMode {
  /**
   * Completely detached.
   */
  None = 0,
  /**
   * Translates and rotates with the parent node.
   */
  Parent = 1,
  /**
   * Translates and rotates with the attachment point (dummypoly). Parent transformations are ignored.
   */
  DummyPoly = 2,
  /**
   * Only translates with the parent node. Rotations are entirely ignored.
   */
  ParentTranslation = 3,
  /**
   * Only translates with the attachment point (dummypoly). Rotations are entirely ignored.
   */
  DummyPolyTranslation = 4,
}

/**
 * Values used to represent different types of blend modes.
 */
export enum BlendMode {
  /**
   * Seemingly identical to {@link Add}?
   */
  Unk0 = 0,
  /**
   * Completely ignores blending. The source layer (particle) will be drawn in place of the background, ignoring the alpha of the layer.
   */
  Source = 1,
  /**
   * The source layer (particle) will be drawn on over the background. Transparent or partially transparent parts of the layer will allow the background to be seen through the layer.
   * 
   * Also known as "source-over", and is the same as the "normal" blend mode found in many image editors.
   */
  Normal = 2,
  /**
   * The source layer (particle) will be multiplied with the background, ignoring the alpha of the layer.
   * 
   * Same as the "multiply" blend mode found in many image editors.
   */
  Multiply = 3,
  /**
   * The source layer (particle) multiplied by its alpha (clamped to [0, 1]) will be added to the background.
   * 
   * Same as the "add", "additive", or "linear dodge" blend modes found in many image editors. The opposite of {@link Subtract}.
   */
  Add = 4,
  /**
   * The source layer (particle) multiplied by its alpha (clamped to [0, 1]) will be subtracted from the background.
   * 
   * Same as the "subtract" or "difference" blend modes found in many image editors. The opposite of {@link Add}.
   */
  Subtract = 5,
  /**
   * Seemingly identical to {@link Normal}?
   */
  Unk6 = 6,
  /**
   * Seemingly identical to {@link Add}?
   */
  Unk7 = 7,
}

/**
 * Values used to represent different types of node configurations, also known as "effects". There is one for each {@link NodeType type of node} that supports multiple configs.
 */
export enum ConfigType {
  /**
   * Manages the duration and thresholds for the {@link NodeType.LevelsOfDetail levels of detail node}.
   * 
   * **Class**: {@link LevelsOfDetailConfig}
   */
  LevelsOfDetail = 1002,
  /**
   * Config used in {@link NodeType.Basic basic nodes} to apply transforms and to control emission and properties of particles.
   * 
   * **Class**: {@link BasicConfig}
   */
  Basic = 1004,
  /**
   * Config used in {@link NodeType.NodeEmitter node emitter nodes} to control the emission of child nodes.
   * 
   * **Class**: {@link NodeEmitterConfig}
   */
  NodeEmitter = 1005,
}

/**
 * Used by {@link ActionType.Distortion Distortion} particles to control what type of distortion to apply.
 */
export enum DistortionMode {
  /**
   * Distorts the background as if you stuck something into it and stirred it. It is animated, and the stir speed is controlled by a property.
   */
  Stir = 0,
  /**
   * Distorts the background based on the normal map.
   */
  NormalMap = 1,
  /**
   * Distorts the background as if the edges were held in place and you grabbed the center and twisted it.
   */
  Twist = 2,
  /**
   * Seemingly identical to {@link NormalMap}?
   */
  Unk3 = 3,
  /**
   * This seems to just squeeze everything to the bottom left corner?
   */
  Unk4 = 4,
}

/**
 * Possible shapes for {@link ActionType.Distortion distortion} particles.
 */
export enum DistortionShape {
  /**
   * A flat rectangle.
   */
  Rectangle = 0,
  /**
   * Half of an ellipsoid. (Like a hemisphere, but with three different radii.)
   */
  Hemiellipsoid = 1,
  /**
   * An ellipsoid. (Like a sphere, but with three different radii.)
   */
  Ellipsoid = 2,
}

/**
 * Emitter shapes for the following actions:
 * - {@link ActionType.GPUStandardParticle GPUStandardParticle}
 * - {@link ActionType.GPUStandardCorrectParticle GPUStandardCorrectParticle}
 * - {@link ActionType.GPUSparkParticle GPUSparkParticle}
 * - {@link ActionType.GPUSparkCorrectParticle GPUSparkCorrectParticle}
 * 
 * Not related to the {@link ActionSlots.EmitterShapeAction emitter shape actions}.
 */
export enum EmitterShape {
  /**
   * A simple line.
   */
  Line = 0,
  /**
   * A cuboid.
   * 
   * The difference between this and {@link Box2} is how the
   * {@link GPUStandardParticle.emitterDistribution distribution} field acts on it.
   */
  Box = 1,
  /**
   * A cuboid.
   * 
   * The difference between this and {@link Box} is how the
   * {@link GPUStandardParticle.emitterDistribution distribution} field acts on it.
   */
  Box2 = 2,
  /**
   * Seemingly identical to {@link Line}?
   */
  Unk3 = 3,
  /**
   * A cylinder.
   */
  Cylinder = 4,
  /**
   * Not yet tested. Found in 800020 in Sekiro.
   */
  Unk5 = 5,
}

/**
 * Values representing different shapes of the volume where force actions apply their force.
 */
export enum ForceVolumeShape {
  /**
   * Allows the force to affect everything, everywhere.
   */
  Boundless = 0,
  /**
   * A spherical volume.
   */
  Sphere = 1,
  /**
   * A cuboid volume.
   */
  Box = 2,
  /**
   * A cylindrical volume.
   */
  Cylinder = 3,
  /**
   * A square prism volume.
   */
  SquarePrism = 4,
}

/**
 * An emitted instance's initial direction is used for various things that require a direction, but does not have a set one to follow.
 * - {@link ActionType.ParticleModifier ParticleModifier action}'s {@link ParticleModifier.speed speed}.
 * - {@link ActionType.Line Line action}'s initial rotation.
 * - {@link ActionType.QuadLine QuadLine action}'s initial rotation.
 * 
 * The initial direction can be further modified by the following actions:
 * - {@link ActionType.NoSpread NoSpread}
 * - {@link ActionType.CircularSpread CircularDirectionSpread}
 * - {@link ActionType.EllipticalSpread EllipticalDirectionSpread}
 * - {@link ActionType.RectangularSpread RectangularDirectionSpread}
 */
export enum InitialDirection {
  /**
   * The direction will depend on the emitter shape.
   * | Emitter&nbsp;Shape | Direction |
   * |:-|:-|
   * | {@link ActionType.PointEmitterShape Point} | Same as {@link LocalNorth}. |
   * | {@link ActionType.DiskEmitterShape Disk} | Same as {@link LocalNorth}. |
   * | {@link ActionType.RectangleEmitterShape Rectangle} | Same as {@link LocalNorth}. |
   * | {@link ActionType.SphereEmitterShape Sphere} | The direction cannot be changed for this emitter shape. |
   * | {@link ActionType.BoxEmitterShape Box} | If {@link BoxEmitterShape.emitInside emitInside} is true, it picks a direction parallel to a random local axis. If it is false, the direction will be out from the box, perpendicular to the side where the particle was emitted. |
   * | {@link ActionType.CylinderEmitterShape Cylinder} | Out from the cylinder's axis. |
   */
  Emitter = 0,
  /**
   * Global up. (+Y)
   */
  Up = 1,
  /**
   * Global down. (-Y)
   */
  Down = 2,
  /**
   * Global north. (+Z)
   */
  North = 3,
  /**
   * Local up. (+Y)
   */
  LocalUp = 4,
  /**
   * Local down. (-Y)
   */
  LocalDown = 5,
  /**
   * Local north. (+Z)
   */
  LocalNorth = 6,
}

/**
 * Values representing different lighting modes.
 * 
 * These values and the fields they are used in require more testing. It's best to not assume they will work exactly as described. Values not covered by this enum are also used in vanilla effects, so there are a lot of unknown things about this.
 */
export enum LightingMode {
  /**
   * Same as {@link Lit}, but this seems to sometimes have an extra light source from somewhere?
   */
  UnkMinus2 = -2,
  /**
   * Lighting does not affect the particles. No shadows or specular hightlights.
   */
  Unlit = -1,
  /**
   * Lighting affects the particles just like most regular objects.
   */
  Lit = 0,
}

/**
 * Values representing different orientation modes for {@link ActionType.Model Model} particles.
 */
export enum ModelOrientationMode {
  /**
   * Faces global north.
   */
  North = 0,
  /**
   * Faces away from the camera plane, the same direction as the camera itself.
   */
  CameraPlane = 1,
  /**
   * Faces in the direction the particle is moving. This direction can be modified by {@link ActionSlots.DirectionSpreadAction DirectionSpread actions}, and is initially the particle's {@link InitialDirection}.
   */
  ParticleDirection = 2,
  /**
   * Tries to face the camera, but is limited to rotation around the global X-axis.
   * 
   * Seemingly identical to {@link UnkGlobalPitch}?
   */
  GlobalPitch = 3,
  /**
   * Tries to face the camera, but is limited to rotation around the vertical global Y-axis.
   */
  GlobalYaw = 4,
  /**
   * Tries to face the camera, but is limited to rotation around the global X-axis.
   * 
   * Seemingly identical to {@link GlobalPitch}?
   */
  UnkGlobalPitch = 5,
}

/**
 * Values used to represent different types of FXR nodes.
 */
export enum NodeType {
  /**
   * The root of the FXR tree structure.
   * 
   * **Class**: {@link RootNode}
   */
  Root = 2000,
  /**
   * Acts as a node containing another SFX.
   * 
   * **Class**: {@link ProxyNode}
   */
  Proxy = 2001,
  /**
   * A node that only displays one of its child nodes at a time based on distance thresholds for each.
   * 
   * **Class**: {@link LevelsOfDetailNode}
   */
  LevelsOfDetail = 2002,
  /**
   * A basic node that can emit particles, play sounds, have transforms and child nodes.
   * 
   * **Class**: {@link BasicNode}
   */
  Basic = 2200,
  /**
   * A node that emits its child nodes.
   * 
   * **Class**: {@link NodeEmitterNode}
   */
  NodeEmitter = 2202,
}

/**
 * Values representing different orientation modes for most particles.
 */
export enum OrientationMode {
  /**
   * Faces global south.
   * 
   * See also:
   * - {@link UnkSouth}
   */
  South = 0,
  /**
   * Faces the camera plane.
   * 
   * See also:
   * - {@link Camera}
   */
  CameraPlane = 1,
  /**
   * Faces the -Z direction of the parent node.
   */
  LocalSouth = 2,
  /**
   * Faces global south.
   * 
   * Similar to {@link South}, but this seems to change the projection of the particle in some way.
   */
  UnkSouth = 3,
  /**
   * Tries to face the camera, but is limited to rotation around the vertical global Y-axis.
   */
  GlobalYaw = 4,
  /**
   * Faces global east.
   */
  East = 5,
  /**
   * Faces the camera.
   * 
   * This is different from {@link CameraPlane}, as this makes it face the camera's position instead of the camera plane.
   */
  Camera = 6,
  /**
   * Tries to face the camera, but is limited to rotation around the Y-axis of the parent node.
   */
  LocalYaw = 7,
  /**
   * Not yet tested. Found in 639742 in Elden Ring. This also implies the existence of 8, 9, and 10, but they have not been tested or found yet.
   */
  Unk11 = 11,
}

/**
 * Arguments used when evaluating properties.
 * 
 * There is no way to change what argument is given to a property. Each property has one specific argument given to it, and this is sometimes the only difference between two properties in the same action.
 */
export enum PropertyArgument {
  /**
   * A constant value of 0.
   */
  Constant0 = 0,
  /**
   * Time in seconds since the particle was emitted.
   */
  ParticleAge = 1,
  /**
   * Time in seconds since the action became active.
   * 
   * An action becoming active is for example the delay from {@link ActionType.NodeAttributes NodeAttributes} being over, or the active {@link State} changing, making a node change which of its configs is active.
   */
  ActiveTime = 2,
  /**
   * Time in seconds between the effect being created and the particle being emitted. Stays constant per particle.
   */
  EmissionTime = 3,
  /**
   * An external value.
   * 
   * In property modifiers, which external value is used is controlled by a field in the modifier.
   */
  ExternalValue = 4,
}

/**
 * Used by {@link ActionType.LensFlare lens flares} to control the direction of the offset vector.
 */
export enum ReflectionMode {
  /**
   * No offsets. The flare(s) will appear at the source's position.
   */
  None = 0,
  /**
   * The source's screen-space position will be reflected through the center of the screen to calculate the offset vector.
   */
  Radial = 1,
  /**
   * The source's screen-space position will be flipped horizontally to calculate the offset vector.
   */
  Horizontal = 2,
}

/**
 * Values representing different orientation modes for {@link ActionType.RichModel RichModel} particles.
 */
export enum RichModelOrientationMode {
  /**
   * Faces global north.
   * 
   * Seemingly identical to {@link UnkNorth}?
   */
  North = 0,
  /**
   * Faces away from the camera plane, the same direction as the camera itself.
   */
  CameraPlane = 1,
  /**
   * Faces in the direction the particle is moving. This direction can be modified by {@link ActionSlots.DirectionSpreadAction DirectionSpread actions}, and is initially the particle's {@link InitialDirection}.
   */
  ParticleDirection = 2,
  /**
   * Faces global north.
   * 
   * Seemingly identical to {@link North}?
   */
  UnkNorth = 3,
  /**
   * Tries to face the camera, but is limited to rotation around the vertical global Y-axis.
   */
  GlobalYaw = 4,
}

/**
 * Values representing different orientation modes for {@link ActionType.Tracer Tracer} and {@link ActionType.LegacyTracer LegacyTracer} particles.
 */
export enum TracerOrientationMode {
  /**
   * The tracer source is perpendicular to the direction it's travelling and the direction of the camera.
   */
  Travel = 0,
  /**
   * The tracer source is aligned with the local Z-axis, which is detenmined by the rotation of the node that emits the tracer.
   */
  LocalZ = 1,
  /**
   * The tracer source is aligned with the global vertical axis.
   */
  Vertical = 2,
  /**
   * The tracer source is aligned with the global X-axis.
   */
  GlobalX = 3,
  /**
   * Creates two sources for the tracer with different orientation modes. One has {@link Vertical} and the other has {@link GlobalX}, forming a cross.
   */
  Cross = 4,
  /**
   * The tracer source is parallel to the global diagonal (1, 1, 1).
   */
  Diagonal = 5,
}
/*#Enums end*/

enum ValueType {
  Scalar = 0,
  Vector2 = 1,
  Vector3 = 2,
  Vector4 = 3
}

enum PropertyFunction {
  /**
   * Always returns 0 for each component.
   */
  Zero = 0,
  /**
   * Always returns 1 for each component.
   */
  One = 1,
  /**
   * Always returns the value in the property's fields.
   * 
   * **Class**: {@link ConstantProperty}
   */
  Constant = 2,
  /**
   * Uses step interpolation to interpolate the property's values.
   * 
   * **Class**: {@link SteppedProperty}
   */
  Stepped = 3,
  /**
   * Uses linear interpolation to interpolate the property's values.
   * 
   * **Class**: {@link LinearProperty}
   */
  Linear = 4,
  /**
   * Uses a cubic Bezier spline to interpolate the property's values.
   * 
   * **Class**: {@link BezierProperty}
   */
  Bezier = 5,
  /**
   * Uses a cubic Hermite spline to interpolate the property's values.
   * 
   * **Class**: {@link HermiteProperty}
   */
  Hermite = 6,
  /**
   * Same as {@link Hermite}, but allows each component to have a different
   * number of keyframes.
   * 
   * Only available in Armored Core 6.
   * 
   * **Class**:  {@link ComponentSequenceProperty}
   */
  ComponentHermite = 7
}

enum ModifierType {
  /**
   * Makes a property's value randomly vary by up to a given maximum from the
   * property's base value. In other words, if `p` is the property's base value
   * and `max` is the {@link RandomDeltaModifier.max maximum difference}, the
   * property's modified value will be between `p - max` and `p + max`.
   * 
   * **Class**: {@link RandomDeltaModifier}
   */
  RandomDelta = 21,
  /**
   * Adds a random value in a given range to a property's value.
   * 
   * **Class**: {@link RandomRangeModifier}
   */
  RandomRange = 24,
  /**
   * Modifies a property's value by multiplying it with different values
   * depending on an {@link ExternalValue external value}.
   * 
   * **Class**:  {@link ExternalValue1Modifier}
   */
  ExternalValue1 = 38,
  /**
   * Similar to {@link ExternalValue1}, but it has some extra restrictions, and
   * it does not update after the effect has been created. For this to update,
   * the effect must be respawned.
   * 
   * The restrictions may depend on the game. In Elden Ring, it seems to only
   * work with the {@link ExternalValue.EldenRing.BloodVisibility DisplayBlood}
   * external value, but Armored Core 6 uses it for external value 2000.
   * 
   * **Class**:  {@link ExternalValue2Modifier}
   */
  ExternalValue2 = 39,
  /**
   * Makes a property's value randomly vary by up to a given maximum fraction
   * from the property's base value. In other words, if `p` is the property's
   * base value and `max` is the
   * {@link RandomFractionModifier.max maximum fraction}, the property's
   * modified value will be between `p - p * max` and `p + p * max`.
   * 
   * **Class**:  {@link RandomFractionModifier}
   */
  RandomFraction = 53,
}

enum FieldType {
  Boolean,
  Integer,
  Float,
  Vector2,
  Vector3,
  Vector4,
}

namespace ExternalValue {
  export enum DarkSouls3 {
    /**
     * This value will be set to 1 when the effect is meant to end due to the
     * source of the effect going away, for example when the SpawnOneShotFFX
     * event ends and it has IsRestrictToDummyPoly enabled. The value is
     * otherwise 0.
     */
    Terminate = 0,
    /**
     * Based on the "Blood" setting.
     * - Off: `-1`
     * - On: `0`
     * - Mild: `1`
     */
    BloodVisibility = 10000,
  }
  export enum Sekiro {
    /**
     * This value will be set to 1 when the effect is meant to end due to the
     * source of the effect going away, for example when the SpawnOneShotFFX
     * event ends and it has IsRestrictToDummyPoly enabled. The value is
     * otherwise 0.
     */
    Terminate = 0,
    /**
     * Based on the "Blood" setting.
     * - Off: `-1`
     * - On: `0`
     * - Mild: `1`
     */
    BloodVisibility = 10000,
  }
  export enum EldenRing {
    /**
     * This value will be set to 1 when the effect is meant to end due to the
     * source of the effect going away, for example when the SpawnOneShotFFX
     * event ends and it has IsRestrictToDummyPoly enabled. The value is
     * otherwise 0.
     */
    Terminate = 0,
    /**
     * This value is 1 if it's raining or snowing, and 0 otherwise.
     */
    Precipitation = 1,
    /**
     * This represents the the time of day. At midnight, the value is 0, at
     * noon it is 12, and then it goes up to 24 before wrapping back to 0, just
     * like the hours on the clock.
     */
    TimeOfDay = 2,
    /**
     * This is based on the distance between the SFX and the camera.
     * 
     * The range is 0-1, the distance is converted in some unknown way.
     * 
     * It does not always work for all sources of effects. This is used by the
     * beacon effect, so it definitely works there.
     */
    SFXDistance = 1000,
    /**
     * This value is set through the Special Attribute param field on weapons.
     */
    HitEffectVariation = 2000,
    Unk2100 = 2100, // Blood related?
    Unk2200 = 2200, // Blood related?
    /**
     * Based on the "Display Blood" setting.
     * - Off: `-1`
     * - On: `0`
     * - Mild: `1`
     */
    BloodVisibility = 10000,
  }
  export enum ArmoredCore6 {
    /**
     * This value will be set to 1 when the effect is meant to end due to the
     * source of the effect going away, for example when the SpawnOneShotFFX
     * event ends and it has IsRestrictToDummyPoly enabled. The value is
     * otherwise 0.
     */
    Terminate = 0,
    Unk1 = 1,
    Unk3 = 3,
    Unk1000 = 1000,
    /**
     * The distance from the camera to the SFX in meters.
     */
    SFXDistance = 2000,
    Unk20000 = 20000,
    Unk40000 = 40000,
    Unk70000 = 70000,
    Unk70010 = 70010,
    Unk70020 = 70020,
    /**
     * The "Scan Distance" value on the player AC's currently equipped head part.
     */
    ScanDistance = 70200,
  }
  export enum Nightreign {
    /**
     * This value will be set to 1 when the effect is meant to end due to the
     * source of the effect going away, for example when the SpawnOneShotFFX
     * event ends and it has IsRestrictToDummyPoly enabled. The value is
     * otherwise 0.
     */
    Terminate = 0,
    Unk1 = 1, // Precipitation?
    /**
     * This represents the the time of day. At midnight, the value is 0, at
     * noon it is 12, and then it goes up to 24 before wrapping back to 0, just
     * like the hours on the clock.
     */
    TimeOfDay = 2,
    Unk1000 = 1000, // Distance?
    Unk2000 = 2000, // Hit effect variation?
    Unk2100 = 2100,
    Unk2200 = 2200,
    Unk4000 = 4000,
    /**
     * Based on the "Display Blood" setting.
     * - Off: `-1`
     * - On: `0`
     * - Mild: `1`
     */
    BloodVisibility = 10000,
  }
}

enum Operator {
  NotEqual = 0,
  Equal = 1,
  GreaterThanOrEqual = 2,
  GreaterThan = 3,

  /*
    These two are not part of the format. The StateCondition class will just
    switch the operands around and use the greater than operators automatically
    when these are used.
  */
  LessThanOrEqual = 4,
  LessThan = 5,
}

enum OperandType {
  /**
   * The field's value, literally.
   */
  Literal = -4,
  /**
   * Gets an external value.
   * 
   * The field refers to an {@link ExternalValue}.
   */
  External = -3,
  /**
   * Based on movement in some way?
   * 
   * Does not require a field.
   */
  UnkMinus2 = -2,
  /**
   * The time since the effect changed state in seconds.
   * 
   * Does not require a field.
   */
  StateTime = -1,
}

enum ResourceType {
  Texture = 0,
  Model = 1,
  Anibnd = 2,
  Sound = 3,
}

/**
 * This represents a condition for scaling a {@link DataAction data action}
 * property.
 * 
 * Used internally in {@link DataAction.prototype.scale} to handle some special
 * properties that should not always be scaled.
 */
export enum ScaleCondition {
  /**
   * Always scale the property, unless {@link ScaleOptions.scaleStructural scaleStructural}
   * is *disabled*.
   */
  True = 1,
  /**
   * Only scale the property if {@link ScaleOptions.scaleViewDistance scaleViewDistance}
   * and {@link ScaleOptions.scaleStructural scaleStructural} are *enabled*.
   */
  Distance = 2,
  /**
   * Only scale the property if the value is not -1 and
   * {@link ScaleOptions.scaleViewDistance scaleViewDistance} and
   * {@link ScaleOptions.scaleStructural scaleStructural} are *enabled*.
   */
  DistanceIfNotMinusOne = 3,
  /**
   * Only scale the property if {@link ScaleOptions.scaleParticleModifier scaleParticleModifier}
   * is *disabled*.
   */
  InstanceSize = 4,
  /**
   * Only scale the property if {@link ScaleOptions.scaleParticleModifier scaleParticleModifier}
   * is *enabled*.
   */
  ParticleModifier = 5,
  /**
   * Always scaled.
   */
  RawInstanceSize = 6,
}

/**
 * This represents an operation to use when modifying values that depend on
 * time.
 * 
 * Used internally to track how time-based values should be scaled by
 * {@link DataAction.prototype.scaleRateOfTime}.
 */
export enum TimeOperation {
  Multiply = 1,
  Divide = 2,
  DivideIfPositive = 3,
  Square = 4,
  /**
   * The tracer segment duration fields are not scaled by the rate of time
   * property, but scaling it may still be desired in some cases, so these
   * fields are marked with this value so they can get special handling.
   */
  TracerDuration = 5,
}

/**
 * Controls the sampling behavior of functions used to generate color palettes.
 */
export enum PaletteMode {
  /**
   * Only add the first set of colors found for each palette slot.
   */
  First,
  /**
   * Average all sets of colors found that fit the same palette slot into a
   * single entry for the slot. This effectively creates a palette that will
   * recolor effects to match a kind of average of the sampled effects.
   */
  Average,
  /**
   * Add all sets of colors found for all slots. This will create a palette
   * that recolors effects randomly based on the colors in the sampled effects.
   */
  Random,
}

//#region Types / Interfaces
type KeysOfType<T, U> = {
  [K in keyof T]: T[K] extends U ? K : never
}[keyof T]

type Entries<T> = {
  [K in keyof T]: [K, T[K]]
}[keyof T][]

export type AtLeastOne<T> = [T, ...T[]]
export type OptionalTail<Head, Tail> =
  | AtLeastOne<Head>
  | [...AtLeastOne<Head>, Tail]

export type AnyExternalValue =
  | ExternalValue.DarkSouls3
  | ExternalValue.Sekiro
  | ExternalValue.EldenRing
  | ExternalValue.ArmoredCore6

export type ValuePropertyFunction =
  | PropertyFunction.Zero
  | PropertyFunction.One
  | PropertyFunction.Constant

export type SequencePropertyFunction =
  | PropertyFunction.Stepped
  | PropertyFunction.Linear
  | PropertyFunction.Bezier
  | PropertyFunction.Hermite

export type ComponentSequencePropertyFunction = PropertyFunction.ComponentHermite

export namespace TypeMap {
  export type PropertyValue = {
    [ValueType.Scalar]: number
    [ValueType.Vector2]: Vector2
    [ValueType.Vector3]: Vector3
    [ValueType.Vector4]: Vector4
  }
  export type Value = {
    [ValueType.Scalar]: ScalarValue
    [ValueType.Vector2]: Vector2Value
    [ValueType.Vector3]: Vector3Value
    [ValueType.Vector4]: Vector4Value
  }
  export type Property = {
    [ValueType.Scalar]: ScalarProperty
    [ValueType.Vector2]: Vector2Property
    [ValueType.Vector3]: Vector3Property
    [ValueType.Vector4]: Vector4Property
  }
  export type Keyframe<T extends ValueType> = {
    [PropertyFunction.Stepped]: IBasicKeyframe<T>
    [PropertyFunction.Linear]: IBasicKeyframe<T>
    [PropertyFunction.Bezier]: IBezierKeyframe<T>
    [PropertyFunction.Hermite]: IHermiteKeyframe<T>
  }
  export type FieldTypeName = {
    [FieldType.Boolean]: 'Boolean'
    [FieldType.Integer]: 'Integer'
    [FieldType.Float]: 'Float'
    [FieldType.Vector2]: 'Vector2'
    [FieldType.Vector3]: 'Vector3'
    [FieldType.Vector4]: 'Vector4'
  }
  export type FieldValue = {
    [FieldType.Boolean]: boolean
    [FieldType.Integer]: number
    [FieldType.Float]: number
    [FieldType.Vector2]: Vector2
    [FieldType.Vector3]: Vector3
    [FieldType.Vector4]: Vector4
  }
  export type VectorComponents = {
    [ValueType.Vector2]: Vector2Components
    [ValueType.Vector3]: Vector3Components
    [ValueType.Vector4]: Vector4Components
  }
}

export interface IBasicKeyframe<T extends ValueType> {
  position: number
  value: TypeMap.PropertyValue[T]
}

export interface IBezierKeyframe<T extends ValueType> extends IBasicKeyframe<T> {
  p1: TypeMap.PropertyValue[T]
  p2: TypeMap.PropertyValue[T]
}

export interface IHermiteKeyframe<T extends ValueType> extends IBasicKeyframe<T> {
  t1: TypeMap.PropertyValue[T]
  t2: TypeMap.PropertyValue[T]
}

export type AnyKeyframe<T extends ValueType> =
  | IBasicKeyframe<T>
  | IBezierKeyframe<T>
  | IHermiteKeyframe<T>

export type ScalarKeyframeFromAny<K extends AnyKeyframe<T>, T extends ValueType> =
  K extends IBezierKeyframe<T> ? IBezierKeyframe<ValueType.Scalar> :
  K extends IHermiteKeyframe<T> ? IHermiteKeyframe<ValueType.Scalar> :
  IBasicKeyframe<ValueType.Scalar>

export interface IProperty<T extends ValueType, F extends PropertyFunction> {
  valueType: T
  function: F
  componentCount: number
  fieldCount: number
  fields: NumericalField[]
  toJSON(): any
  serialize(options?: FXRSerializeOptions): any
  scale(factor: TypeMap.PropertyValue[T] | number): this
  add(summand: TypeMap.PropertyValue[T] | number): this
  valueAt(arg: number): TypeMap.PropertyValue[T]
  clone(): IProperty<T, F>
  separateComponents(): IProperty<ValueType.Scalar, F>[]
  for(game: Game): IProperty<T, F>
  min(): TypeMap.PropertyValue[T]
  max(): TypeMap.PropertyValue[T]
  minify(): IProperty<T, PropertyFunction>
}

export interface IModifiableProperty<T extends ValueType, F extends PropertyFunction> extends IProperty<T, F> {
  modifiers: IModifier<T>[]
}

export interface IAction {
  readonly type: ActionType
  readonly $data: ActionDataEntry
  toJSON(): any
  serialize(options?: FXRSerializeOptions): any
  /**
   * Creates a minified version of this action.
   * 
   * Some actions can be minified to make the output smaller. This is done by
   * creating a simpler action that is functionally equivalent to this action.
   * 
   * Actions that can not be minified will not be changed.
   */
  minify(): AnyAction
  clone(): IAction
}

export interface IConfig {
  readonly type: ConfigType

  /**
   * Returns the number of actions this config will contain if written to the
   * given `game`'s structure.
   */
  getActionCount(game: Game): number

  /**
   * Returns and array of the actions this config will contain if written to
   * the given `game`'s structure.
   */
  getActions(game: Game): AnyAction[]

  /**
   * Create a deep copy of this config.
   */
  clone(): IConfig

  /**
   * Scale the config by the given `factor`. This can be used to change
   * the size of effect created by the config.
   */
  scale(factor: number, options?: ScaleOptions): this

  toJSON(): any
  serialize(options?: FXRSerializeOptions): any
  minify(): this
  walkActions(): Generator<AnyAction>
}

export interface IModifier<T extends ValueType> {
  readonly type: ModifierType
  readonly valueType: T
  getFieldCount(): number
  getFields(): Field<FieldType>[]
  getPropertyCount(): number
  getProperties(game: Game): AnyProperty[]
  toJSON(): any
  serialize(options?: FXRSerializeOptions): any
  clone(): IModifier<T>
  separateComponents(): IModifier<ValueType.Scalar>[]
  minify(): IModifier<T>
}

export interface NodeColorOptions {
  activeState?: number
  side?: 'start' | 'end' | 'middle'
  layer?: number
}

export interface ScaleOptions {
  /**
   * Scale the scale properties in {@link ParticleModifier} actions _instead
   * of_ those in the appearance actions.
   * 
   * Defaults to `false`.
   */
  scaleParticleModifier?: boolean
  /**
   * Scale properties that are based on the distance to the camera, such as the
   * min/max distance for many apperance actions.
   * 
   * Defaults to `false`.
   */
  scaleViewDistance?: boolean
  /**
   * Scale properties that control the size of the structure of the effect,
   * i.e. ones that don't affect the size of the appearance instances, except
   * the emitter size for GPU particle actions.
   * 
   * Defaults to `true`.
   */
  scaleStructural?: boolean
}

const defaultScaleOptions: ScaleOptions = {
  scaleStructural: true,
}

export type AnyAction = Action | DataAction
export type Vector2 = [x: number, y: number]
export type Vector3 = [x: number, y: number, z: number]
export type Vector4 = [red: number, green: number, blue: number, alpha: number]
export type Vector = Vector2 | Vector3 | Vector4
export type PropertyValue = number | Vector
export type AnyProperty = Property<any, PropertyFunction>
export type ScalarProperty = Property<ValueType.Scalar, PropertyFunction>
export type Vector2Property = Property<ValueType.Vector2, PropertyFunction>
export type Vector3Property = Property<ValueType.Vector3, PropertyFunction>
export type Vector4Property = Property<ValueType.Vector4, PropertyFunction>
export type VectorProperty = Vector2Property | Vector3Property | Vector4Property
export type AnyValue = AnyProperty | PropertyValue
export type ScalarValue = number | ScalarProperty
export type Vector2Value = Vector2 | Vector2Property
export type Vector3Value = Vector3 | Vector3Property
export type Vector4Value = Vector4 | Vector4Property
export type VectorValue = Vector | VectorProperty
export type NumericalField = Field<FieldType.Integer | FieldType.Float>
export type VectorValueType = Exclude<ValueType, ValueType.Scalar>
export type Vector2Components = [ScalarValue, ScalarValue]
export type Vector3Components = [ScalarValue, ScalarValue, ScalarValue]
export type Vector4Components = [ScalarValue, ScalarValue, ScalarValue, ScalarValue]
export type VectorComponents = Vector2Components | Vector3Components | Vector4Components

export type GenComponents<T, V extends ValueType> = [
  [T], [T, T], [T, T, T], [T, T, T, T]
][V]

export type NodeMovementProps = Partial<
  | Props<NodeSpin>
  | Props<NodeAcceleration>
  | Props<NodeAccelerationRandomTurns>
  | Props<NodeAccelerationPartialFollow>
  | Props<NodeAccelerationSpin>
  | Props<NodeSpeed>
  | Props<NodeSpeedRandomTurns>
  | Props<NodeSpeedPartialFollow>
  | Props<NodeSpeedSpin>
>

export type NodeTransformProps = Partial<
  | Props<StaticNodeTransform>
  | Props<RandomNodeTransform>
>

export type ParticleMovementProps = Partial<
  | Props<ParticleAcceleration>
  | Props<ParticleAccelerationRandomTurns>
  | Props<ParticleAccelerationPartialFollow>
  | Props<ParticleSpeed>
  | Props<ParticleSpeedRandomTurns>
  | Props<ParticleSpeedPartialFollow>
>

export namespace ActionSlots {
/*#ActionSlotTypes start*/
  export type AppearanceAction =
    | PointSprite
    | Line
    | QuadLine
    | BillboardEx
    | MultiTextureBillboardEx
    | Model
    | LegacyTracer
    | Distortion
    | RadialBlur
    | PointLight
    | GPUStandardParticle
    | GPUStandardCorrectParticle
    | LightShaft
    | GPUSparkParticle
    | GPUSparkCorrectParticle
    | Tracer
    | WaterInteraction
    | LensFlare
    | RichModel
    | CancelForce
    | WindForce
    | GravityForce
    | ForceCollision
    | TurbulenceForce
    | SpotLight
    | Action

  export type DirectionSpreadAction =
    | NoSpread
    | CircularSpread
    | EllipticalSpread
    | RectangularSpread
    | Action

  export type EmissionAudioAction =
    | EmissionSound
    | Action

  export type EmitterAction =
    | PeriodicEmitter
    | EqualDistanceEmitter
    | OneTimeEmitter
    | Action

  export type EmitterShapeAction =
    | PointEmitterShape
    | DiskEmitterShape
    | RectangleEmitterShape
    | SphereEmitterShape
    | BoxEmitterShape
    | CylinderEmitterShape
    | Action

  export type LevelsOfDetailThresholdsAction =
    | LevelsOfDetailThresholds
    | Action

  export type NodeAttributesAction =
    | NodeAttributes
    | Action

  export type NodeAudioAction =
    | NodeSound
    | Action

  export type NodeForceMovementAction =
    | NodeForceSpeed
    | NodeForceAcceleration
    | Action

  export type NodeMovementAction =
    | NodeAcceleration
    | NodeTranslation
    | NodeSpin
    | NodeAttachToCamera
    | NodeAccelerationRandomTurns
    | NodeAccelerationPartialFollow
    | NodeAccelerationSpin
    | NodeSpeed
    | NodeSpeedRandomTurns
    | NodeSpeedPartialFollow
    | NodeSpeedSpin
    | Action

  export type NodeSelectorAction =
    | SelectAllNodes
    | SelectRandomNode
    | Action

  export type NodeTransformAction =
    | StaticNodeTransform
    | RandomNodeTransform
    | Action

  export type ParticleAttributesAction =
    | ParticleAttributes
    | Action

  export type ParticleForceMovementAction =
    | ParticleForceSpeed
    | ParticleForceAcceleration
    | ParticleForceCollision
    | Action

  export type ParticleModifierAction =
    | ParticleModifier
    | Action

  export type ParticleMovementAction =
    | ParticleAcceleration
    | ParticleSpeed
    | ParticleSpeedRandomTurns
    | ParticleSpeedPartialFollow
    | ParticleAccelerationRandomTurns
    | ParticleAccelerationPartialFollow
    | Action

  export type SFXReferenceAction =
    | SFXReference
    | Action

  export type StateConfigMapAction =
    | StateConfigMap
    | Action

  export type TerminationAction =
    | SimulateTermination
    | FadeTermination
    | InstantTermination
    | Action

  export type Unknown130Action =
    | Unk130
    | Action

  export type Unknown10100Action =
    | Unk10100
    | Action

  export type Unknown10400Action =
    | Unk10400
    | Action

  export type Unknown10500Action =
    | Unk10500
    | Action
/*#ActionSlotTypes end*/
}

export type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B
export type WritableKeys<T> = {
  [K in keyof T]: IfEquals<{ [P in K]: T[K] }, { -readonly [P in K]: T[K] }, K>
}[keyof T]
export type NonFunctionKeys<T> = {
  [K in keyof T]: T[K] extends Function ? never : K
}[keyof T]
export type Props<T> = Pick<T, WritableKeys<T> & NonFunctionKeys<T>>

//#region Action Data
export type ActionGameDataEntry = {
  fields1?: Game | (string[] & { fieldsCount?: number })
  fields2?: Game | (string[] & { fieldsCount?: number })
  properties1?: string[] | Game
  properties2?: string[] | Game
  section10s?: string[] | Game
}
export type FilledActionGameDataEntry = {
  fields1?: string[] & { fieldsCount?: number }
  fields2?: string[] & { fieldsCount?: number }
  properties1?: string[]
  properties2?: string[]
  section10s?: string[]
}
export type ActionDataProp = (
  {
    field?: FieldType | Partial<Record<Game, FieldType>>
    resource?: ResourceType
    textureType?: string
    scale?: ScaleCondition
    time?: TimeOperation
    color?: 1 | 2
    omit?: 1
    paths?: {
      [game: string]: [string, number]
    }
  } & ({
    default: AnyValue
  } | {
    default: boolean
    field: FieldType.Boolean
  } | {
    default: number[]
    s10: 1
  })
)
export type ActionDataEntry = {
  /**
   * Is `true` if the action is an
   * {@link ActionSlots.AppearanceAction appearance action}.
   */
  isAppearance: boolean
  /**
   * Is `true` if the action defines a particle appearance. Particles are
   * affected by particle-related actions:
   * - {@link ActionSlots.ParticleModifierAction ParticleModifierAction}
   * - {@link ActionSlots.ParticleAttributesAction ParticleAttributesAction}
   * - {@link ActionSlots.ParticleMovementAction ParticleMovementAction}
   * - {@link ActionSlots.ParticleForceMovementAction ParticleForceMovementAction}
   * 
   * Particles can be emitted by any of the regular emitters:
   * - {@link ActionType.OneTimeEmitter OneTimeEmitter}
   * - {@link ActionType.PeriodicEmitter PeriodicEmitter}
   * - {@link ActionType.EqualDistanceEmitter EqualDistanceEmitter}
   * 
   * Non-particles are not affected by the particle-related actions, and can
   * only be emitted by {@link ActionType.OneTimeEmitter OneTimeEmitter}.
   * 
   * GPU particles, for example those from
   * {@link ActionType.GPUStandardParticle GPUStandardParticle}, do not count
   * as particles in the same way. They are not affected by the
   * particle-related actions, and the actions that define them also define
   * their own emitter for the GPU particles instead of using the one in the
   * node's emitter slot.
   */
  isParticle: boolean
  /**
   * Is `true` if the action is the default action for its slot.
   */
  slotDefault: boolean
  props?: Record<string, ActionDataProp>
  games?: Record<string, ActionGameDataEntry | Game | -2>
}
export type ActionDataConversionEntry<T> = {
  read?(props: Props<T>, game: Game): Props<T>
  write?(props: Props<T>, game: Game): Props<T>
  minify?(): AnyAction
  fallback?(action: T, game: Game): Action
}
const ActionData: Record<string, ActionDataEntry> = {
  /*#ActionData start*/
  [ActionType.NodeAcceleration]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      speedZ: { default: 0, scale: 1, time: 1 },
      accelerationZ: { default: 0, scale: 1, time: 4 },
      accelerationMultiplierZ: { default: 1 },
      accelerationY: { default: 0, scale: 1, time: 4 },
      unk_ds3_f1_0: { default: 0, field: 1 },
      alignWithMotion: { default: 0, field: 1 },
      unk_ds3_f1_2: { default: 0, field: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','alignWithMotion','unk_ds3_f1_2'],
        properties1: ['speedZ','accelerationZ','accelerationMultiplierZ','accelerationY']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeTranslation]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      translation: { default: [0, 0, 0], scale: 1 },
      alignWithMotion: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        properties1: ['translation']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: {
        fields1: ['alignWithMotion'],
        properties1: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.NodeSpin]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      angularSpeedX: { default: 0, time: 1 },
      angularSpeedMultiplierX: { default: 1 },
      angularSpeedY: { default: 0, time: 1 },
      angularSpeedMultiplierY: { default: 1 },
      angularSpeedZ: { default: 0, time: 1 },
      angularSpeedMultiplierZ: { default: 1 },
      unk_ds3_f1_0: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0'],
        properties1: ['angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.StaticNodeTransform]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      offset: { default: [0, 0, 0], field: 4, scale: 1 },
      rotation: { default: [0, 0, 0], field: 4 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['offset','rotation']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.RandomNodeTransform]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      offset: { default: [0, 0, 0], field: 4, scale: 1 },
      rotation: { default: [0, 0, 0], field: 4 },
      offsetVariance: { default: [0, 0, 0], field: 4, scale: 1 },
      rotationVariance: { default: [0, 0, 0], field: 4 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['offset','rotation','offsetVariance','rotationVariance']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeAttachToCamera]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      followRotation: { default: true, field: 0 },
      unk_ds3_f1_1: { default: 1, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['followRotation','unk_ds3_f1_1']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.ParticleAcceleration]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      gravity: { default: 0, scale: 1, time: 4 },
      acceleration: { default: 0, scale: 1, time: 4 },
      accelerationMultiplier: { default: 1 },
      unk_ds3_f1_0: { default: 0, field: 1 },
      unk_ds3_f1_1: { default: 0, field: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','unk_ds3_f1_1'],
        properties1: ['gravity','acceleration','accelerationMultiplier']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.ParticleSpeed]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      gravity: { default: 0, scale: 1, time: 4 },
      speed: { default: 0, scale: 1, time: 1 },
      speedMultiplier: { default: 1 },
      unk_ds3_f1_0: { default: 0, field: 1 },
      unk_ds3_f1_1: { default: 0, field: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','unk_ds3_f1_1'],
        properties1: ['gravity','speed','speedMultiplier']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.ParticleSpeedRandomTurns]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      gravity: { default: 0, scale: 1, time: 4 },
      speed: { default: 0, scale: 1, time: 1 },
      speedMultiplier: { default: 1 },
      maxTurnAngle: { default: 0 },
      unk_ds3_f1_0: { default: 0, field: 2 },
      turnInterval: { default: 0, field: 1, time: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','turnInterval'],
        properties1: ['gravity','speed','speedMultiplier','maxTurnAngle']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.ParticleSpeedPartialFollow]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      gravity: { default: 0, scale: 1, time: 4 },
      speed: { default: 0, scale: 1, time: 1 },
      speedMultiplier: { default: 1 },
      maxTurnAngle: { default: 0 },
      followFactor: { default: 0 },
      unk_ds3_f1_0: { default: 0, field: 2 },
      turnInterval: { default: 0, field: 1, time: 2 },
      followRotation: { default: true, field: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','turnInterval','followRotation'],
        properties1: ['gravity','speed','speedMultiplier','maxTurnAngle','followFactor']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeSound]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      sound: { default: 0, field: 1, resource: 3 },
      unk_ds3_f1_1: { default: 1, field: 2 },
      unk_ds3_f1_2: { default: false, field: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['sound','unk_ds3_f1_1','unk_ds3_f1_2']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.EmissionSound]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      sound: { default: 0, field: 1, resource: 3 },
      unk_ds3_f1_1: { default: 1, field: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['sound','unk_ds3_f1_1']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeAccelerationRandomTurns]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      speedZ: { default: 0, scale: 1, time: 1 },
      accelerationZ: { default: 0, scale: 1, time: 4 },
      accelerationMultiplierZ: { default: 1 },
      accelerationY: { default: 0, scale: 1, time: 4 },
      maxTurnAngle: { default: 0 },
      alignWithMotion: { default: 0, field: 1 },
      unk_ds3_f1_1: { default: 0, field: 2 },
      turnInterval: { default: 0, field: 1, time: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['alignWithMotion','unk_ds3_f1_1','turnInterval'],
        properties1: ['speedZ','accelerationZ','accelerationMultiplierZ','accelerationY','maxTurnAngle']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.ParticleAccelerationRandomTurns]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      gravity: { default: 0, scale: 1, time: 4 },
      acceleration: { default: 0, scale: 1, time: 4 },
      accelerationMultiplier: { default: 1 },
      maxTurnAngle: { default: 0 },
      unk_ds3_f1_0: { default: 0, field: 2 },
      turnInterval: { default: 0, field: 1, time: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','turnInterval'],
        properties1: ['gravity','acceleration','accelerationMultiplier','maxTurnAngle']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.ParticleAccelerationPartialFollow]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      gravity: { default: 0, scale: 1, time: 4 },
      acceleration: { default: 0, scale: 1, time: 4 },
      accelerationMultiplier: { default: 1 },
      maxTurnAngle: { default: 0 },
      followFactor: { default: 0 },
      unk_ds3_f1_0: { default: 0, field: 2 },
      turnInterval: { default: 0, field: 1, time: 2 },
      followRotation: { default: true, field: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','turnInterval','followRotation'],
        properties1: ['gravity','acceleration','accelerationMultiplier','maxTurnAngle','followFactor']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeAccelerationPartialFollow]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      speedZ: { default: 0, scale: 1, time: 1 },
      accelerationZ: { default: 0, scale: 1, time: 4 },
      accelerationMultiplierZ: { default: 1 },
      accelerationY: { default: 0, scale: 1, time: 4 },
      maxTurnAngle: { default: 0 },
      followFactor: { default: 0 },
      alignWithMotion: { default: 0, field: 1 },
      unk_ds3_f1_1: { default: 0, field: 1 },
      turnInterval: { default: 0, field: 1, time: 2 },
      followRotation: { default: true, field: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['alignWithMotion','unk_ds3_f1_1','turnInterval','followRotation'],
        properties1: ['speedZ','accelerationZ','accelerationMultiplierZ','accelerationY','maxTurnAngle','followFactor']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeAccelerationSpin]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      speedZ: { default: 0, scale: 1, time: 1 },
      accelerationZ: { default: 0, scale: 1, time: 4 },
      accelerationMultiplierZ: { default: 1 },
      accelerationY: { default: 0, scale: 1, time: 4 },
      angularSpeedX: { default: 0, time: 1 },
      angularSpeedMultiplierX: { default: 1 },
      angularSpeedY: { default: 0, time: 1 },
      angularSpeedMultiplierY: { default: 1 },
      angularSpeedZ: { default: 0, time: 1 },
      angularSpeedMultiplierZ: { default: 1 },
      unk_ds3_f1_0: { default: 0, field: 1 },
      unk_ds3_f1_1: { default: 0, field: 1 },
      alignWithMotion: { default: 0, field: 1 },
      unk_ds3_f1_3: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','unk_ds3_f1_1','alignWithMotion','unk_ds3_f1_3'],
        properties1: ['speedZ','accelerationZ','accelerationMultiplierZ','accelerationY','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeSpeed]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      speedZ: { default: 0, scale: 1, time: 1 },
      speedMultiplierZ: { default: 1 },
      accelerationY: { default: 0, scale: 1, time: 4 },
      unk_ds3_f1_0: { default: 0, field: 1 },
      alignWithMotion: { default: 0, field: 1 },
      unk_ds3_f1_2: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','alignWithMotion','unk_ds3_f1_2'],
        properties1: ['speedZ','speedMultiplierZ','accelerationY']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeSpeedRandomTurns]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      speedZ: { default: 0, scale: 1, time: 1 },
      speedMultiplierZ: { default: 1 },
      accelerationY: { default: 0, scale: 1, time: 4 },
      maxTurnAngle: { default: 0 },
      alignWithMotion: { default: 0, field: 1 },
      unk_ds3_f1_1: { default: 0, field: 1 },
      turnInterval: { default: 0, field: 1, time: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['alignWithMotion','unk_ds3_f1_1','turnInterval'],
        properties1: ['speedZ','speedMultiplierZ','accelerationY','maxTurnAngle']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeSpeedPartialFollow]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      speedZ: { default: 0, scale: 1, time: 1 },
      speedMultiplierZ: { default: 1 },
      accelerationY: { default: 0, scale: 1, time: 4 },
      maxTurnAngle: { default: 0 },
      followFactor: { default: 0 },
      alignWithMotion: { default: 0, field: 1 },
      unk_ds3_f1_1: { default: 0, field: 1 },
      turnInterval: { default: 0, field: 1, time: 2 },
      followRotation: { default: true, field: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['alignWithMotion','unk_ds3_f1_1','turnInterval','followRotation'],
        properties1: ['speedZ','speedMultiplierZ','accelerationY','maxTurnAngle','followFactor']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeSpeedSpin]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      speedZ: { default: 0, scale: 1, time: 1 },
      speedMultiplierZ: { default: 1 },
      accelerationY: { default: 0, scale: 1, time: 4 },
      angularSpeedX: { default: 0, time: 1 },
      angularSpeedMultiplierX: { default: 1 },
      angularSpeedY: { default: 0, time: 1 },
      angularSpeedMultiplierY: { default: 1 },
      angularSpeedZ: { default: 0, time: 1 },
      angularSpeedMultiplierZ: { default: 1 },
      unk_ds3_f1_0: { default: 0, field: 1 },
      unk_ds3_f1_1: { default: 0, field: 1 },
      alignWithMotion: { default: 0, field: 1 },
      unk_ds3_f1_3: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','unk_ds3_f1_1','alignWithMotion','unk_ds3_f1_3'],
        properties1: ['speedZ','speedMultiplierZ','accelerationY','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.NodeAttributes]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      duration: { default: -1, time: 3 },
      delay: { default: 0, field: 2, time: 2 },
      unk_ds3_f1_1: { default: 1, field: 1 },
      attachment: { default: AttachMode.Parent, field: 1 },
      depthBias: { default: 0, field: 2, scale: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['delay','unk_ds3_f1_1','attachment','depthBias'],
        properties1: ['duration']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.ParticleAttributes]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      duration: { default: -1, time: 3 },
      attachment: { default: AttachMode.Parent, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['attachment'],
        properties1: ['duration']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.Unk130]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      unk_ds3_p1_0: { default: 0 },
      unk_ds3_p1_1: { default: 0 },
      unk_ds3_p1_2: { default: 0 },
      unk_ds3_p1_3: { default: 0 },
      unk_ds3_p1_4: { default: 0 },
      unk_ds3_p1_5: { default: 0 },
      unk_ds3_p1_6: { default: 0 },
      unk_ds3_p1_7: { default: 0 },
      unk_ds3_f1_0: { default: 1, field: 1 },
      unk_ds3_f1_1: { default: 0, field: 1 },
      unk_ds3_f1_2: { default: 0, field: 1 },
      unk_ds3_f1_3: { default: 0, field: 1 },
      unk_ds3_f1_4: { default: 0, field: 1 },
      unk_ds3_f1_5: { default: 0, field: 1 },
      unk_ds3_f1_6: { default: 0, field: 1 },
      unk_ds3_f1_7: { default: 0, field: 1 },
      unk_ds3_f1_8: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','unk_ds3_f1_1','unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4','unk_ds3_f1_5','unk_ds3_f1_6','unk_ds3_f1_7','unk_ds3_f1_8'],
        properties1: ['unk_ds3_p1_0','unk_ds3_p1_1','unk_ds3_p1_2','unk_ds3_p1_3','unk_ds3_p1_4','unk_ds3_p1_5','unk_ds3_p1_6','unk_ds3_p1_7']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.ParticleModifier]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      speed: { default: 0, scale: 1, time: 1 },
      scaleX: { default: 1, scale: 5 },
      scaleY: { default: 1, scale: 5 },
      scaleZ: { default: 1, scale: 5 },
      color: { default: [1, 1, 1, 1], color: 2 },
      uniformScale: { default: false, field: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['uniformScale'],
        properties1: ['speed','scaleX','scaleY','scaleZ','color']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.SFXReference]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      sfx: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['sfx']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.LevelsOfDetailThresholds]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      duration: { default: -1, time: 3 },
      threshold0: { default: 10000, field: 1, scale: 2 },
      threshold1: { default: 10000, field: 1, scale: 2 },
      threshold2: { default: 10000, field: 1, scale: 2 },
      threshold3: { default: 10000, field: 1, scale: 2 },
      threshold4: { default: 10000, field: 1, scale: 2 },
      unk_ac6_f1_5: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['threshold0','threshold1','threshold2','threshold3','threshold4'],
        properties1: ['duration']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: {
        fields1: ['threshold0','threshold1','threshold2','threshold3','threshold4','unk_ac6_f1_5'],
        properties1: Game.DarkSouls3
      },
      [Game.Nightreign]: Game.ArmoredCore6
    }
  },
  [ActionType.StateConfigMap]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      configIndices: { default: [0], s10: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        section10s: ['configIndices']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.SelectAllNodes]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true
  },
  [ActionType.SelectRandomNode]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      weights: { default: [1], s10: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        section10s: ['weights']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.PeriodicEmitter]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      interval: { default: 1, time: 2 },
      perEmission: { default: 1 },
      totalEmissions: { default: -1 },
      maxConcurrent: { default: -1, field: 1 },
      unk_ds3_f1_1: { default: 1, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['maxConcurrent','unk_ds3_f1_1'],
        properties1: ['interval','perEmission','totalEmissions']
      },
      [Game.Sekiro]: {
        fields1: ['unk_ds3_f1_1'],
        properties1: ['interval','perEmission','totalEmissions','maxConcurrent']
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: Game.Sekiro,
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.EqualDistanceEmitter]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      threshold: { default: 0.1, scale: 1 },
      totalEmissions: { default: -1 },
      maxConcurrent: { default: -1, field: 1 },
      unk_ds3_p1_1: { default: 1 },
      unk_ds3_f1_1: { default: 1, field: 1 },
      unk_sdt_f1_1: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['maxConcurrent','unk_ds3_f1_1'],
        properties1: ['threshold','unk_ds3_p1_1','totalEmissions']
      },
      [Game.Sekiro]: {
        fields1: ['unk_ds3_f1_1','unk_sdt_f1_1'],
        properties1: ['threshold','totalEmissions','maxConcurrent']
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: Game.Sekiro,
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.OneTimeEmitter]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true
  },
  [ActionType.PointEmitterShape]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      direction: { default: InitialDirection.Emitter, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['direction']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.DiskEmitterShape]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      radius: { default: 1, scale: 1 },
      distribution: { default: 0 },
      direction: { default: InitialDirection.Emitter, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['direction'],
        properties1: ['radius','distribution']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.RectangleEmitterShape]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      sizeX: { default: 1, scale: 1 },
      sizeY: { default: 1, scale: 1 },
      distribution: { default: 0 },
      direction: { default: InitialDirection.Emitter, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['direction'],
        properties1: ['sizeX','sizeY','distribution']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.SphereEmitterShape]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      radius: { default: 1, scale: 1 },
      emitInside: { default: true, field: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['emitInside'],
        properties1: ['radius']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.BoxEmitterShape]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      sizeX: { default: 1, scale: 1 },
      sizeY: { default: 1, scale: 1 },
      sizeZ: { default: 1, scale: 1 },
      direction: { default: InitialDirection.Emitter, field: 1 },
      emitInside: { default: true, field: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['direction','emitInside'],
        properties1: ['sizeX','sizeY','sizeZ']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.CylinderEmitterShape]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      radius: { default: 1, scale: 1 },
      height: { default: 1, scale: 1 },
      direction: { default: InitialDirection.Emitter, field: 1 },
      emitInside: { default: true, field: 0 },
      yAxis: { default: true, field: 0 },
    },
    games: {
      [Game.Sekiro]: {
        fields1: ['direction','emitInside','yAxis'],
        properties1: ['radius','height']
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: Game.Sekiro,
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.NoSpread]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true
  },
  [ActionType.CircularSpread]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      angle: { default: 30 },
      distribution: { default: 0 },
      unk_er_f1_0: { default: false, field: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        properties1: ['angle','distribution']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: {
        fields1: ['unk_er_f1_0'],
        properties1: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.EllipticalSpread]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      angleX: { default: 30 },
      angleY: { default: 30 },
      distribution: { default: 0 },
      unk_er_f1_0: { default: false, field: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        properties1: ['angleX','angleY','distribution']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: {
        fields1: ['unk_er_f1_0'],
        properties1: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.RectangularSpread]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      angleX: { default: 30 },
      angleY: { default: 30 },
      distribution: { default: 0 },
    },
    games: {
      [Game.DarkSouls3]: {
        properties1: ['angleX','angleY','distribution']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.PointSprite]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      texture: { default: 1, field: 1, resource: 0, textureType: 'a' },
      blendMode: { default: BlendMode.Normal, field: 1 },
      size: { default: 1, scale: 4 },
      color1: { default: [1, 1, 1, 1], color: 2 },
      color2: { default: [1, 1, 1, 1], color: 2 },
      color3: { default: [1, 1, 1, 1], color: 1 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      unk_ds3_p2_2: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      alphaThreshold: { default: 0 },
      unk_ds3_f1_2: { default: -2, field: 1 },
      unk_ds3_f1_3: { default: -2, field: 1 },
      unk_ds3_f1_4: { default: 0, field: 1 },
      unk_er_f1_3: { default: 1, field: 1 },
      unk_er_f1_4: { default: 1, field: 1 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 0, field: 1 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ds3_f2_9: { default: 0, field: 2 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0, field: 1 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 0, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_ds3_f2_29: { default: 0, field: 2, scale: 2 },
      unk_sdt_f2_30: { default: 0, field: 2 },
      unk_sdt_f2_31: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: false, field: 0 },
      unk_sdt_f2_33: { default: 0, field: 1 },
      unk_sdt_f2_34: { default: 0, field: 2 },
      unk_sdt_f2_35: { default: -1, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      unk_sdt_f2_38: { default: 0, field: 1 },
      unk_er_f2_39: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['texture','blendMode','unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29'],
        properties1: ['size','color1','color2','color3'],
        properties2: ['rgbMultiplier','alphaMultiplier','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','alphaThreshold']
      },
      [Game.Sekiro]: {
        fields1: ['unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','unk_sdt_f2_30','unk_sdt_f2_31','unk_sdt_f2_32','unk_sdt_f2_33','unk_sdt_f2_34','unk_sdt_f2_35','unk_sdt_f2_36','unk_sdt_f2_37','unk_sdt_f2_38'],
        properties1: ['texture','blendMode','size','color1','color2','color3'],
        properties2: Game.DarkSouls3
      },
      [Game.EldenRing]: {
        fields1: ['unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4','unk_er_f1_3','unk_er_f1_4'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','unk_sdt_f2_30','unk_sdt_f2_31','unk_sdt_f2_32','unk_sdt_f2_33','unk_sdt_f2_34','unk_sdt_f2_35','unk_sdt_f2_36','unk_sdt_f2_37','unk_sdt_f2_38','unk_er_f2_39'],
        properties1: Game.Sekiro,
        properties2: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.Line]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      blendMode: { default: BlendMode.Normal, field: 1 },
      length: { default: 1, scale: 4 },
      color1: { default: [1, 1, 1, 1], color: 1 },
      color2: { default: [1, 1, 1, 1], color: 2 },
      startColor: { default: [1, 1, 1, 1], color: 2 },
      endColor: { default: [1, 1, 1, 1], color: 2 },
      lengthMultiplier: { default: 1 },
      color3: { default: [1, 1, 1, 1], color: 2 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      unk_ds3_p2_2: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      alphaThreshold: { default: 0 },
      unk_ds3_f1_1: { default: -1, field: 1 },
      unk_er_f1_1: { default: 1, field: 1 },
      unk_er_f1_2: { default: 1, field: 1 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 0, field: 1 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ds3_f2_9: { default: 0, field: 2 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0, field: 1 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 0, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_ds3_f2_29: { default: 0, field: 2, scale: 2 },
      unk_sdt_f2_30: { default: 0, field: 1 },
      unkHideIndoors: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: false, field: 0 },
      unk_sdt_f2_33: { default: 0, field: 1 },
      unk_sdt_f2_34: { default: 0, field: 2 },
      unk_sdt_f2_35: { default: -2, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      unk_sdt_f2_38: { default: 0, field: 1 },
      unk_sdt_f2_39: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['blendMode','unk_ds3_f1_1'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29'],
        properties1: ['length','color1','color2','startColor','endColor','lengthMultiplier','color3'],
        properties2: ['rgbMultiplier','alphaMultiplier','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','alphaThreshold']
      },
      [Game.Sekiro]: {
        fields1: ['unk_ds3_f1_1'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','unk_sdt_f2_30','unkHideIndoors','unk_sdt_f2_32','unk_sdt_f2_33','unk_sdt_f2_34','unk_sdt_f2_35','unk_sdt_f2_36','unk_sdt_f2_37','unk_sdt_f2_38','unk_sdt_f2_39'],
        properties1: ['blendMode','length','color1','color2','startColor','endColor','lengthMultiplier','color3'],
        properties2: Game.DarkSouls3
      },
      [Game.EldenRing]: {
        fields1: ['unk_ds3_f1_1','unk_er_f1_1','unk_er_f1_2'],
        fields2: Game.Sekiro,
        properties1: Game.Sekiro,
        properties2: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.QuadLine]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      blendMode: { default: BlendMode.Normal, field: 1 },
      width: { default: 1, scale: 4 },
      length: { default: 1, scale: 4 },
      color1: { default: [1, 1, 1, 1], color: 1 },
      color2: { default: [1, 1, 1, 1], color: 2 },
      startColor: { default: [1, 1, 1, 1], color: 2 },
      endColor: { default: [1, 1, 1, 1], color: 2 },
      widthMultiplier: { default: 1 },
      lengthMultiplier: { default: 1 },
      color3: { default: [1, 1, 1, 1], color: 2 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      unk_ds3_p2_2: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      alphaThreshold: { default: 0 },
      unk_ds3_f1_1: { default: -1, field: 1 },
      unk_er_f1_1: { default: 1, field: 1 },
      unk_er_f1_2: { default: 1, field: 1 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 0, field: 1 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ds3_f2_9: { default: 0, field: 2 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0, field: 1 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 0, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_ds3_f2_29: { default: 0, field: 2, scale: 2 },
      unk_sdt_f2_30: { default: 0, field: 2 },
      unk_sdt_f2_31: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: false, field: 0 },
      unk_sdt_f2_33: { default: 0, field: 1 },
      unk_sdt_f2_34: { default: 0, field: 2 },
      unk_sdt_f2_35: { default: -2, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      unk_sdt_f2_38: { default: 0, field: 1 },
      unk_sdt_f2_39: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['blendMode','unk_ds3_f1_1'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29'],
        properties1: ['width','length','color1','color2','startColor','endColor','widthMultiplier','lengthMultiplier','color3'],
        properties2: ['rgbMultiplier','alphaMultiplier','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','alphaThreshold']
      },
      [Game.Sekiro]: {
        fields1: ['unk_ds3_f1_1'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','unk_sdt_f2_30','unk_sdt_f2_31','unk_sdt_f2_32','unk_sdt_f2_33','unk_sdt_f2_34','unk_sdt_f2_35','unk_sdt_f2_36','unk_sdt_f2_37','unk_sdt_f2_38','unk_sdt_f2_39'],
        properties1: ['blendMode','width','length','color1','color2','startColor','endColor','widthMultiplier','lengthMultiplier','color3'],
        properties2: Game.DarkSouls3
      },
      [Game.EldenRing]: {
        fields1: ['unk_ds3_f1_1','unk_er_f1_1','unk_er_f1_2'],
        fields2: Game.Sekiro,
        properties1: Game.Sekiro,
        properties2: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.BillboardEx]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      texture: { default: 1, field: 1, resource: 0, textureType: 'a' },
      blendMode: { default: BlendMode.Normal, field: 1 },
      offsetX: { default: 0 },
      offsetY: { default: 0 },
      offsetZ: { default: 0 },
      width: { default: 1, scale: 4 },
      height: { default: 1, scale: 4 },
      color1: { default: [1, 1, 1, 1], color: 2 },
      color2: { default: [1, 1, 1, 1], color: 2 },
      color3: { default: [1, 1, 1, 1], color: 1 },
      alphaFadeThreshold: { default: 0 },
      rotationX: { default: 0 },
      rotationY: { default: 0 },
      rotationZ: { default: 0 },
      angularSpeedX: { default: 0, time: 1 },
      angularSpeedMultiplierX: { default: 1 },
      angularSpeedY: { default: 0, time: 1 },
      angularSpeedMultiplierY: { default: 1 },
      angularSpeedZ: { default: 0, time: 1 },
      angularSpeedMultiplierZ: { default: 1 },
      depthOffset: { default: 0, scale: 1 },
      frameIndex: { default: 0 },
      frameIndexOffset: { default: 0 },
      unk_ds3_p1_21: { default: 0 },
      unk_ds3_p1_22: { default: 0 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      unk_ds3_p2_2: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      alphaThreshold: { default: 0 },
      orientation: { default: OrientationMode.CameraPlane, field: 1 },
      normalMap: { default: 0, field: 1, resource: 0, textureType: 'n' },
      scaleVariationX: { default: 1, field: 2 },
      scaleVariationY: { default: 1, field: 2 },
      uniformScale: { default: false, field: 0 },
      scaleBeforeRotation: { default: true, field: 0 },
      columns: { default: 1, field: 1 },
      totalFrames: { default: 1, field: 1 },
      interpolateFrames: { default: true, field: 0 },
      unk_ds3_f1_11: { default: 0, field: 1 },
      unk_ds3_f1_12: { default: 0, field: 1 },
      unk_ds3_f1_13: { default: -1, field: 2 },
      depthBlend: { default: true, field: 0 },
      octagonal: { default: false, field: 0 },
      unk_ds3_f1_16: { default: 0, field: 1 },
      unk_sdt_f1_15: { default: 1, field: 1 },
      unk_sdt_f1_16: { default: 1, field: 1 },
      unk_sdt_f1_17: { default: 0, field: 1 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 0, field: 2 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ds3_f2_9: { default: 0, field: 2 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0, field: 1 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 1, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_ds3_f2_29: { default: 0, field: 2, scale: 2 },
      shadowDarkness: { default: 0, field: 2 },
      unkHideIndoors: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: false, field: 0 },
      specular: { default: 0, field: 1, resource: 0, textureType: '3m' },
      glossiness: { default: 0.25, field: 2 },
      lighting: { default: -1, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      specularity: { default: 0.5, field: 2 },
      unk_sdt_f2_39: { default: 1, field: 1 },
      unk_sdt_f2_40: { default: 0, field: 1 },
      unk_sdt_f2_41: { default: 0, field: 1 },
      unk_sdt_f2_42: { default: 0, field: 1 },
      unk_sdt_f2_43: { default: 0, field: 1 },
      unk_sdt_f2_44: { default: 0, field: 1 },
      unk_ac6_f2_45: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['orientation','texture','normalMap','blendMode','scaleVariationX','scaleVariationY','uniformScale','scaleBeforeRotation','columns','totalFrames','interpolateFrames','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','depthBlend','octagonal','unk_ds3_f1_16'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29'],
        properties1: ['offsetX','offsetY','offsetZ','width','height','color1','color2','color3','alphaFadeThreshold','rotationX','rotationY','rotationZ','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ','depthOffset','frameIndex','frameIndexOffset','unk_ds3_p1_21','unk_ds3_p1_22'],
        properties2: ['rgbMultiplier','alphaMultiplier','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','alphaThreshold']
      },
      [Game.Sekiro]: {
        fields1: ['orientation','normalMap','scaleVariationX','scaleVariationY','uniformScale','scaleBeforeRotation','columns','totalFrames','interpolateFrames','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','depthBlend','octagonal','unk_ds3_f1_16','unk_sdt_f1_15','unk_sdt_f1_16','unk_sdt_f1_17'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','shadowDarkness','unkHideIndoors','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','specularity','unk_sdt_f2_39','unk_sdt_f2_40','unk_sdt_f2_41','unk_sdt_f2_42','unk_sdt_f2_43','unk_sdt_f2_44'],
        properties1: ['texture','blendMode','offsetX','offsetY','offsetZ','width','height','color1','color2','color3','alphaFadeThreshold','rotationX','rotationY','rotationZ','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ','depthOffset','frameIndex','frameIndexOffset','unk_ds3_p1_21','unk_ds3_p1_22'],
        properties2: Game.DarkSouls3
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: {
        fields1: Game.Sekiro,
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','shadowDarkness','unkHideIndoors','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','specularity','unk_sdt_f2_39','unk_sdt_f2_40','unk_sdt_f2_41','unk_sdt_f2_42','unk_sdt_f2_43','unk_sdt_f2_44','unk_ac6_f2_45'],
        properties1: Game.Sekiro,
        properties2: Game.DarkSouls3
      },
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.MultiTextureBillboardEx]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      blendMode: { default: BlendMode.Normal, field: 1 },
      offsetX: { default: 0 },
      offsetY: { default: 0 },
      offsetZ: { default: 0 },
      width: { default: 1, scale: 4 },
      height: { default: 1, scale: 4 },
      rotationX: { default: 0 },
      rotationY: { default: 0 },
      rotationZ: { default: 0 },
      angularSpeedX: { default: 0, time: 1 },
      angularSpeedMultiplierX: { default: 1 },
      angularSpeedY: { default: 0, time: 1 },
      angularSpeedMultiplierY: { default: 1 },
      angularSpeedZ: { default: 0, time: 1 },
      angularSpeedMultiplierZ: { default: 1 },
      color1: { default: [1, 1, 1, 1], color: 2 },
      color2: { default: [1, 1, 1, 1], color: 2 },
      color3: { default: [1, 1, 1, 1], color: 1 },
      layer1Color: { default: [1, 1, 1, 1], color: 2 },
      layer2Color: { default: [1, 1, 1, 1], color: 2 },
      layer3Color: { default: [1, 1, 1, 1], color: 2 },
      alphaFadeThreshold: { default: 0 },
      frameIndex: { default: 0 },
      frameIndexOffset: { default: 0 },
      layer1SpeedU: { default: 0 },
      layer1SpeedV: { default: 0 },
      layer1OffsetU: { default: 0 },
      layer1OffsetV: { default: 0 },
      layer1ScaleU: { default: 1 },
      layer1ScaleV: { default: 1 },
      layer2SpeedU: { default: 0 },
      layer2SpeedV: { default: 0 },
      layer2OffsetU: { default: 0 },
      layer2OffsetV: { default: 0 },
      layer2ScaleU: { default: 1 },
      layer2ScaleV: { default: 1 },
      layer3SpeedU: { default: 0 },
      layer3SpeedV: { default: 0 },
      layer3OffsetU: { default: 0 },
      layer3OffsetV: { default: 0 },
      layer3ScaleU: { default: 1 },
      layer3ScaleV: { default: 1 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      unk_ds3_p2_2: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      alphaThreshold: { default: 0 },
      orientation: { default: OrientationMode.CameraPlane, field: 1 },
      layer1: { default: 1, field: 1, resource: 0, textureType: 'a' },
      layer2: { default: 1, field: 1, resource: 0, textureType: 'a' },
      layer3: { default: 1, field: 1, resource: 0, textureType: 'a' },
      uniformScale: { default: false, field: 0 },
      scaleBeforeRotation: { default: true, field: 0 },
      columns: { default: 1, field: 1 },
      totalFrames: { default: 1, field: 1 },
      interpolateFrames: { default: true, field: 0 },
      unk_ds3_f1_10: { default: -2, field: 1 },
      unk_ds3_f1_11: { default: -2, field: 1 },
      depthBlend: { default: true, field: 0 },
      octagonal: { default: false, field: 0 },
      unk_ds3_f1_14: { default: 0, field: 1 },
      unk_er_f1_14: { default: 1, field: 1 },
      unk_er_f1_15: { default: 1, field: 1 },
      unk_er_f1_16: { default: 0, field: 1 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 0, field: 2 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ds3_f2_9: { default: 0, field: 2 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0, field: 1 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 1, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_ds3_f2_29: { default: 0, field: 2, scale: 2 },
      shadowDarkness: { default: 0, field: 2 },
      unk_sdt_f2_31: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: false, field: 0 },
      specular: { default: 0, field: 1, resource: 0, textureType: '3m' },
      glossiness: { default: 0.25, field: 2 },
      lighting: { default: -1, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      unk_sdt_f2_38: { default: 1, field: 1 },
      unk_sdt_f2_39: { default: 1, field: 1 },
      unk_sdt_f2_40: { default: 0, field: 1 },
      unk_sdt_f2_41: { default: 0, field: 1 },
      unk_er_f2_42: { default: 0, field: 1 },
      unk_er_f2_43: { default: 0, field: 1 },
      unk_er_f2_44: { default: 0, field: 2 },
      unk_er_f2_45: { default: 0, field: 1 },
      unk_ac6_f2_46: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['orientation','layer1','layer2','layer3','blendMode','uniformScale','scaleBeforeRotation','columns','totalFrames','interpolateFrames','unk_ds3_f1_10','unk_ds3_f1_11','depthBlend','octagonal','unk_ds3_f1_14'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29'],
        properties1: ['offsetX','offsetY','offsetZ','width','height','rotationX','rotationY','rotationZ','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ','color1','color2','color3','layer1Color','layer2Color','layer3Color','alphaFadeThreshold','frameIndex','frameIndexOffset','layer1SpeedU','layer1SpeedV','layer1OffsetU','layer1OffsetV','layer1ScaleU','layer1ScaleV','layer2SpeedU','layer2SpeedV','layer2OffsetU','layer2OffsetV','layer2ScaleU','layer2ScaleV','layer3SpeedU','layer3SpeedV','layer3OffsetU','layer3OffsetV','layer3ScaleU','layer3ScaleV'],
        properties2: ['rgbMultiplier','alphaMultiplier','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','alphaThreshold']
      },
      [Game.Sekiro]: {
        fields1: ['orientation','layer1','layer2','layer3','uniformScale','scaleBeforeRotation','columns','totalFrames','interpolateFrames','unk_ds3_f1_10','unk_ds3_f1_11','depthBlend','octagonal','unk_ds3_f1_14'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','shadowDarkness','unk_sdt_f2_31','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','unk_sdt_f2_38','unk_sdt_f2_39','unk_sdt_f2_40','unk_sdt_f2_41'],
        properties1: ['blendMode','offsetX','offsetY','offsetZ','width','height','rotationX','rotationY','rotationZ','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ','color1','color2','color3','layer1Color','layer2Color','layer3Color','alphaFadeThreshold','frameIndex','frameIndexOffset','layer1SpeedU','layer1SpeedV','layer1OffsetU','layer1OffsetV','layer1ScaleU','layer1ScaleV','layer2SpeedU','layer2SpeedV','layer2OffsetU','layer2OffsetV','layer2ScaleU','layer2ScaleV','layer3SpeedU','layer3SpeedV','layer3OffsetU','layer3OffsetV','layer3ScaleU','layer3ScaleV'],
        properties2: Game.DarkSouls3
      },
      [Game.EldenRing]: {
        fields1: ['orientation','layer1','layer2','layer3','uniformScale','scaleBeforeRotation','columns','totalFrames','interpolateFrames','unk_ds3_f1_10','unk_ds3_f1_11','depthBlend','octagonal','unk_ds3_f1_14','unk_er_f1_14','unk_er_f1_15','unk_er_f1_16'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','shadowDarkness','unk_sdt_f2_31','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','unk_sdt_f2_38','unk_sdt_f2_39','unk_sdt_f2_40','unk_sdt_f2_41','unk_er_f2_42','unk_er_f2_43','unk_er_f2_44','unk_er_f2_45'],
        properties1: Game.Sekiro,
        properties2: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: {
        fields1: Game.EldenRing,
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','shadowDarkness','unk_sdt_f2_31','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','unk_sdt_f2_38','unk_sdt_f2_39','unk_sdt_f2_40','unk_sdt_f2_41','unk_er_f2_42','unk_er_f2_43','unk_er_f2_44','unk_er_f2_45','unk_ac6_f2_46'],
        properties1: Game.Sekiro,
        properties2: Game.DarkSouls3
      },
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.Model]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      model: { default: 80201, field: 1, resource: 1 },
      sizeX: { default: 1, scale: 4 },
      sizeY: { default: 1, scale: 4 },
      sizeZ: { default: 1, scale: 4 },
      rotationX: { default: 0 },
      rotationY: { default: 0 },
      rotationZ: { default: 0 },
      angularSpeedX: { default: 0, time: 1 },
      angularSpeedMultiplierX: { default: 1 },
      angularSpeedY: { default: 0, time: 1 },
      angularSpeedMultiplierY: { default: 1 },
      angularSpeedZ: { default: 0, time: 1 },
      angularSpeedMultiplierZ: { default: 1 },
      blendMode: { default: BlendMode.Normal, field: 1 },
      color1: { default: [1, 1, 1, 1], color: 2 },
      color2: { default: [1, 1, 1, 1], color: 2 },
      color3: { default: [1, 1, 1, 1], color: 1 },
      unk_ds3_p1_15: { default: 0 },
      frameIndex: { default: 0 },
      frameIndexOffset: { default: 0 },
      offsetU: { default: 0 },
      offsetV: { default: 0 },
      speedU: { default: 0, time: 1 },
      speedMultiplierU: { default: 0 },
      speedV: { default: 0, time: 1 },
      speedMultiplierV: { default: 0 },
      unk_ds3_p1_24: { default: 0 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      unk_ds3_p2_2: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      unk_ds3_p2_6: { default: 0 },
      unk_ds3_p2_7: { default: 0 },
      orientation: { default: ModelOrientationMode.ParticleDirection, field: 1 },
      scaleVariationX: { default: 1, field: 2 },
      scaleVariationY: { default: 1, field: 2 },
      scaleVariationZ: { default: 1, field: 2 },
      uniformScale: { default: false, field: 0 },
      columns: { default: 1, field: 1 },
      totalFrames: { default: 1, field: 1 },
      unk_ds3_f1_9: { default: -2, field: 1 },
      unk_ds3_f1_10: { default: -2, field: 1 },
      unk_ds3_f1_11: { default: true, field: 0 },
      unk_ds3_f1_12: { default: true, field: 0 },
      unk_ds3_f1_13: { default: 1, field: 1 },
      anibnd: { default: 0, field: 1, resource: 2 },
      animation: { default: 0, field: 1 },
      loopAnimation: { default: true, field: 0 },
      animationSpeed: { default: 1, field: 2, time: 1 },
      unk_ds3_f1_18: { default: 0, field: 1 },
      unk_er_f1_17: { default: 1, field: 1 },
      unk_er_f1_18: { default: 1, field: 1 },
      unk_er_f1_19: { default: 0, field: 1 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 0, field: 1 },
      unk_ds3_f2_4: { default: 1, field: 1 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ds3_f2_9: { default: 0, field: 2 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0, field: 2 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 2 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_26: { default: 1, field: 1 },
      unk_ds3_f2_27: { default: 0, field: 1 },
      unk_sdt_f2_29: { default: 0, field: 2 },
      unk_sdt_f2_30: { default: 0, field: 2 },
      unk_sdt_f2_31: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: false, field: 0 },
      unk_sdt_f2_33: { default: 0, field: 1 },
      unk_sdt_f2_34: { default: 0, field: 2 },
      unk_sdt_f2_35: { default: -2, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      unk_ac6_f2_38: { default: 0, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['orientation','model','scaleVariationX','scaleVariationY','scaleVariationZ','uniformScale','blendMode','columns','totalFrames','unk_ds3_f1_9','unk_ds3_f1_10','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','anibnd','animation','loopAnimation','animationSpeed','unk_ds3_f1_18'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_26','unk_ds3_f2_27','unk_ds3_f2_28'],
        properties1: ['sizeX','sizeY','sizeZ','rotationX','rotationY','rotationZ','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ','color1','color2','color3','unk_ds3_p1_15','frameIndex','frameIndexOffset','offsetU','offsetV','speedU','speedMultiplierU','speedV','speedMultiplierV','unk_ds3_p1_24'],
        properties2: ['rgbMultiplier','alphaMultiplier','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','unk_ds3_p2_6','unk_ds3_p2_7']
      },
      [Game.Sekiro]: {
        fields1: ['orientation','scaleVariationX','scaleVariationY','scaleVariationZ','uniformScale','columns','totalFrames','unk_ds3_f1_9','unk_ds3_f1_10','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','anibnd','animation','loopAnimation','animationSpeed','unk_ds3_f1_18'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_26','unk_ds3_f2_27','unk_sdt_f2_29','unk_sdt_f2_30','unk_sdt_f2_31','unk_sdt_f2_32','unk_sdt_f2_33','unk_sdt_f2_34','unk_sdt_f2_35','unk_sdt_f2_36','unk_sdt_f2_37'],
        properties1: ['model','sizeX','sizeY','sizeZ','rotationX','rotationY','rotationZ','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ','blendMode','color1','color2','color3','unk_ds3_p1_15','frameIndex','frameIndexOffset','offsetU','offsetV','speedU','speedMultiplierU','speedV','speedMultiplierV','unk_ds3_p1_24'],
        properties2: ['rgbMultiplier','alphaMultiplier','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','unk_ds3_p2_6']
      },
      [Game.EldenRing]: {
        fields1: ['orientation','scaleVariationX','scaleVariationY','scaleVariationZ','uniformScale','columns','totalFrames','unk_ds3_f1_9','unk_ds3_f1_10','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','anibnd','animation','loopAnimation','animationSpeed','unk_ds3_f1_18','unk_er_f1_17','unk_er_f1_18','unk_er_f1_19'],
        fields2: Game.Sekiro,
        properties1: Game.Sekiro,
        properties2: Game.Sekiro
      },
      [Game.ArmoredCore6]: {
        fields1: Game.EldenRing,
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_26','unk_ds3_f2_27','unk_sdt_f2_29','unk_sdt_f2_30','unk_sdt_f2_31','unk_sdt_f2_32','unk_sdt_f2_33','unk_sdt_f2_34','unk_sdt_f2_35','unk_sdt_f2_36','unk_sdt_f2_37','unk_ac6_f2_38'],
        properties1: Game.Sekiro,
        properties2: Game.Sekiro
      },
      [Game.Nightreign]: Game.ArmoredCore6
    }
  },
  [ActionType.LegacyTracer]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      texture: { default: 1, field: 1, resource: 0, textureType: 'a' },
      blendMode: { default: BlendMode.Normal, field: 1 },
      width: { default: 1, scale: 4 },
      widthMultiplier: { default: 1 },
      startFadeEndpoint: { default: 0 },
      endFadeEndpoint: { default: 0 },
      color1: { default: [1, 1, 1, 1], color: 2 },
      color2: { default: [1, 1, 1, 1], color: 2 },
      color3: { default: [1, 1, 1, 1], color: 1 },
      alphaFadeThreshold: { default: 0 },
      frameIndex: { default: 0 },
      frameIndexOffset: { default: 0 },
      textureFraction: { default: 0.1 },
      speedU: { default: 0, time: 1 },
      varianceV: { default: 0 },
      unk_ds3_p1_13: { default: -1 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      distortionIntensity: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      alphaThreshold: { default: 0 },
      orientation: { default: TracerOrientationMode.LocalZ, field: 1 },
      normalMap: { default: 0, field: 1, resource: 0, textureType: 'n' },
      segmentInterval: { default: 0, field: 2, time: 2 },
      segmentDuration: { default: 1, field: 2, scale: 4, time: 5 },
      concurrentSegments: { default: 100, field: 1 },
      segmentSubdivision: { default: 0, field: 1 },
      unk_ds3_f1_8: { default: 0, field: 2 },
      fadeOutTime: { default: 0, field: 2 },
      columns: { default: 1, field: 1 },
      totalFrames: { default: 1, field: 1 },
      attachedUV: { default: true, field: 0 },
      unk_ds3_f1_13: { default: -1, field: 1 },
      unk_ds3_f1_14: { default: -1, field: 1 },
      unk_ds3_f1_15: { default: 0, field: 1 },
      unk_er_f1_14: { default: 1, field: 1 },
      unk_er_f1_15: { default: 1, field: 1 },
      unk_er_f1_16: { default: 0, field: 1 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 0, field: 1 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ds3_f2_9: { default: 0, field: 2 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0, field: 1 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 1, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_ds3_f2_29: { default: 0, field: 2, scale: 2 },
      shadowDarkness: { default: 0, field: 2 },
      unk_sdt_f2_31: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: false, field: 0 },
      specular: { default: 0, field: 1, resource: 0, textureType: '3m' },
      glossiness: { default: 0.25, field: 2 },
      lighting: { default: -1, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      specularity: { default: 0.5, field: 2 },
      unk_er_f2_39: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['orientation','texture','normalMap','blendMode','segmentInterval','segmentDuration','concurrentSegments','segmentSubdivision','unk_ds3_f1_8','fadeOutTime','columns','totalFrames','attachedUV','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29'],
        properties1: ['width','widthMultiplier','startFadeEndpoint','endFadeEndpoint','color1','color2','color3','alphaFadeThreshold','frameIndex','frameIndexOffset','textureFraction','speedU','varianceV','unk_ds3_p1_13'],
        properties2: ['rgbMultiplier','alphaMultiplier','distortionIntensity','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','alphaThreshold']
      },
      [Game.Sekiro]: {
        fields1: ['orientation','normalMap','segmentInterval','segmentDuration','concurrentSegments','segmentSubdivision','unk_ds3_f1_8','fadeOutTime','columns','totalFrames','attachedUV','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','shadowDarkness','unk_sdt_f2_31','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','specularity'],
        properties1: ['texture','blendMode','width','widthMultiplier','startFadeEndpoint','endFadeEndpoint','color1','color2','color3','alphaFadeThreshold','frameIndex','frameIndexOffset','textureFraction','speedU','varianceV','unk_ds3_p1_13'],
        properties2: Game.DarkSouls3
      },
      [Game.EldenRing]: {
        fields1: ['orientation','normalMap','segmentInterval','segmentDuration','concurrentSegments','segmentSubdivision','unk_ds3_f1_8','fadeOutTime','columns','totalFrames','attachedUV','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15','unk_er_f1_14','unk_er_f1_15','unk_er_f1_16'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','shadowDarkness','unk_sdt_f2_31','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','specularity','unk_er_f2_39'],
        properties1: Game.Sekiro,
        properties2: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.Distortion]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      blendMode: { default: BlendMode.Normal, field: 1 },
      offsetX: { default: 0 },
      offsetY: { default: 0 },
      offsetZ: { default: 0 },
      sizeX: { default: 1, scale: 4 },
      sizeY: { default: 1, scale: 4 },
      sizeZ: { default: 1, scale: 4 },
      color: { default: [1, 1, 1, 1], color: 2 },
      unk_ds3_p1_7: { default: [1, 1, 1, 1] },
      intensity: { default: 1 },
      unk_ds3_p1_9: { default: 0 },
      stirSpeed: { default: 60, time: 1 },
      radius: { default: 1 },
      normalMapOffsetU: { default: 0 },
      normalMapOffsetV: { default: 0 },
      normalMapSpeedU: { default: 0, time: 1 },
      normalMapSpeedV: { default: 0, time: 1 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      unk_ds3_p2_2: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      alphaThreshold: { default: 0 },
      unk_er_p2_7: { default: 1 },
      unk_er_p2_8: { default: 1 },
      mode: { default: DistortionMode.NormalMap, field: 1 },
      shape: { default: DistortionShape.Rectangle, field: 1 },
      orientation: { default: OrientationMode.CameraPlane, field: 1 },
      texture: { default: 0, field: 1, resource: 0, textureType: 'a' },
      normalMap: { default: 0, field: 1, resource: 0, textureType: 'n' },
      mask: { default: 0, field: 1, resource: 0, textureType: 'a' },
      scaleVariationX: { default: 1, field: 2 },
      scaleVariationY: { default: 1, field: 2 },
      scaleVariationZ: { default: 1, field: 2 },
      uniformScale: { default: false, field: 0 },
      unk_ds3_f1_11: { default: -2, field: 1 },
      unk_ds3_f1_12: { default: 0, field: 1 },
      unk_er_f1_12: { default: 1, field: 1 },
      unk_er_f1_13: { default: 1, field: 1 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 1, field: 2 },
      unk_ds3_f2_4: { default: 0, field: 1 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ds3_f2_9: { default: 0, field: 1 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 1, field: 2 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 1, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_ds3_f2_29: { default: 0, field: 1 },
      unk_sdt_f2_30: { default: 0, field: 2 },
      unk_sdt_f2_31: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: 0, field: 1 },
      unk_sdt_f2_33: { default: 0, field: 1 },
      unk_sdt_f2_34: { default: 0, field: 2 },
      unk_sdt_f2_35: { default: -1, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      unk_sdt_f2_38: { default: 0, field: 2, scale: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['mode','shape','orientation','texture','normalMap','mask','blendMode','scaleVariationX','scaleVariationY','scaleVariationZ','uniformScale','unk_ds3_f1_11','unk_ds3_f1_12'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29'],
        properties1: ['offsetX','offsetY','offsetZ','sizeX','sizeY','sizeZ','color','unk_ds3_p1_7','intensity','unk_ds3_p1_9','stirSpeed','radius','normalMapOffsetU','normalMapOffsetV','normalMapSpeedU','normalMapSpeedV'],
        properties2: ['rgbMultiplier','alphaMultiplier','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','alphaThreshold']
      },
      [Game.Sekiro]: {
        fields1: ['mode','shape','orientation','texture','normalMap','mask','scaleVariationX','scaleVariationY','scaleVariationZ','uniformScale','unk_ds3_f1_11','unk_ds3_f1_12'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','unk_sdt_f2_30','unk_sdt_f2_31','unk_sdt_f2_32','unk_sdt_f2_33','unk_sdt_f2_34','unk_sdt_f2_35','unk_sdt_f2_36','unk_sdt_f2_37','unk_sdt_f2_38'],
        properties1: ['blendMode','offsetX','offsetY','offsetZ','sizeX','sizeY','sizeZ','color','unk_ds3_p1_7','intensity','unk_ds3_p1_9','stirSpeed','radius','normalMapOffsetU','normalMapOffsetV','normalMapSpeedU','normalMapSpeedV'],
        properties2: Game.DarkSouls3
      },
      [Game.EldenRing]: {
        fields1: ['mode','shape','orientation','texture','normalMap','mask','scaleVariationX','scaleVariationY','scaleVariationZ','uniformScale','unk_ds3_f1_11','unk_ds3_f1_12','unk_er_f1_12','unk_er_f1_13'],
        fields2: Game.Sekiro,
        properties1: Game.Sekiro,
        properties2: ['rgbMultiplier','alphaMultiplier','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','alphaThreshold','unk_er_p2_7','unk_er_p2_8']
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.RadialBlur]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      blendMode: { default: BlendMode.Normal, field: 1 },
      mask: { default: 1, field: 1, resource: 0, textureType: 'a' },
      offsetX: { default: 0 },
      offsetY: { default: 0 },
      offsetZ: { default: 0 },
      width: { default: 1, scale: 4 },
      height: { default: 1, scale: 4 },
      color: { default: [1, 1, 1, 1], color: 2 },
      unk_ds3_p1_6: { default: [1, 1, 1, 1] },
      blurRadius: { default: 0.5 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      unk_ds3_p2_2: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      alphaThreshold: { default: 0 },
      uniformScale: { default: false, field: 0 },
      iterations: { default: 1, field: 1 },
      unk_ds3_f1_4: { default: 0, field: 1 },
      unk_er_f1_3: { default: 1, field: 1 },
      unk_er_f1_4: { default: 1, field: 1 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 1, field: 2 },
      unk_ds3_f2_4: { default: 0, field: 1 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ds3_f2_9: { default: 0, field: 1 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0.5, field: 2 },
      unk_ds3_f2_21: { default: 1, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 2 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 1, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_ds3_f2_29: { default: 0, field: 2 },
      unk_sdt_f2_30: { default: 0, field: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['blendMode','mask','uniformScale','iterations','unk_ds3_f1_4'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29'],
        properties1: ['offsetX','offsetY','offsetZ','width','height','color','unk_ds3_p1_6','blurRadius'],
        properties2: ['rgbMultiplier','alphaMultiplier','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','alphaThreshold']
      },
      [Game.Sekiro]: {
        fields1: ['uniformScale','iterations','unk_ds3_f1_4'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','unk_sdt_f2_30'],
        properties1: ['blendMode','mask','offsetX','offsetY','offsetZ','width','height','color','unk_ds3_p1_6','blurRadius'],
        properties2: Game.DarkSouls3
      },
      [Game.EldenRing]: {
        fields1: ['uniformScale','iterations','unk_ds3_f1_4','unk_er_f1_3','unk_er_f1_4'],
        fields2: Game.Sekiro,
        properties1: Game.Sekiro,
        properties2: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.PointLight]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      diffuseColor: { default: [1, 1, 1, 1], color: 1 },
      specularColor: { default: [1, 1, 1, 1], color: 1 },
      radius: { default: 10, scale: 4 },
      unk_ds3_p1_3: { default: 0 },
      unk_ds3_p1_4: { default: 0 },
      unk_ds3_p1_5: { default: 0 },
      unk_ds3_p1_6: { default: 0 },
      unk_ds3_p1_7: { default: 10 },
      unk_ds3_p1_8: { default: 10 },
      unk_ds3_p1_9: { default: 10 },
      unk_ds3_p2_0: { default: 1 },
      unk_ds3_p2_1: { default: 1 },
      unk_sdt_p2_2: { default: 1 },
      diffuseMultiplier: { default: 1 },
      specularMultiplier: { default: 1 },
      unk_ds3_f1_0: { default: 0, field: 1 },
      unk_ds3_f1_1: { default: 0, field: 2 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      jitterAndFlicker: { default: false, field: 0 },
      jitterAcceleration: { default: 1, field: 2, scale: 1, time: 4 },
      unk_ds3_f2_3: { default: 0, field: 2 },
      jitterX: { default: 0, field: 2, scale: 1 },
      jitterY: { default: 0, field: 2, scale: 1 },
      jitterZ: { default: 0, field: 2, scale: 1 },
      flickerIntervalMin: { default: 0, field: 2, time: 2 },
      flickerIntervalMax: { default: 1, field: 2, time: 2 },
      flickerBrightness: { default: 0.5, field: 2 },
      shadows: { default: false, field: 0 },
      separateSpecular: { default: false, field: 0 },
      fadeOutTime: { default: 0, field: 1, time: 2 },
      shadowDarkness: { default: 1, field: 2 },
      unk_ds3_f2_15: { default: 0, field: 1 },
      unk_ds3_f2_16: { default: 2, field: 1 },
      unk_ds3_f2_17: { default: 1, field: 1 },
      unk_ds3_f2_18: { default: 0, field: 2 },
      unk_ds3_f2_19: { default: 0, field: 2 },
      unk_ds3_f2_20: { default: 0, field: 2 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 100, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      maxViewDistance: { default: 0, field: 2, scale: 2 },
      volumeDensity: { default: 0, field: 2 },
      unk_sdt_f2_25: { default: 0, field: 2 },
      phaseFunction: { default: true, field: 0 },
      asymmetryParam: { default: 0.75, field: 2 },
      adaptationExponent: { default: 0, field: 2 },
      unk_er_f2_29: { default: 1, field: 1 },
      unk_er_f2_30: { default: 1, field: 2 },
      unk_er_f2_31: { default: 1, field: 1 },
      unk_er_f2_32: { default: 0, field: 1 },
      unk_nr_f2_33: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 1, field: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','unk_ds3_f1_1'],
        fields2: ['unk_ds3_f2_0','jitterAndFlicker','jitterAcceleration','unk_ds3_f2_3','jitterX','jitterY','jitterZ','flickerIntervalMin','flickerIntervalMax','flickerBrightness','shadows','separateSpecular','unk_ds3_f2_12','fadeOutTime','shadowDarkness','unk_ds3_f2_15','unk_ds3_f2_16','unk_ds3_f2_17','unk_ds3_f2_18','unk_ds3_f2_19','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','maxViewDistance'],
        properties1: ['diffuseColor','specularColor','radius','unk_ds3_p1_3','unk_ds3_p1_4','unk_ds3_p1_5','unk_ds3_p1_6','unk_ds3_p1_7','unk_ds3_p1_8','unk_ds3_p1_9'],
        properties2: ['unk_ds3_p2_0','unk_ds3_p2_1']
      },
      [Game.Sekiro]: {
        fields1: Game.DarkSouls3,
        fields2: ['unk_ds3_f2_0','jitterAndFlicker','jitterAcceleration','unk_ds3_f2_3','jitterX','jitterY','jitterZ','flickerIntervalMin','flickerIntervalMax','flickerBrightness','shadows','separateSpecular','fadeOutTime','shadowDarkness','unk_ds3_f2_15','unk_ds3_f2_16','unk_ds3_f2_17','unk_ds3_f2_18','unk_ds3_f2_19','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','maxViewDistance','volumeDensity','unk_sdt_f2_25','phaseFunction','asymmetryParam','adaptationExponent'],
        properties1: Game.DarkSouls3,
        properties2: ['unk_ds3_p2_0','unk_ds3_p2_1','unk_sdt_p2_2','diffuseMultiplier','specularMultiplier']
      },
      [Game.EldenRing]: {
        fields1: Game.DarkSouls3,
        fields2: ['unk_ds3_f2_0','jitterAndFlicker','jitterAcceleration','unk_ds3_f2_3','jitterX','jitterY','jitterZ','flickerIntervalMin','flickerIntervalMax','flickerBrightness','shadows','separateSpecular','fadeOutTime','shadowDarkness','unk_ds3_f2_15','unk_ds3_f2_16','unk_ds3_f2_17','unk_ds3_f2_18','unk_ds3_f2_19','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','maxViewDistance','volumeDensity','unk_sdt_f2_25','phaseFunction','asymmetryParam','adaptationExponent','unk_er_f2_29','unk_er_f2_30','unk_er_f2_31','unk_er_f2_32'],
        properties1: Game.DarkSouls3,
        properties2: Game.Sekiro
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: {
        fields1: Game.DarkSouls3,
        fields2: ['unk_ds3_f2_0','jitterAndFlicker','jitterAcceleration','unk_ds3_f2_3','jitterX','jitterY','jitterZ','flickerIntervalMin','flickerIntervalMax','flickerBrightness','shadows','separateSpecular','fadeOutTime','shadowDarkness','unk_ds3_f2_15','unk_ds3_f2_16','unk_ds3_f2_17','unk_ds3_f2_18','unk_ds3_f2_19','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','maxViewDistance','volumeDensity','unk_sdt_f2_25','phaseFunction','asymmetryParam','adaptationExponent','unk_er_f2_29','unk_er_f2_30','unk_er_f2_31','unk_er_f2_32','unk_nr_f2_33'],
        properties1: Game.DarkSouls3,
        properties2: Game.Sekiro
      }
    }
  },
  [ActionType.SimulateTermination]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true
  },
  [ActionType.FadeTermination]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      duration: { default: 1, time: 2 },
    },
    games: {
      [Game.EldenRing]: {
        properties1: ['duration']
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.InstantTermination]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false
  },
  [ActionType.NodeForceSpeed]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      speed: { default: 0, scale: 1, time: 1 },
      speedMultiplier: { default: 1 },
      unk_sdt_f1_0: { default: 1, field: 1 },
    },
    games: {
      [Game.Sekiro]: {
        fields1: ['unk_sdt_f1_0'],
        properties1: ['speed','speedMultiplier']
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: Game.Sekiro,
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.ParticleForceSpeed]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      speed: { default: 0, scale: 1, time: 1 },
      speedMultiplier: { default: 1 },
      unk_sdt_f1_0: { default: 1, field: 1 },
      unk_sdt_f1_1: { default: 0, field: 1 },
    },
    games: {
      [Game.Sekiro]: {
        fields1: ['unk_sdt_f1_0','unk_sdt_f1_1'],
        properties1: ['speed','speedMultiplier']
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: Game.Sekiro,
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.NodeForceAcceleration]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      acceleration: { default: 0, scale: 1, time: 4 },
      accelerationMultiplier: { default: 1 },
      unk_sdt_f1_0: { default: 1, field: 1 },
    },
    games: {
      [Game.Sekiro]: {
        fields1: ['unk_sdt_f1_0'],
        properties1: ['acceleration','accelerationMultiplier']
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: Game.Sekiro,
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.ParticleForceAcceleration]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      acceleration: { default: 0, scale: 1, time: 4 },
      accelerationMultiplier: { default: 1 },
      unk_sdt_f1_0: { default: 1, field: 1 },
      unk_sdt_f1_1: { default: 0, field: 1 },
    },
    games: {
      [Game.Sekiro]: {
        fields1: ['unk_sdt_f1_0','unk_sdt_f1_1'],
        properties1: ['acceleration','accelerationMultiplier']
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: Game.Sekiro,
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.ParticleForceCollision]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: false,
    props: {
      radius: { default: 1, field: 2, scale: 6 },
      friction: { default: 0.5, field: 2 },
      bounciness: { default: 0.5, field: 2 },
    },
    games: {
      [Game.ArmoredCore6]: {
        fields1: ['radius','friction','bounciness']
      }
    }
  },
  [ActionType.GPUStandardParticle]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      particleFollowFactor: { default: 0 },
      unk_ds3_p1_1: { default: 0 },
      unk_ds3_p1_2: { default: 0 },
      unk_ds3_p1_3: { default: 0 },
      particleAccelerationX: { default: 0, scale: 1, time: 4 },
      particleAccelerationY: { default: 0, scale: 1, time: 4 },
      particleAccelerationZ: { default: 0, scale: 1, time: 4 },
      unk_ds3_p1_7: { default: 0 },
      unk_ds3_p1_8: { default: 0 },
      particleAngularAccelerationZ: { default: 0, time: 4 },
      particleGrowthRateX: { default: 0, scale: 4, time: 1 },
      particleGrowthRateY: { default: 0, scale: 4, time: 1 },
      unk_ds3_p1_12: { default: 0 },
      color: { default: [1, 1, 1, 1], color: 1 },
      unk_ds3_p1_14: { default: 1 },
      unk_ds3_p1_15: { default: 0 },
      unkParticleAcceleration: { default: 0, scale: 1, time: 4 },
      unk_ds3_p1_17: { default: 0 },
      particleGravity: { default: 0, scale: 1, time: 4 },
      particleRandomTurnAngle: { default: 0 },
      unk_ds3_p1_20: { default: 0 },
      unk_ds3_p2_0: { default: 1 },
      unk_ds3_p2_1: { default: 1 },
      unk_ds3_p2_2: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      unk_ds3_p2_6: { default: 0 },
      unk_ds3_f1_0: { default: 1005, field: 1 },
      texture: { default: 1, field: 1, resource: 0, textureType: 'a' },
      unk_ds3_f1_2: { default: 0, field: 1 },
      normalMap: { default: 0, field: 1, resource: 0, textureType: 'n' },
      emitterShape: { default: EmitterShape.Box, field: 1 },
      unk_ds3_f1_5: { default: 0, field: 1 },
      emitterSize: { default: [1, 1, 1], field: 4, scale: 1 },
      emitterRotation: { default: [0, 0, 0], field: 4 },
      unk_ds3_f1_12: { default: 1, field: 2 },
      unk_ds3_f1_13: { default: 1, field: 2 },
      unk_ds3_f1_14: { default: 1, field: 2 },
      emitterDistribution: { default: 0, field: 2 },
      unk_ds3_f1_16: { default: 0, field: 2 },
      unk_ds3_f1_17: { default: 0, field: 2 },
      unk_ds3_f1_18: { default: -1, field: 1 },
      unk_ds3_f1_19: { default: 0, field: 1 },
      unk_ds3_f1_20: { default: 0, field: 1 },
      unk_ds3_f1_21: { default: 100, field: 1 },
      emissionParticleCount: { default: 10, field: 1 },
      emissionParticleCountMin: { default: 0, field: 1 },
      emissionParticleCountMax: { default: 0, field: 1 },
      unk_ds3_f1_25: { default: 0, field: 1 },
      emissionIntervalMin: { default: 1, field: 1, time: 2 },
      emissionIntervalMax: { default: 1, field: 1, time: 2 },
      limitEmissionCount: { default: false, field: 0 },
      emissionCountLimit: { default: 0, field: 1 },
      unk_ds3_f1_30: { default: 0, field: 1 },
      particleDuration: { default: 1, field: 1, time: 2 },
      unk_ds3_f1_32: { default: 0, field: 1 },
      unk_ds3_f1_33: { default: 0, field: 1 },
      particleOffset: { default: [0, 0, 0], field: 4, scale: 1 },
      particleOffsetMin: { default: [0, 0, 0], field: 4, scale: 1 },
      particleOffsetMax: { default: [0, 0, 0], field: 4, scale: 1 },
      particleSpeed: { default: [0, 0, 0], field: 4, scale: 1, time: 1 },
      particleSpeedMin: { default: [0, 0, 0], field: 4, scale: 1, time: 1 },
      particleSpeedMax: { default: [0, 0, 0], field: 4, scale: 1, time: 1 },
      particleAccelerationMin: { default: [0, 0, 0], field: 4, scale: 1, time: 4 },
      particleAccelerationMax: { default: [0, 0, 0], field: 4, scale: 1, time: 4 },
      particleRotationVariance: { default: [0, 0, 0], field: 4 },
      particleAngularSpeedVariance: { default: [0, 0, 0], field: 4, time: 1 },
      particleAngularAccelerationMin: { default: [0, 0, 0], field: 4, time: 4 },
      particleAngularAccelerationMax: { default: [0, 0, 0], field: 4, time: 4 },
      particleUniformScale: { default: false, field: 0 },
      particleSizeX: { default: 1, field: 2, scale: 4 },
      particleSizeY: { default: 1, field: 2, scale: 4 },
      unk_ds3_f1_73: { default: 1, field: 2 },
      particleSizeXMin: { default: 0, field: 2, scale: 4 },
      particleSizeYMin: { default: 0, field: 2, scale: 4 },
      unk_ds3_f1_76: { default: 0, field: 2 },
      particleSizeXMax: { default: 0, field: 2, scale: 4 },
      particleSizeYMax: { default: 0, field: 2, scale: 4 },
      unk_ds3_f1_79: { default: 0, field: 2 },
      particleGrowthRateXStatic: { default: 0, field: 2, scale: 4, time: 1 },
      particleGrowthRateYStatic: { default: 0, field: 2, scale: 4, time: 1 },
      unk_ds3_f1_82: { default: 0, field: 2 },
      particleGrowthRateXMin: { default: 0, field: 2, scale: 4, time: 1 },
      particleGrowthRateYMin: { default: 0, field: 2, scale: 4, time: 1 },
      unk_ds3_f1_85: { default: 0, field: 2 },
      particleGrowthRateXMax: { default: 0, field: 2, scale: 4, time: 1 },
      particleGrowthRateYMax: { default: 0, field: 2, scale: 4, time: 1 },
      unk_ds3_f1_88: { default: 0, field: 2 },
      particleGrowthAccelerationXMin: { default: 0, field: 2, scale: 4, time: 4 },
      particleGrowthAccelerationYMin: { default: 0, field: 2, scale: 4, time: 4 },
      unk_ds3_f1_91: { default: 0, field: 2 },
      particleGrowthAccelerationXMax: { default: 0, field: 2, scale: 4, time: 4 },
      particleGrowthAccelerationYMax: { default: 0, field: 2, scale: 4, time: 4 },
      unk_ds3_f1_94: { default: 0, field: 2 },
      rgbMultiplier: { default: 1, field: 2 },
      alphaMultiplier: { default: 1, field: 2 },
      colorMin: { default: [0, 0, 0, 0], field: 5 },
      colorMax: { default: [0, 0, 0, 0], field: 5 },
      blendMode: { default: BlendMode.Normal, field: 1 },
      columns: { default: 1, field: 1 },
      totalFrames: { default: 1, field: 1 },
      randomTextureFrame: { default: false, field: 0 },
      unk_ds3_f1_109: { default: 0, field: 1 },
      maxFrameIndex: { default: 0, field: 1 },
      unk_ds3_f1_111: { default: -1, field: 1 },
      unk_ds3_f1_112: { default: -1, field: 1 },
      unk_ds3_f1_113: { default: 0, field: 1 },
      unk_ds3_f1_114: { default: 1, field: 1 },
      unk_ds3_f1_115: { default: 0, field: 1 },
      unk_ds3_f1_116: { default: 0, field: 1 },
      unk_ds3_f1_117: { default: 1, field: 2 },
      unk_ds3_f1_118: { default: 1, field: 2 },
      particleDurationMultiplier: { default: 1, field: 2 },
      unk_ds3_f1_120: { default: 1, field: 2 },
      particleSizeMultiplier: { default: 1, field: 2 },
      unk_ds3_f1_122: { default: 1, field: 2 },
      unk_ds3_f1_123: { default: 1, field: 2 },
      unk_ds3_f1_124: { default: 1, field: 2 },
      unk_ds3_f1_125: { default: 1, field: 2 },
      unk_ds3_f1_126: { default: 1, field: 2 },
      unk_ds3_f1_127: { default: 0, field: 1 },
      unk_ds3_f1_128: { default: 1, field: 2 },
      unk_ds3_f1_129: { default: 1, field: 2 },
      unk_ds3_f1_130: { default: 1, field: 2 },
      unk_ds3_f1_131: { default: 1, field: 2 },
      unk_ds3_f1_132: { default: 0, field: 1 },
      unk_ds3_f1_133: { default: 0, field: 1 },
      unk_ds3_f1_134: { default: 0, field: 1 },
      unk_ds3_f1_135: { default: 0, field: 2, scale: 1 },
      unk_ds3_f1_136: { default: 0, field: 2, scale: 1 },
      unk_ds3_f1_137: { default: 0, field: 1 },
      unk_ds3_f1_138: { default: 8, field: 1 },
      unk_ds3_f1_139: { default: 0, field: 2 },
      unk_ds3_f1_140: { default: 0, field: 2 },
      unk_ds3_f1_141: { default: 0, field: 1 },
      limitUpdateDistance: { default: false, field: 0 },
      updateDistance: { default: 0, field: 2, scale: 1 },
      particleCollision: { default: false, field: 0 },
      particleBounciness: { default: 0, field: 2 },
      particleRandomTurns: { default: false, field: 0 },
      particleRandomTurnIntervalMax: { default: 1, field: 1, time: 2 },
      traceParticles: { default: false, field: 0 },
      unk_ds3_f1_149: { default: 1, field: 2 },
      particleTraceLength: { default: 1, field: 2, scale: 4, time: 2 },
      traceParticlesThreshold: { default: 0, field: 2 },
      traceParticleHead: { default: false, field: 0 },
      unk_ds3_f1_153: { default: 0, field: 1 },
      unk_ds3_f1_154: { default: 0, field: 1 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_sdt_f1_160: { default: 1, field: 2 },
      unk_sdt_f1_161: { default: 0, field: 1 },
      unk_sdt_f1_162: { default: 1, field: 2 },
      unk_sdt_f1_163: { default: 1, field: 2 },
      unk_sdt_f1_164: { default: 1, field: 2 },
      unk_sdt_f1_165: { default: 0, field: 1 },
      unk_sdt_f1_166: { default: 1, field: 2 },
      unk_er_f1_167: { default: 1, field: 2 },
      desaturate: { default: 0, field: 2 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 0, field: 1 },
      unk_ds3_f2_4: { default: 0, field: 1 },
      unk_ds3_f2_5: { default: 1, field: 2 },
      unk_ds3_f2_6: { default: 1, field: 2 },
      unk_ds3_f2_7: { default: 1, field: 2 },
      unk_ds3_f2_8: { default: 1, field: 2 },
      unk_ds3_f2_9: { default: 0, field: 1 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0, field: 1 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 1, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_sdt_f2_29: { default: 0, field: 2 },
      shadowDarkness: { default: 0, field: 2 },
      unkHideIndoors: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: false, field: 0 },
      specular: { default: 0, field: 1, resource: 0, textureType: '3m' },
      glossiness: { default: 0.25, field: 2 },
      lighting: { default: -1, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      specularity: { default: 0.5, field: 2 },
      unk_er_f2_39: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','texture','unk_ds3_f1_2','normalMap','emitterShape','unk_ds3_f1_5','emitterSize','emitterRotation','unk_ds3_f1_12','unk_ds3_f1_13','unk_ds3_f1_14','emitterDistribution','unk_ds3_f1_16','unk_ds3_f1_17','unk_ds3_f1_18','unk_ds3_f1_19','unk_ds3_f1_20','unk_ds3_f1_21','emissionParticleCount','emissionParticleCountMin','emissionParticleCountMax','unk_ds3_f1_25','emissionIntervalMin','emissionIntervalMax','limitEmissionCount','emissionCountLimit','unk_ds3_f1_30','particleDuration','unk_ds3_f1_32','unk_ds3_f1_33','particleOffset','particleOffsetMin','particleOffsetMax','particleSpeed','particleSpeedMin','particleSpeedMax','particleAccelerationMin','particleAccelerationMax','particleRotationVariance','particleAngularSpeedVariance','particleAngularAccelerationMin','particleAngularAccelerationMax','particleUniformScale','particleSizeX','particleSizeY','unk_ds3_f1_73','particleSizeXMin','particleSizeYMin','unk_ds3_f1_76','particleSizeXMax','particleSizeYMax','unk_ds3_f1_79','particleGrowthRateXStatic','particleGrowthRateYStatic','unk_ds3_f1_82','particleGrowthRateXMin','particleGrowthRateYMin','unk_ds3_f1_85','particleGrowthRateXMax','particleGrowthRateYMax','unk_ds3_f1_88','particleGrowthAccelerationXMin','particleGrowthAccelerationYMin','unk_ds3_f1_91','particleGrowthAccelerationXMax','particleGrowthAccelerationYMax','unk_ds3_f1_94','rgbMultiplier','alphaMultiplier','colorMin','colorMax','blendMode','columns','totalFrames','randomTextureFrame','unk_ds3_f1_109','maxFrameIndex','unk_ds3_f1_111','unk_ds3_f1_112','unk_ds3_f1_113','unk_ds3_f1_114','unk_ds3_f1_115','unk_ds3_f1_116','unk_ds3_f1_117','unk_ds3_f1_118','particleDurationMultiplier','unk_ds3_f1_120','particleSizeMultiplier','unk_ds3_f1_122','unk_ds3_f1_123','unk_ds3_f1_124','unk_ds3_f1_125','unk_ds3_f1_126','unk_ds3_f1_127','unk_ds3_f1_128','unk_ds3_f1_129','unk_ds3_f1_130','unk_ds3_f1_131','unk_ds3_f1_132','unk_ds3_f1_133','unk_ds3_f1_134','unk_ds3_f1_135','unk_ds3_f1_136','unk_ds3_f1_137','unk_ds3_f1_138','unk_ds3_f1_139','unk_ds3_f1_140','unk_ds3_f1_141','limitUpdateDistance','updateDistance','particleCollision','particleBounciness','particleRandomTurns','particleRandomTurnIntervalMax','traceParticles','unk_ds3_f1_149','particleTraceLength','traceParticlesThreshold','traceParticleHead','unk_ds3_f1_153','unk_ds3_f1_154','bloom','bloomColor','desaturate'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','unk_ds3_f2_5','unk_ds3_f2_6','unk_ds3_f2_7','unk_ds3_f2_8','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_28'],
        properties1: ['particleFollowFactor','unk_ds3_p1_1','unk_ds3_p1_2','unk_ds3_p1_3','particleAccelerationX','particleAccelerationY','particleAccelerationZ','unk_ds3_p1_7','unk_ds3_p1_8','particleAngularAccelerationZ','particleGrowthRateX','particleGrowthRateY','unk_ds3_p1_12','color','unk_ds3_p1_14','unk_ds3_p1_15','unkParticleAcceleration','unk_ds3_p1_17','particleGravity','particleRandomTurnAngle','unk_ds3_p1_20'],
        properties2: ['unk_ds3_p2_0','unk_ds3_p2_1','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','unk_ds3_p2_6']
      },
      [Game.Sekiro]: {
        fields1: ['unk_ds3_f1_0','texture','unk_ds3_f1_2','normalMap','emitterShape','unk_ds3_f1_5','emitterSize','emitterRotation','unk_ds3_f1_12','unk_ds3_f1_13','unk_ds3_f1_14','emitterDistribution','unk_ds3_f1_16','unk_ds3_f1_17','unk_ds3_f1_18','unk_ds3_f1_19','unk_ds3_f1_20','unk_ds3_f1_21','emissionParticleCount','emissionParticleCountMin','emissionParticleCountMax','unk_ds3_f1_25','emissionIntervalMin','emissionIntervalMax','limitEmissionCount','emissionCountLimit','unk_ds3_f1_30','particleDuration','unk_ds3_f1_32','unk_ds3_f1_33','particleOffset','particleOffsetMin','particleOffsetMax','particleSpeed','particleSpeedMin','particleSpeedMax','particleAccelerationMin','particleAccelerationMax','particleRotationVariance','particleAngularSpeedVariance','particleAngularAccelerationMin','particleAngularAccelerationMax','particleUniformScale','particleSizeX','particleSizeY','unk_ds3_f1_73','particleSizeXMin','particleSizeYMin','unk_ds3_f1_76','particleSizeXMax','particleSizeYMax','unk_ds3_f1_79','particleGrowthRateXStatic','particleGrowthRateYStatic','unk_ds3_f1_82','particleGrowthRateXMin','particleGrowthRateYMin','unk_ds3_f1_85','particleGrowthRateXMax','particleGrowthRateYMax','unk_ds3_f1_88','particleGrowthAccelerationXMin','particleGrowthAccelerationYMin','unk_ds3_f1_91','particleGrowthAccelerationXMax','particleGrowthAccelerationYMax','unk_ds3_f1_94','rgbMultiplier','alphaMultiplier','colorMin','colorMax','blendMode','columns','totalFrames','randomTextureFrame','unk_ds3_f1_109','maxFrameIndex','unk_ds3_f1_111','unk_ds3_f1_112','unk_ds3_f1_113','unk_ds3_f1_114','unk_ds3_f1_115','unk_ds3_f1_116','unk_ds3_f1_117','unk_ds3_f1_118','particleDurationMultiplier','unk_ds3_f1_120','particleSizeMultiplier','unk_ds3_f1_122','unk_ds3_f1_123','unk_ds3_f1_124','unk_ds3_f1_125','unk_ds3_f1_126','unk_ds3_f1_127','unk_ds3_f1_128','unk_ds3_f1_129','unk_ds3_f1_130','unk_ds3_f1_131','unk_ds3_f1_132','unk_ds3_f1_133','unk_ds3_f1_134','unk_ds3_f1_135','unk_ds3_f1_136','unk_ds3_f1_137','unk_ds3_f1_138','unk_ds3_f1_139','unk_ds3_f1_140','unk_ds3_f1_141','limitUpdateDistance','updateDistance','particleCollision','particleBounciness','particleRandomTurns','particleRandomTurnIntervalMax','traceParticles','unk_ds3_f1_149','particleTraceLength','traceParticlesThreshold','traceParticleHead','unk_ds3_f1_153','unk_ds3_f1_154','bloom','bloomColor','unk_sdt_f1_160','unk_sdt_f1_161','unk_sdt_f1_162','unk_sdt_f1_163','unk_sdt_f1_164','unk_sdt_f1_165','unk_sdt_f1_166'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','unk_ds3_f2_5','unk_ds3_f2_6','unk_ds3_f2_7','unk_ds3_f2_8','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_sdt_f2_29','shadowDarkness','unkHideIndoors','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','specularity'],
        properties1: Game.DarkSouls3,
        properties2: Game.DarkSouls3
      },
      [Game.EldenRing]: {
        fields1: ['unk_ds3_f1_0','texture','unk_ds3_f1_2','normalMap','emitterShape','unk_ds3_f1_5','emitterSize','emitterRotation','unk_ds3_f1_12','unk_ds3_f1_13','unk_ds3_f1_14','emitterDistribution','unk_ds3_f1_16','unk_ds3_f1_17','unk_ds3_f1_18','unk_ds3_f1_19','unk_ds3_f1_20','unk_ds3_f1_21','emissionParticleCount','emissionParticleCountMin','emissionParticleCountMax','unk_ds3_f1_25','emissionIntervalMin','emissionIntervalMax','limitEmissionCount','emissionCountLimit','unk_ds3_f1_30','particleDuration','unk_ds3_f1_32','unk_ds3_f1_33','particleOffset','particleOffsetMin','particleOffsetMax','particleSpeed','particleSpeedMin','particleSpeedMax','particleAccelerationMin','particleAccelerationMax','particleRotationVariance','particleAngularSpeedVariance','particleAngularAccelerationMin','particleAngularAccelerationMax','particleUniformScale','particleSizeX','particleSizeY','unk_ds3_f1_73','particleSizeXMin','particleSizeYMin','unk_ds3_f1_76','particleSizeXMax','particleSizeYMax','unk_ds3_f1_79','particleGrowthRateXStatic','particleGrowthRateYStatic','unk_ds3_f1_82','particleGrowthRateXMin','particleGrowthRateYMin','unk_ds3_f1_85','particleGrowthRateXMax','particleGrowthRateYMax','unk_ds3_f1_88','particleGrowthAccelerationXMin','particleGrowthAccelerationYMin','unk_ds3_f1_91','particleGrowthAccelerationXMax','particleGrowthAccelerationYMax','unk_ds3_f1_94','rgbMultiplier','alphaMultiplier','colorMin','colorMax','blendMode','columns','totalFrames','randomTextureFrame','unk_ds3_f1_109','maxFrameIndex','unk_ds3_f1_111','unk_ds3_f1_112','unk_ds3_f1_113','unk_ds3_f1_114','unk_ds3_f1_115','unk_ds3_f1_116','unk_ds3_f1_117','unk_ds3_f1_118','particleDurationMultiplier','unk_ds3_f1_120','particleSizeMultiplier','unk_ds3_f1_122','unk_ds3_f1_123','unk_ds3_f1_124','unk_ds3_f1_125','unk_ds3_f1_126','unk_ds3_f1_127','unk_ds3_f1_128','unk_ds3_f1_129','unk_ds3_f1_130','unk_ds3_f1_131','unk_ds3_f1_132','unk_ds3_f1_133','unk_ds3_f1_134','unk_ds3_f1_135','unk_ds3_f1_136','unk_ds3_f1_137','unk_ds3_f1_138','unk_ds3_f1_139','unk_ds3_f1_140','unk_ds3_f1_141','limitUpdateDistance','updateDistance','particleCollision','particleBounciness','particleRandomTurns','particleRandomTurnIntervalMax','traceParticles','unk_ds3_f1_149','particleTraceLength','traceParticlesThreshold','traceParticleHead','unk_ds3_f1_153','unk_ds3_f1_154','bloom','bloomColor','unk_sdt_f1_160','unk_sdt_f1_161','unk_sdt_f1_162','unk_sdt_f1_163','unk_sdt_f1_164','unk_sdt_f1_165','unk_sdt_f1_166','unk_er_f1_167'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','unk_ds3_f2_5','unk_ds3_f2_6','unk_ds3_f2_7','unk_ds3_f2_8','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_sdt_f2_29','shadowDarkness','unkHideIndoors','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','specularity','unk_er_f2_39'],
        properties1: Game.DarkSouls3,
        properties2: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.GPUStandardCorrectParticle]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      particleFollowFactor: { default: 0 },
      unk_ds3_p1_1: { default: 0 },
      unk_ds3_p1_2: { default: 0 },
      unk_ds3_p1_3: { default: 0 },
      particleAccelerationX: { default: 0, scale: 1, time: 4 },
      particleAccelerationY: { default: 0, scale: 1, time: 4 },
      particleAccelerationZ: { default: 0, scale: 1, time: 4 },
      unk_ds3_p1_7: { default: 0 },
      unk_ds3_p1_8: { default: 0 },
      particleAngularAccelerationZ: { default: 0, time: 4 },
      particleGrowthRateX: { default: 0, scale: 4, time: 1 },
      particleGrowthRateY: { default: 0, scale: 4, time: 1 },
      unk_ds3_p1_12: { default: 0 },
      color: { default: [1, 1, 1, 1], color: 1 },
      unk_ds3_p1_14: { default: 1 },
      unk_ds3_p1_15: { default: 0 },
      unkParticleAcceleration: { default: 0, scale: 1, time: 4 },
      unk_ds3_p1_17: { default: 0 },
      particleGravity: { default: 0, scale: 1, time: 4 },
      particleRandomTurnAngle: { default: 0 },
      unk_ds3_p1_20: { default: 0 },
      unk_ds3_p2_0: { default: 1 },
      unk_ds3_p2_1: { default: 1 },
      unk_ds3_p2_2: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      unk_ds3_p2_6: { default: 0 },
      unk_ds3_f1_0: { default: 1005, field: 1 },
      texture: { default: 1, field: 1, resource: 0, textureType: 'a' },
      unk_ds3_f1_2: { default: 0, field: 1 },
      normalMap: { default: 0, field: 1, resource: 0, textureType: 'n' },
      emitterShape: { default: EmitterShape.Box, field: 1 },
      unk_ds3_f1_5: { default: 0, field: 1 },
      emitterSize: { default: [1, 1, 1], field: 4, scale: 1 },
      emitterRotation: { default: [0, 0, 0], field: 4 },
      unk_ds3_f1_12: { default: 1, field: 2 },
      unk_ds3_f1_13: { default: 1, field: 2 },
      unk_ds3_f1_14: { default: 1, field: 2 },
      emitterDistribution: { default: 0, field: 2 },
      unk_ds3_f1_16: { default: 0, field: 2 },
      unk_ds3_f1_17: { default: 0, field: 2 },
      unk_ds3_f1_18: { default: -1, field: 1 },
      unk_ds3_f1_19: { default: 0, field: 1 },
      unk_ds3_f1_20: { default: 0, field: 1 },
      unk_ds3_f1_21: { default: 100, field: 1 },
      emissionParticleCount: { default: 10, field: 1 },
      emissionParticleCountMin: { default: 0, field: 1 },
      emissionParticleCountMax: { default: 0, field: 1 },
      unk_ds3_f1_25: { default: 0, field: 1 },
      emissionIntervalMin: { default: 1, field: 1, time: 2 },
      emissionIntervalMax: { default: 1, field: 1, time: 2 },
      limitEmissionCount: { default: false, field: 0 },
      emissionCountLimit: { default: 0, field: 1 },
      unk_ds3_f1_30: { default: 0, field: 1 },
      particleDuration: { default: 1, field: 1, time: 2 },
      unk_ds3_f1_32: { default: 0, field: 1 },
      unk_ds3_f1_33: { default: 0, field: 1 },
      particleOffset: { default: [0, 0, 0], field: 4, scale: 1 },
      particleOffsetMin: { default: [0, 0, 0], field: 4, scale: 1 },
      particleOffsetMax: { default: [0, 0, 0], field: 4, scale: 1 },
      particleSpeed: { default: [0, 0, 0], field: 4, scale: 1, time: 1 },
      particleSpeedMin: { default: [0, 0, 0], field: 4, scale: 1, time: 1 },
      particleSpeedMax: { default: [0, 0, 0], field: 4, scale: 1, time: 1 },
      particleAccelerationMin: { default: [0, 0, 0], field: 4, scale: 1, time: 4 },
      particleAccelerationMax: { default: [0, 0, 0], field: 4, scale: 1, time: 4 },
      particleRotationVariance: { default: [0, 0, 0], field: 4 },
      particleAngularSpeedVariance: { default: [0, 0, 0], field: 4, time: 1 },
      particleAngularAccelerationMin: { default: [0, 0, 0], field: 4, time: 4 },
      particleAngularAccelerationMax: { default: [0, 0, 0], field: 4, time: 4 },
      particleUniformScale: { default: false, field: 0 },
      particleSizeX: { default: 1, field: 2, scale: 4 },
      particleSizeY: { default: 1, field: 2, scale: 4 },
      unk_ds3_f1_73: { default: 1, field: 2 },
      particleSizeXMin: { default: 0, field: 2, scale: 4 },
      particleSizeYMin: { default: 0, field: 2, scale: 4 },
      unk_ds3_f1_76: { default: 0, field: 2 },
      particleSizeXMax: { default: 0, field: 2, scale: 4 },
      particleSizeYMax: { default: 0, field: 2, scale: 4 },
      unk_ds3_f1_79: { default: 0, field: 2 },
      particleGrowthRateXStatic: { default: 0, field: 2, scale: 4, time: 1 },
      particleGrowthRateYStatic: { default: 0, field: 2, scale: 4, time: 1 },
      unk_ds3_f1_82: { default: 0, field: 2 },
      particleGrowthRateXMin: { default: 0, field: 2, scale: 4, time: 1 },
      particleGrowthRateYMin: { default: 0, field: 2, scale: 4, time: 1 },
      unk_ds3_f1_85: { default: 0, field: 2 },
      particleGrowthRateXMax: { default: 0, field: 2, scale: 4, time: 1 },
      particleGrowthRateYMax: { default: 0, field: 2, scale: 4, time: 1 },
      unk_ds3_f1_88: { default: 0, field: 2 },
      particleGrowthAccelerationXMin: { default: 0, field: 2, scale: 4, time: 4 },
      particleGrowthAccelerationYMin: { default: 0, field: 2, scale: 4, time: 4 },
      unk_ds3_f1_91: { default: 0, field: 2 },
      particleGrowthAccelerationXMax: { default: 0, field: 2, scale: 4, time: 4 },
      particleGrowthAccelerationYMax: { default: 0, field: 2, scale: 4, time: 4 },
      unk_ds3_f1_94: { default: 0, field: 2 },
      rgbMultiplier: { default: 1, field: 2 },
      alphaMultiplier: { default: 1, field: 2 },
      colorMin: { default: [0, 0, 0, 0], field: 5 },
      colorMax: { default: [0, 0, 0, 0], field: 5 },
      blendMode: { default: BlendMode.Normal, field: 1 },
      columns: { default: 1, field: 1 },
      totalFrames: { default: 1, field: 1 },
      randomTextureFrame: { default: false, field: 0 },
      unk_ds3_f1_109: { default: 0, field: 1 },
      maxFrameIndex: { default: 0, field: 1 },
      unk_ds3_f1_111: { default: -1, field: 1 },
      unk_ds3_f1_112: { default: -1, field: 1 },
      unk_ds3_f1_113: { default: 0, field: 1 },
      unk_ds3_f1_114: { default: 1, field: 1 },
      unk_ds3_f1_115: { default: 0, field: 1 },
      unk_ds3_f1_116: { default: 0, field: 1 },
      unk_ds3_f1_117: { default: 1, field: 2 },
      unk_ds3_f1_118: { default: 1, field: 2 },
      particleDurationMultiplier: { default: 1, field: 2 },
      unk_ds3_f1_120: { default: 1, field: 2 },
      particleSizeMultiplier: { default: 1, field: 2 },
      unk_ds3_f1_122: { default: 1, field: 2 },
      unk_ds3_f1_123: { default: 1, field: 2 },
      unk_ds3_f1_124: { default: 1, field: 2 },
      unk_ds3_f1_125: { default: 1, field: 2 },
      unk_ds3_f1_126: { default: 1, field: 2 },
      unk_ds3_f1_127: { default: 0, field: 1 },
      unk_ds3_f1_128: { default: 1, field: 2 },
      unk_ds3_f1_129: { default: 1, field: 2 },
      unk_ds3_f1_130: { default: 1, field: 2 },
      unk_ds3_f1_131: { default: 1, field: 2 },
      unk_ds3_f1_132: { default: 0, field: 1 },
      unk_ds3_f1_133: { default: 0, field: 1 },
      unk_ds3_f1_134: { default: 0, field: 1 },
      unk_ds3_f1_135: { default: 0, field: 2, scale: 1 },
      unk_ds3_f1_136: { default: 0, field: 2, scale: 1 },
      unk_ds3_f1_137: { default: 0, field: 1 },
      unk_ds3_f1_138: { default: 8, field: 1 },
      unk_ds3_f1_139: { default: 0, field: 2 },
      unk_ds3_f1_140: { default: 0, field: 2 },
      unk_ds3_f1_141: { default: 0, field: 1 },
      limitUpdateDistance: { default: false, field: 0 },
      updateDistance: { default: 0, field: 2, scale: 1 },
      particleCollision: { default: false, field: 0 },
      particleBounciness: { default: 0, field: 2 },
      particleRandomTurns: { default: false, field: 0 },
      particleRandomTurnIntervalMax: { default: 1, field: 1, time: 2 },
      traceParticles: { default: false, field: 0 },
      unk_ds3_f1_149: { default: 1, field: 2 },
      particleTraceLength: { default: 1, field: 2, scale: 4, time: 2 },
      traceParticlesThreshold: { default: 0, field: 2 },
      traceParticleHead: { default: false, field: 0 },
      unk_ds3_f1_153: { default: 0, field: 1 },
      unk_ds3_f1_154: { default: 0, field: 1 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_sdt_f1_160: { default: 1, field: 2 },
      unk_sdt_f1_161: { default: 0, field: 1 },
      unk_sdt_f1_162: { default: 1, field: 2 },
      unk_sdt_f1_163: { default: 1, field: 2 },
      unk_sdt_f1_164: { default: 1, field: 2 },
      unk_sdt_f1_165: { default: 0, field: 1 },
      unk_sdt_f1_166: { default: 1, field: 2 },
      unk_er_f1_167: { default: 1, field: 2 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 0, field: 1 },
      unk_ds3_f2_4: { default: 0, field: 1 },
      unk_ds3_f2_5: { default: 1, field: 2 },
      unk_ds3_f2_6: { default: 1, field: 2 },
      unk_ds3_f2_7: { default: 1, field: 2 },
      unk_ds3_f2_8: { default: 1, field: 2 },
      unk_ds3_f2_9: { default: 0, field: 1 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0, field: 1 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 1, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_sdt_f2_29: { default: 0, field: 2 },
      shadowDarkness: { default: 0, field: 2 },
      unkHideIndoors: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: false, field: 0 },
      specular: { default: 0, field: 1, resource: 0, textureType: '3m' },
      glossiness: { default: 0.25, field: 2 },
      lighting: { default: -1, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      specularity: { default: 0.5, field: 2 },
      unk_er_f2_39: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: -2,
      [Game.Sekiro]: -2,
      [Game.EldenRing]: {
        fields1: ['unk_ds3_f1_0','texture','unk_ds3_f1_2','normalMap','emitterShape','unk_ds3_f1_5','emitterSize','emitterRotation','unk_ds3_f1_12','unk_ds3_f1_13','unk_ds3_f1_14','emitterDistribution','unk_ds3_f1_16','unk_ds3_f1_17','unk_ds3_f1_18','unk_ds3_f1_19','unk_ds3_f1_20','unk_ds3_f1_21','emissionParticleCount','emissionParticleCountMin','emissionParticleCountMax','unk_ds3_f1_25','emissionIntervalMin','emissionIntervalMax','limitEmissionCount','emissionCountLimit','unk_ds3_f1_30','particleDuration','unk_ds3_f1_32','unk_ds3_f1_33','particleOffset','particleOffsetMin','particleOffsetMax','particleSpeed','particleSpeedMin','particleSpeedMax','particleAccelerationMin','particleAccelerationMax','particleRotationVariance','particleAngularSpeedVariance','particleAngularAccelerationMin','particleAngularAccelerationMax','particleUniformScale','particleSizeX','particleSizeY','unk_ds3_f1_73','particleSizeXMin','particleSizeYMin','unk_ds3_f1_76','particleSizeXMax','particleSizeYMax','unk_ds3_f1_79','particleGrowthRateXStatic','particleGrowthRateYStatic','unk_ds3_f1_82','particleGrowthRateXMin','particleGrowthRateYMin','unk_ds3_f1_85','particleGrowthRateXMax','particleGrowthRateYMax','unk_ds3_f1_88','particleGrowthAccelerationXMin','particleGrowthAccelerationYMin','unk_ds3_f1_91','particleGrowthAccelerationXMax','particleGrowthAccelerationYMax','unk_ds3_f1_94','rgbMultiplier','alphaMultiplier','colorMin','colorMax','blendMode','columns','totalFrames','randomTextureFrame','unk_ds3_f1_109','maxFrameIndex','unk_ds3_f1_111','unk_ds3_f1_112','unk_ds3_f1_113','unk_ds3_f1_114','unk_ds3_f1_115','unk_ds3_f1_116','unk_ds3_f1_117','unk_ds3_f1_118','particleDurationMultiplier','unk_ds3_f1_120','particleSizeMultiplier','unk_ds3_f1_122','unk_ds3_f1_123','unk_ds3_f1_124','unk_ds3_f1_125','unk_ds3_f1_126','unk_ds3_f1_127','unk_ds3_f1_128','unk_ds3_f1_129','unk_ds3_f1_130','unk_ds3_f1_131','unk_ds3_f1_132','unk_ds3_f1_133','unk_ds3_f1_134','unk_ds3_f1_135','unk_ds3_f1_136','unk_ds3_f1_137','unk_ds3_f1_138','unk_ds3_f1_139','unk_ds3_f1_140','unk_ds3_f1_141','limitUpdateDistance','updateDistance','particleCollision','particleBounciness','particleRandomTurns','particleRandomTurnIntervalMax','traceParticles','unk_ds3_f1_149','particleTraceLength','traceParticlesThreshold','traceParticleHead','unk_ds3_f1_153','unk_ds3_f1_154','bloom','bloomColor','unk_sdt_f1_160','unk_sdt_f1_161','unk_sdt_f1_162','unk_sdt_f1_163','unk_sdt_f1_164','unk_sdt_f1_165','unk_sdt_f1_166','unk_er_f1_167'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','unk_ds3_f2_4','unk_ds3_f2_5','unk_ds3_f2_6','unk_ds3_f2_7','unk_ds3_f2_8','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_sdt_f2_29','shadowDarkness','unkHideIndoors','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','specularity','unk_er_f2_39'],
        properties1: ['particleFollowFactor','unk_ds3_p1_1','unk_ds3_p1_2','unk_ds3_p1_3','particleAccelerationX','particleAccelerationY','particleAccelerationZ','unk_ds3_p1_7','unk_ds3_p1_8','particleAngularAccelerationZ','particleGrowthRateX','particleGrowthRateY','unk_ds3_p1_12','color','unk_ds3_p1_14','unk_ds3_p1_15','unkParticleAcceleration','unk_ds3_p1_17','particleGravity','particleRandomTurnAngle','unk_ds3_p1_20'],
        properties2: ['unk_ds3_p2_0','unk_ds3_p2_1','unk_ds3_p2_2','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','unk_ds3_p2_6']
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: Game.EldenRing
    }
  },
  [ActionType.LightShaft]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      width: { default: 1, scale: 4 },
      height: { default: 1, scale: 4 },
      color1: { default: [1, 1, 1, 1], color: 2 },
      color2: { default: [1, 1, 1, 1], color: 2 },
      color3: { default: [1, 1, 1, 1], color: 1 },
      unk_ds3_p1_5: { default: 0 },
      unk_ds3_p1_6: { default: 0 },
      unk_ds3_p1_7: { default: 0 },
      unk_ds3_p1_8: { default: 1 },
      unk_ds3_p1_9: { default: 1 },
      texture: { default: 0, field: 1, resource: 0, textureType: 'a' },
      blendMode: { default: BlendMode.Add, field: 1 },
      unk_ds3_f1_2: { default: 0.75, field: 2 },
      unk_ds3_f1_3: { default: 0.75, field: 2 },
      unk_ds3_f1_4: { default: 2, field: 2 },
      unk_ds3_f1_5: { default: 0.1, field: 2 },
      unk_ds3_f1_6: { default: 1, field: 2 },
      unk_ds3_f1_7: { default: 1, field: 2 },
      layers: { default: 30, field: 1 },
      unk_ds3_f1_9: { default: 1, field: 2 },
      unk_ds3_f1_10: { default: 1, field: 2 },
      unk_ds3_f1_11: { default: 1, field: 2 },
      unk_ds3_f1_12: { default: 0, field: 1 },
      unk_ds3_f1_13: { default: 0, field: 1 },
      unk_ds3_f1_14: { default: 0, field: 1 },
      unk_ds3_f1_15: { default: 1, field: 2 },
      unk_ds3_f1_16: { default: 1, field: 1 },
      unk_ds3_f1_17: { default: 0, field: 1 },
      unk_ds3_f1_18: { default: 1, field: 2 },
      unk_ds3_f1_19: { default: 1, field: 2 },
      unk_ds3_f1_20: { default: 1, field: 2 },
      unk_ds3_f1_21: { default: 1, field: 2 },
      unk_ds3_f1_22: { default: -1, field: 2 },
      unk_ds3_f1_23: { default: -1, field: 2 },
      unk_ds3_f1_24: { default: 0, field: 1 },
      unk_ds3_f1_25: { default: 1, field: 2 },
      unk_ds3_f1_26: { default: 1, field: 2 },
      unk_ds3_f1_27: { default: 1, field: 2 },
      unk_ds3_f1_28: { default: -1, field: 2 },
      unk_ds3_f1_29: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['texture','blendMode','unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4','unk_ds3_f1_5','unk_ds3_f1_6','unk_ds3_f1_7','layers','unk_ds3_f1_9','unk_ds3_f1_10','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15','unk_ds3_f1_16','unk_ds3_f1_17','unk_ds3_f1_18','unk_ds3_f1_19','unk_ds3_f1_20','unk_ds3_f1_21','unk_ds3_f1_22','unk_ds3_f1_23','unk_ds3_f1_24','unk_ds3_f1_25','unk_ds3_f1_26','unk_ds3_f1_27','unk_ds3_f1_28','unk_ds3_f1_29'],
        properties1: ['width','height','color1','color2','color3','unk_ds3_p1_5','unk_ds3_p1_6','unk_ds3_p1_7','unk_ds3_p1_8','unk_ds3_p1_9']
      },
      [Game.Sekiro]: Game.DarkSouls3
    }
  },
  [ActionType.GPUSparkParticle]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      particleFollowFactor: { default: 0 },
      unk_ac6_p1_1: { default: 0 },
      unk_ac6_p1_2: { default: 0 },
      unk_ac6_p1_3: { default: 0 },
      particleAccelerationX: { default: 0, scale: 1, time: 4 },
      particleAccelerationY: { default: 0, scale: 1, time: 4 },
      particleAccelerationZ: { default: 0, scale: 1, time: 4 },
      color: { default: [1, 1, 1, 1], color: 1 },
      particleLength: { default: 1, time: 2 },
      particleWidth: { default: 0.1 },
      unkParticleAcceleration: { default: 0, scale: 1, time: 4 },
      unk_ac6_p1_11: { default: 0 },
      particleGravity: { default: 1, scale: 1, time: 4 },
      unk_ac6_p1_13: { default: 0 },
      unk_ac6_p2_0: { default: 1 },
      unk_ac6_p2_1: { default: 1 },
      unk_ac6_p2_2: { default: 0 },
      unk_ac6_p2_3: { default: [1, 1, 1, 1] },
      unk_ac6_p2_4: { default: [1, 1, 1, 1] },
      unk_ac6_p2_5: { default: [1, 1, 1, 1] },
      unk_ac6_p2_6: { default: 0 },
      texture: { default: 1, field: 1, resource: 0, textureType: 'a' },
      emitterShape: { default: EmitterShape.Box, field: 1 },
      unk_ac6_f1_2: { default: 0, field: 1 },
      emitterSize: { default: [1, 1, 1], field: 4, scale: 1 },
      emitterRotation: { default: [0, 0, 0], field: 4 },
      unk_ac6_f1_9: { default: 1, field: 2 },
      unk_ac6_f1_10: { default: 1, field: 2 },
      unk_ac6_f1_11: { default: 1, field: 2 },
      emitterDistribution: { default: 0, field: 2 },
      unk_ac6_f1_13: { default: 0, field: 2 },
      unk_ac6_f1_14: { default: 0, field: 2 },
      unk_ac6_f1_15: { default: -1, field: 1 },
      unk_ac6_f1_16: { default: 0, field: 1 },
      unk_ac6_f1_17: { default: 0, field: 1 },
      emissionParticleCount: { default: 10, field: 1 },
      emissionParticleCountMin: { default: 0, field: 1 },
      emissionParticleCountMax: { default: 0, field: 1 },
      emissionInterval: { default: 0, field: 1, time: 2 },
      emissionIntervalMin: { default: 0, field: 1, time: 2 },
      emissionIntervalMax: { default: 0, field: 1, time: 2 },
      limitConcurrentEmissions: { default: false, field: 0 },
      concurrentEmissionsLimit: { default: 0, field: 1 },
      unk_ac6_f1_26: { default: 0, field: 1 },
      particleDuration: { default: 1, field: 1, time: 2 },
      unk_ac6_f1_28: { default: 0, field: 1 },
      unk_ac6_f1_29: { default: 0, field: 1 },
      particleOffset: { default: [0, 0, 0], field: 4, scale: 1 },
      particleOffsetMin: { default: [0, 0, 0], field: 4, scale: 1 },
      particleOffsetMax: { default: [0, 0, 0], field: 4, scale: 1 },
      unk_ac6_f1_39: { default: 0, field: 1 },
      particleSpeedMin: { default: [-0.01, -0.01, -0.01], field: 4, scale: 1, time: 1 },
      particleSpeedMax: { default: [0.01, 0.01, 0.01], field: 4, scale: 1, time: 1 },
      rgbMultiplier: { default: 1, field: 2 },
      alphaMultiplier: { default: 1, field: 2 },
      colorMin: { default: [0, 0, 0, 0], field: 5 },
      colorMax: { default: [0, 0, 0, 0], field: 5 },
      blendMode: { default: BlendMode.Add, field: 1 },
      unk_ac6_f1_57: { default: -1, field: 1 },
      unk_ac6_f1_58: { default: -1, field: 1 },
      unk_ac6_f1_59: { default: 0, field: 1 },
      unk_ac6_f1_60: { default: 0, field: 1 },
      unk_ac6_f1_61: { default: 0, field: 1 },
      unk_ac6_f1_62: { default: 0, field: 1 },
      particleLengthMin: { default: 1, field: 2, scale: 4 },
      particleLengthMax: { default: 1, field: 2, scale: 4 },
      particleWidthMin: { default: 1, field: 2, scale: 4 },
      particleWidthMax: { default: 1, field: 2, scale: 4 },
      unk_ac6_f1_67: { default: 1, field: 2 },
      unk_ac6_f1_68: { default: 1, field: 2 },
      particleDurationMultiplier: { default: 1, field: 2 },
      unk_ac6_f1_70: { default: 1, field: 2 },
      unk_ac6_f1_71: { default: 1, field: 2 },
      unk_ac6_f1_72: { default: 1, field: 2 },
      unk_ac6_f1_73: { default: 1, field: 2 },
      unk_ac6_f1_74: { default: 1, field: 2 },
      unk_ac6_f1_75: { default: 0, field: 2 },
      unk_ac6_f1_76: { default: 1, field: 2 },
      unk_ac6_f1_77: { default: 1, field: 2 },
      unk_ac6_f1_78: { default: 1, field: 2 },
      unk_ac6_f1_79: { default: 1, field: 2 },
      unk_ac6_f1_80: { default: 1, field: 2 },
      unk_ac6_f1_81: { default: 0, field: 1 },
      unk_ac6_f1_82: { default: 0, field: 1 },
      unk_ac6_f1_83: { default: 0, field: 1 },
      unk_ac6_f1_84: { default: 0, field: 2, scale: 1, time: 1 },
      unk_ac6_f1_85: { default: 0, field: 2, scale: 1, time: 1 },
      unk_ac6_f1_86: { default: 0, field: 1 },
      unk_ac6_f1_87: { default: 8, field: 1 },
      unk_ac6_f1_88: { default: 0, field: 1 },
      unk_ac6_f1_89: { default: 0, field: 1 },
      limitUpdateDistance: { default: false, field: 0 },
      updateDistance: { default: 0, field: 2, scale: 1 },
      particleCollision: { default: false, field: 0 },
      particleBounciness: { default: 0, field: 2 },
      unk_ac6_f1_94: { default: 0, field: 1 },
      unk_ac6_f1_95: { default: 0, field: 1 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ac6_f1_101: { default: 1, field: 2 },
      unk_ac6_f1_102: { default: 0, field: 1 },
      unk_ac6_f1_103: { default: 1, field: 2 },
      unk_ac6_f2_0: { default: 0, field: 1 },
      unk_ac6_f2_1: { default: 0, field: 1 },
      unk_ac6_f2_2: { default: 8, field: 1 },
      unk_ac6_f2_3: { default: 0, field: 1 },
      unk_ac6_f2_4: { default: 0, field: 1 },
      unk_ac6_f2_5: { default: 1, field: 2 },
      unk_ac6_f2_6: { default: 1, field: 2 },
      unk_ac6_f2_7: { default: 1, field: 2 },
      unk_ac6_f2_8: { default: 1, field: 2 },
      unk_ac6_f2_9: { default: 0, field: 1 },
      unk_ac6_f2_10: { default: 0, field: 1 },
      unk_ac6_f2_11: { default: 0, field: 1 },
      unk_ac6_f2_12: { default: 0, field: 1 },
      unk_ac6_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ac6_f2_20: { default: 0, field: 1 },
      unk_ac6_f2_21: { default: 0, field: 1 },
      unk_ac6_f2_22: { default: 0, field: 1 },
      unk_ac6_f2_23: { default: 0, field: 1 },
      unk_ac6_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ac6_f2_27: { default: 1, field: 1 },
      unk_ac6_f2_28: { default: 0, field: 1 },
      unk_ac6_f2_29: { default: 0, field: 2 },
      shadowDarkness: { default: 1, field: 2 },
      unkHideIndoors: { default: 0, field: 1 },
      unk_ac6_f2_32: { default: 0, field: 1 },
      unk_ac6_f2_33: { default: 0, field: 1 },
      unk_ac6_f2_34: { default: 0.5, field: 2 },
      lighting: { default: -1, field: 1 },
      unk_ac6_f2_36: { default: -2, field: 1 },
      unk_ac6_f2_37: { default: 0, field: 1 },
      unk_ac6_f2_38: { default: 0, field: 2 },
      unk_ac6_f2_39: { default: 0, field: 1 },
    },
    games: {
      [Game.Sekiro]: Game.ArmoredCore6,
      [Game.EldenRing]: Game.ArmoredCore6,
      [Game.ArmoredCore6]: {
        fields1: ['texture','emitterShape','unk_ac6_f1_2','emitterSize','emitterRotation','unk_ac6_f1_9','unk_ac6_f1_10','unk_ac6_f1_11','emitterDistribution','unk_ac6_f1_13','unk_ac6_f1_14','unk_ac6_f1_15','unk_ac6_f1_16','unk_ac6_f1_17','emissionParticleCount','emissionParticleCountMin','emissionParticleCountMax','emissionInterval','emissionIntervalMin','emissionIntervalMax','limitConcurrentEmissions','concurrentEmissionsLimit','unk_ac6_f1_26','particleDuration','unk_ac6_f1_28','unk_ac6_f1_29','particleOffset','particleOffsetMin','particleOffsetMax','unk_ac6_f1_39','particleSpeedMin','particleSpeedMax','rgbMultiplier','alphaMultiplier','colorMin','colorMax','blendMode','unk_ac6_f1_57','unk_ac6_f1_58','unk_ac6_f1_59','unk_ac6_f1_60','unk_ac6_f1_61','unk_ac6_f1_62','particleLengthMin','particleLengthMax','particleWidthMin','particleWidthMax','unk_ac6_f1_67','unk_ac6_f1_68','particleDurationMultiplier','unk_ac6_f1_70','unk_ac6_f1_71','unk_ac6_f1_72','unk_ac6_f1_73','unk_ac6_f1_74','unk_ac6_f1_75','unk_ac6_f1_76','unk_ac6_f1_77','unk_ac6_f1_78','unk_ac6_f1_79','unk_ac6_f1_80','unk_ac6_f1_81','unk_ac6_f1_82','unk_ac6_f1_83','unk_ac6_f1_84','unk_ac6_f1_85','unk_ac6_f1_86','unk_ac6_f1_87','unk_ac6_f1_88','unk_ac6_f1_89','limitUpdateDistance','updateDistance','particleCollision','particleBounciness','unk_ac6_f1_94','unk_ac6_f1_95','bloom','bloomColor','unk_ac6_f1_101','unk_ac6_f1_102','unk_ac6_f1_103'],
        fields2: ['unk_ac6_f2_0','unk_ac6_f2_1','unk_ac6_f2_2','unk_ac6_f2_3','unk_ac6_f2_4','unk_ac6_f2_5','unk_ac6_f2_6','unk_ac6_f2_7','unk_ac6_f2_8','unk_ac6_f2_9','unk_ac6_f2_10','unk_ac6_f2_11','unk_ac6_f2_12','unk_ac6_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ac6_f2_20','unk_ac6_f2_21','unk_ac6_f2_22','unk_ac6_f2_23','unk_ac6_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ac6_f2_27','unk_ac6_f2_28','unk_ac6_f2_29','shadowDarkness','unkHideIndoors','unk_ac6_f2_32','unk_ac6_f2_33','unk_ac6_f2_34','lighting','unk_ac6_f2_36','unk_ac6_f2_37','unk_ac6_f2_38','unk_ac6_f2_39'],
        properties1: ['particleFollowFactor','unk_ac6_p1_1','unk_ac6_p1_2','unk_ac6_p1_3','particleAccelerationX','particleAccelerationY','particleAccelerationZ','color','particleLength','particleWidth','unkParticleAcceleration','unk_ac6_p1_11','particleGravity','unk_ac6_p1_13'],
        properties2: ['unk_ac6_p2_0','unk_ac6_p2_1','unk_ac6_p2_2','unk_ac6_p2_3','unk_ac6_p2_4','unk_ac6_p2_5','unk_ac6_p2_6']
      },
      [Game.Nightreign]: Game.ArmoredCore6
    }
  },
  [ActionType.GPUSparkCorrectParticle]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      particleFollowFactor: { default: 0 },
      unk_ac6_p1_1: { default: 0 },
      unk_ac6_p1_2: { default: 0 },
      unk_ac6_p1_3: { default: 0 },
      particleAccelerationX: { default: 0, scale: 1, time: 4 },
      particleAccelerationY: { default: 0, scale: 1, time: 4 },
      particleAccelerationZ: { default: 0, scale: 1, time: 4 },
      color: { default: [1, 1, 1, 1], color: 1 },
      particleLength: { default: 1, time: 2 },
      particleWidth: { default: 0.1 },
      unkParticleAcceleration: { default: 0, scale: 1, time: 4 },
      unk_ac6_p1_11: { default: 0 },
      particleGravity: { default: 1, scale: 1, time: 4 },
      unk_ac6_p1_13: { default: 0 },
      unk_ac6_p2_0: { default: 1 },
      unk_ac6_p2_1: { default: 1 },
      unk_ac6_p2_2: { default: 0 },
      unk_ac6_p2_3: { default: [1, 1, 1, 1] },
      unk_ac6_p2_4: { default: [1, 1, 1, 1] },
      unk_ac6_p2_5: { default: [1, 1, 1, 1] },
      unk_ac6_p2_6: { default: 0 },
      texture: { default: 1, field: 1, resource: 0, textureType: 'a' },
      emitterShape: { default: EmitterShape.Box, field: 1 },
      unk_ac6_f1_2: { default: 0, field: 1 },
      emitterSize: { default: [1, 1, 1], field: 4, scale: 1 },
      emitterRotation: { default: [0, 0, 0], field: 4 },
      unk_ac6_f1_9: { default: 1, field: 2 },
      unk_ac6_f1_10: { default: 1, field: 2 },
      unk_ac6_f1_11: { default: 1, field: 2 },
      emitterDistribution: { default: 0, field: 2 },
      unk_ac6_f1_13: { default: 0, field: 2 },
      unk_ac6_f1_14: { default: 0, field: 2 },
      unk_ac6_f1_15: { default: -1, field: 1 },
      unk_ac6_f1_16: { default: 0, field: 1 },
      unk_ac6_f1_17: { default: 0, field: 1 },
      emissionParticleCount: { default: 10, field: 1 },
      emissionParticleCountMin: { default: 0, field: 1 },
      emissionParticleCountMax: { default: 0, field: 1 },
      emissionInterval: { default: 0, field: 1, time: 2 },
      emissionIntervalMin: { default: 0, field: 1, time: 2 },
      emissionIntervalMax: { default: 0, field: 1, time: 2 },
      limitConcurrentEmissions: { default: false, field: 0 },
      concurrentEmissionsLimit: { default: 0, field: 1 },
      unk_ac6_f1_26: { default: 0, field: 1 },
      particleDuration: { default: 1, field: 1, time: 2 },
      unk_ac6_f1_28: { default: 0, field: 1 },
      unk_ac6_f1_29: { default: 0, field: 1 },
      particleOffset: { default: [0, 0, 0], field: 4, scale: 1 },
      particleOffsetMin: { default: [0, 0, 0], field: 4, scale: 1 },
      particleOffsetMax: { default: [0, 0, 0], field: 4, scale: 1 },
      unk_ac6_f1_39: { default: 0, field: 1 },
      particleSpeedMin: { default: [-0.01, -0.01, -0.01], field: 4, scale: 1, time: 1 },
      particleSpeedMax: { default: [0.01, 0.01, 0.01], field: 4, scale: 1, time: 1 },
      rgbMultiplier: { default: 1, field: 2 },
      alphaMultiplier: { default: 1, field: 2 },
      colorMin: { default: [0, 0, 0, 0], field: 5 },
      colorMax: { default: [0, 0, 0, 0], field: 5 },
      blendMode: { default: BlendMode.Add, field: 1 },
      unk_ac6_f1_57: { default: -1, field: 1 },
      unk_ac6_f1_58: { default: -1, field: 1 },
      unk_ac6_f1_59: { default: 0, field: 1 },
      unk_ac6_f1_60: { default: 0, field: 1 },
      unk_ac6_f1_61: { default: 0, field: 1 },
      unk_ac6_f1_62: { default: 0, field: 1 },
      particleLengthMin: { default: 1, field: 2, scale: 4 },
      particleLengthMax: { default: 1, field: 2, scale: 4 },
      particleWidthMin: { default: 1, field: 2, scale: 4 },
      particleWidthMax: { default: 1, field: 2, scale: 4 },
      unk_ac6_f1_67: { default: 1, field: 2 },
      unk_ac6_f1_68: { default: 1, field: 2 },
      particleDurationMultiplier: { default: 1, field: 2 },
      unk_ac6_f1_70: { default: 1, field: 2 },
      unk_ac6_f1_71: { default: 1, field: 2 },
      unk_ac6_f1_72: { default: 1, field: 2 },
      unk_ac6_f1_73: { default: 1, field: 2 },
      unk_ac6_f1_74: { default: 1, field: 2 },
      unk_ac6_f1_75: { default: 0, field: 2 },
      unk_ac6_f1_76: { default: 1, field: 2 },
      unk_ac6_f1_77: { default: 1, field: 2 },
      unk_ac6_f1_78: { default: 1, field: 2 },
      unk_ac6_f1_79: { default: 1, field: 2 },
      unk_ac6_f1_80: { default: 1, field: 2 },
      unk_ac6_f1_81: { default: 0, field: 1 },
      unk_ac6_f1_82: { default: 0, field: 1 },
      unk_ac6_f1_83: { default: 0, field: 1 },
      unk_ac6_f1_84: { default: 0, field: 2, scale: 1, time: 1 },
      unk_ac6_f1_85: { default: 0, field: 2, scale: 1, time: 1 },
      unk_ac6_f1_86: { default: 0, field: 1 },
      unk_ac6_f1_87: { default: 8, field: 1 },
      unk_ac6_f1_88: { default: 0, field: 1 },
      unk_ac6_f1_89: { default: 0, field: 1 },
      limitUpdateDistance: { default: false, field: 0 },
      updateDistance: { default: 0, field: 2, scale: 1 },
      particleCollision: { default: false, field: 0 },
      particleBounciness: { default: 0, field: 2 },
      unk_ac6_f1_94: { default: 0, field: 1 },
      unk_ac6_f1_95: { default: 0, field: 1 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ac6_f1_101: { default: 1, field: 2 },
      unk_ac6_f1_102: { default: 0, field: 1 },
      unk_ac6_f1_103: { default: 1, field: 2 },
      unk_ac6_f2_0: { default: 0, field: 1 },
      unk_ac6_f2_1: { default: 0, field: 1 },
      unk_ac6_f2_2: { default: 8, field: 1 },
      unk_ac6_f2_3: { default: 0, field: 1 },
      unk_ac6_f2_4: { default: 0, field: 1 },
      unk_ac6_f2_5: { default: 1, field: 2 },
      unk_ac6_f2_6: { default: 1, field: 2 },
      unk_ac6_f2_7: { default: 1, field: 2 },
      unk_ac6_f2_8: { default: 1, field: 2 },
      unk_ac6_f2_9: { default: 0, field: 1 },
      unk_ac6_f2_10: { default: 0, field: 1 },
      unk_ac6_f2_11: { default: 0, field: 1 },
      unk_ac6_f2_12: { default: 0, field: 1 },
      unk_ac6_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ac6_f2_20: { default: 0, field: 1 },
      unk_ac6_f2_21: { default: 0, field: 1 },
      unk_ac6_f2_22: { default: 0, field: 1 },
      unk_ac6_f2_23: { default: 0, field: 1 },
      unk_ac6_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ac6_f2_27: { default: 1, field: 1 },
      unk_ac6_f2_28: { default: 0, field: 1 },
      unk_ac6_f2_29: { default: 0, field: 2 },
      shadowDarkness: { default: 1, field: 2 },
      unkHideIndoors: { default: 0, field: 1 },
      unk_ac6_f2_32: { default: 0, field: 1 },
      unk_ac6_f2_33: { default: 0, field: 1 },
      unk_ac6_f2_34: { default: 0.5, field: 2 },
      lighting: { default: -1, field: 1 },
      unk_ac6_f2_36: { default: -2, field: 1 },
      unk_ac6_f2_37: { default: 0, field: 1 },
      unk_ac6_f2_38: { default: 0, field: 2 },
      unk_ac6_f2_39: { default: 0, field: 1 },
    },
    games: {
      [Game.EldenRing]: Game.ArmoredCore6,
      [Game.ArmoredCore6]: {
        fields1: ['texture','emitterShape','unk_ac6_f1_2','emitterSize','emitterRotation','unk_ac6_f1_9','unk_ac6_f1_10','unk_ac6_f1_11','emitterDistribution','unk_ac6_f1_13','unk_ac6_f1_14','unk_ac6_f1_15','unk_ac6_f1_16','unk_ac6_f1_17','emissionParticleCount','emissionParticleCountMin','emissionParticleCountMax','emissionInterval','emissionIntervalMin','emissionIntervalMax','limitConcurrentEmissions','concurrentEmissionsLimit','unk_ac6_f1_26','particleDuration','unk_ac6_f1_28','unk_ac6_f1_29','particleOffset','particleOffsetMin','particleOffsetMax','unk_ac6_f1_39','particleSpeedMin','particleSpeedMax','rgbMultiplier','alphaMultiplier','colorMin','colorMax','blendMode','unk_ac6_f1_57','unk_ac6_f1_58','unk_ac6_f1_59','unk_ac6_f1_60','unk_ac6_f1_61','unk_ac6_f1_62','particleLengthMin','particleLengthMax','particleWidthMin','particleWidthMax','unk_ac6_f1_67','unk_ac6_f1_68','particleDurationMultiplier','unk_ac6_f1_70','unk_ac6_f1_71','unk_ac6_f1_72','unk_ac6_f1_73','unk_ac6_f1_74','unk_ac6_f1_75','unk_ac6_f1_76','unk_ac6_f1_77','unk_ac6_f1_78','unk_ac6_f1_79','unk_ac6_f1_80','unk_ac6_f1_81','unk_ac6_f1_82','unk_ac6_f1_83','unk_ac6_f1_84','unk_ac6_f1_85','unk_ac6_f1_86','unk_ac6_f1_87','unk_ac6_f1_88','unk_ac6_f1_89','limitUpdateDistance','updateDistance','particleCollision','particleBounciness','unk_ac6_f1_94','unk_ac6_f1_95','bloom','bloomColor','unk_ac6_f1_101','unk_ac6_f1_102','unk_ac6_f1_103'],
        fields2: ['unk_ac6_f2_0','unk_ac6_f2_1','unk_ac6_f2_2','unk_ac6_f2_3','unk_ac6_f2_4','unk_ac6_f2_5','unk_ac6_f2_6','unk_ac6_f2_7','unk_ac6_f2_8','unk_ac6_f2_9','unk_ac6_f2_10','unk_ac6_f2_11','unk_ac6_f2_12','unk_ac6_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ac6_f2_20','unk_ac6_f2_21','unk_ac6_f2_22','unk_ac6_f2_23','unk_ac6_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ac6_f2_27','unk_ac6_f2_28','unk_ac6_f2_29','shadowDarkness','unkHideIndoors','unk_ac6_f2_32','unk_ac6_f2_33','unk_ac6_f2_34','lighting','unk_ac6_f2_36','unk_ac6_f2_37','unk_ac6_f2_38','unk_ac6_f2_39'],
        properties1: ['particleFollowFactor','unk_ac6_p1_1','unk_ac6_p1_2','unk_ac6_p1_3','particleAccelerationX','particleAccelerationY','particleAccelerationZ','color','particleLength','particleWidth','unkParticleAcceleration','unk_ac6_p1_11','particleGravity','unk_ac6_p1_13'],
        properties2: ['unk_ac6_p2_0','unk_ac6_p2_1','unk_ac6_p2_2','unk_ac6_p2_3','unk_ac6_p2_4','unk_ac6_p2_5','unk_ac6_p2_6']
      },
      [Game.Nightreign]: Game.ArmoredCore6
    }
  },
  [ActionType.Tracer]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      texture: { default: 1, field: 1, resource: 0, textureType: 'a' },
      blendMode: { default: BlendMode.Normal, field: 1 },
      width: { default: 1, scale: 4 },
      widthMultiplier: { default: 1 },
      startFadeEndpoint: { default: 0 },
      endFadeEndpoint: { default: 0 },
      color1: { default: [1, 1, 1, 1], color: 2 },
      color2: { default: [1, 1, 1, 1], color: 2 },
      color3: { default: [1, 1, 1, 1], color: 1 },
      alphaFadeThreshold: { default: 0 },
      frameIndex: { default: 0 },
      frameIndexOffset: { default: 0 },
      textureFraction: { default: 0.1 },
      speedU: { default: 0, time: 1 },
      varianceV: { default: 0 },
      unk_ds3_p1_13: { default: -1 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      distortionIntensity: { default: 0 },
      unk_ds3_p2_3: { default: [1, 1, 1, 1] },
      unk_ds3_p2_4: { default: [1, 1, 1, 1] },
      unk_ds3_p2_5: { default: [1, 1, 1, 1] },
      alphaThreshold: { default: 0 },
      orientation: { default: TracerOrientationMode.LocalZ, field: 1 },
      normalMap: { default: 0, field: 1, resource: 0, textureType: 'n' },
      segmentInterval: { default: 0, field: 2, time: 2 },
      segmentDuration: { default: 1, field: 2, scale: 4, time: 5 },
      concurrentSegments: { default: 100, field: 1 },
      segmentSubdivision: { default: 0, field: 1 },
      unk_ds3_f1_8: { default: 0, field: 2 },
      fadeOutTime: { default: 0, field: 2 },
      columns: { default: 1, field: 1 },
      totalFrames: { default: 1, field: 1 },
      attachedUV: { default: true, field: 0 },
      unk_ds3_f1_13: { default: -1, field: 1 },
      unk_ds3_f1_14: { default: -1, field: 1 },
      unk_ds3_f1_15: { default: 0, field: 1 },
      dynamicOpacity: { default: false, field: 0 },
      unk_sdt_f1_15: { default: 1, field: 2 },
      unk_sdt_f1_16: { default: 1, field: 2 },
      varianceU: { default: 0, field: 2 },
      unk_er_f1_18: { default: 1, field: 1 },
      unk_er_f1_19: { default: 1, field: 1 },
      unk_er_f1_20: { default: 0, field: 1 },
      unk_er_f1_21: { default: 0, field: 2 },
      unk_ds3_f2_0: { default: 0, field: 1 },
      unk_ds3_f2_1: { default: 0, field: 1 },
      unk_ds3_f2_2: { default: 8, field: 1 },
      unk_ds3_f2_3: { default: 0, field: 1 },
      bloom: { default: false, field: 0 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ds3_f2_9: { default: 0, field: 1 },
      unk_ds3_f2_10: { default: 0, field: 1 },
      unk_ds3_f2_11: { default: 0, field: 1 },
      unk_ds3_f2_12: { default: 0, field: 1 },
      unk_ds3_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_ds3_f2_20: { default: 0, field: 2 },
      unk_ds3_f2_21: { default: 0, field: 1 },
      unk_ds3_f2_22: { default: 0, field: 1 },
      unk_ds3_f2_23: { default: 0, field: 1 },
      unk_ds3_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_ds3_f2_27: { default: 1, field: 1 },
      unk_ds3_f2_28: { default: 0, field: 1 },
      unk_ds3_f2_29: { default: 0, field: 2, scale: 2 },
      shadowDarkness: { default: 0, field: 2 },
      unk_sdt_f2_31: { default: 0, field: 1 },
      unk_sdt_f2_32: { default: false, field: 0 },
      specular: { default: 0, field: 1, resource: 0, textureType: '3m' },
      glossiness: { default: 0.25, field: 2 },
      lighting: { default: -1, field: 1 },
      unk_sdt_f2_36: { default: -2, field: 1 },
      unk_sdt_f2_37: { default: 0, field: 1 },
      specularity: { default: 0.5, field: 2 },
      unk_er_f2_39: { default: 0, field: 1 },
      unk_er_f2_40: { default: 1, field: 2 },
      unk_ac6_f2_41: { default: 0, field: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['orientation','texture','normalMap','blendMode','segmentInterval','segmentDuration','concurrentSegments','segmentSubdivision','unk_ds3_f1_8','fadeOutTime','columns','totalFrames','attachedUV','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29'],
        properties1: ['width','widthMultiplier','startFadeEndpoint','endFadeEndpoint','color1','color2','color3','alphaFadeThreshold','frameIndex','frameIndexOffset','textureFraction','speedU','varianceV','unk_ds3_p1_13'],
        properties2: ['rgbMultiplier','alphaMultiplier','distortionIntensity','unk_ds3_p2_3','unk_ds3_p2_4','unk_ds3_p2_5','alphaThreshold']
      },
      [Game.Sekiro]: {
        fields1: ['orientation','normalMap','segmentInterval','segmentDuration','concurrentSegments','segmentSubdivision','unk_ds3_f1_8','fadeOutTime','columns','totalFrames','attachedUV','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15','dynamicOpacity','unk_sdt_f1_15','unk_sdt_f1_16','varianceU'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','shadowDarkness','unk_sdt_f2_31','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','specularity'],
        properties1: ['texture','blendMode','width','widthMultiplier','startFadeEndpoint','endFadeEndpoint','color1','color2','color3','alphaFadeThreshold','frameIndex','frameIndexOffset','textureFraction','speedU','varianceV','unk_ds3_p1_13'],
        properties2: Game.DarkSouls3
      },
      [Game.EldenRing]: {
        fields1: ['orientation','normalMap','segmentInterval','segmentDuration','concurrentSegments','segmentSubdivision','unk_ds3_f1_8','fadeOutTime','columns','totalFrames','attachedUV','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15','dynamicOpacity','unk_sdt_f1_15','unk_sdt_f1_16','varianceU','unk_er_f1_18','unk_er_f1_19','unk_er_f1_20','unk_er_f1_21'],
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','shadowDarkness','unk_sdt_f2_31','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','specularity','unk_er_f2_39','unk_er_f2_40'],
        properties1: Game.Sekiro,
        properties2: Game.DarkSouls3
      },
      [Game.ArmoredCore6]: {
        fields1: Game.EldenRing,
        fields2: ['unk_ds3_f2_0','unk_ds3_f2_1','unk_ds3_f2_2','unk_ds3_f2_3','bloom','bloomColor','unk_ds3_f2_9','unk_ds3_f2_10','unk_ds3_f2_11','unk_ds3_f2_12','unk_ds3_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_ds3_f2_20','unk_ds3_f2_21','unk_ds3_f2_22','unk_ds3_f2_23','unk_ds3_f2_24','unkDepthBlend1','unkDepthBlend2','unk_ds3_f2_27','unk_ds3_f2_28','unk_ds3_f2_29','shadowDarkness','unk_sdt_f2_31','unk_sdt_f2_32','specular','glossiness','lighting','unk_sdt_f2_36','unk_sdt_f2_37','specularity','unk_er_f2_39','unk_er_f2_40','unk_ac6_f2_41'],
        properties1: Game.Sekiro,
        properties2: Game.DarkSouls3
      },
      [Game.Nightreign]: Game.ArmoredCore6
    }
  },
  [ActionType.WaterInteraction]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      texture: { default: 50004, field: 1, resource: 0, textureType: 'd' },
      depth: { default: 1, field: 2, scale: 4 },
      size: { default: 1, field: 2, scale: 4 },
      descent: { default: 0.15, field: 2, time: 2 },
      duration: { default: 0.15, field: 2, time: 2 },
    },
    games: {
      [Game.Sekiro]: {
        fields1: ['texture','depth','size','descent','duration']
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: Game.Sekiro,
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.LensFlare]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      layer1Width: { default: 1, scale: 4 },
      layer1Height: { default: 1, scale: 4 },
      layer1Color: { default: [1, 1, 1, 1], color: 1 },
      layer2Width: { default: 1, scale: 4 },
      layer2Height: { default: 1, scale: 4 },
      layer2Color: { default: [1, 1, 1, 1], color: 1 },
      layer3Width: { default: 1, scale: 4 },
      layer3Height: { default: 1, scale: 4 },
      layer3Color: { default: [1, 1, 1, 1], color: 1 },
      layer4Width: { default: 1, scale: 4 },
      layer4Height: { default: 1, scale: 4 },
      layer4Color: { default: [1, 1, 1, 1], color: 1 },
      layer1: { default: 1, field: 1, resource: 0, textureType: 'a' },
      layer2: { default: 0, field: 1, resource: 0, textureType: 'a' },
      layer3: { default: 0, field: 1, resource: 0, textureType: 'a' },
      layer4: { default: 0, field: 1, resource: 0, textureType: 'a' },
      blendMode: { default: BlendMode.Add, field: 1 },
      unk_er_f1_4: { default: 0, field: 1 },
      sourceSize: { default: 1, field: 2 },
      opacityTransitionDuration: { default: 1, field: 2 },
      unk_er_f1_8: { default: 0, field: 1 },
      layer1Count: { default: 1, field: 1 },
      layer1ScaleVariationX: { default: 1, field: 2 },
      layer1ScaleVariationY: { default: 1, field: 2 },
      layer1UniformScale: { default: false, field: 0 },
      layer1ColorMultiplier: { default: [1, 1, 1, 1], field: 5, color: 2 },
      layer1Reflection: { default: ReflectionMode.None, field: 1 },
      layer1Offset: { default: 0, field: 2 },
      layer1OffsetVariation: { default: 1, field: 2 },
      layer1AttenuationRadius: { default: -1, field: 2 },
      layer2Count: { default: 1, field: 1 },
      layer2ScaleVariationX: { default: 1, field: 2 },
      layer2ScaleVariationY: { default: 1, field: 2 },
      layer2UniformScale: { default: false, field: 0 },
      layer2ColorMultiplier: { default: [1, 1, 1, 1], field: 5, color: 2 },
      layer2Reflection: { default: ReflectionMode.None, field: 1 },
      layer2Offset: { default: 0, field: 2 },
      layer2OffsetVariation: { default: 1, field: 2 },
      layer2AttenuationRadius: { default: -1, field: 2 },
      layer3Count: { default: 1, field: 1 },
      layer3ScaleVariationX: { default: 1, field: 2 },
      layer3ScaleVariationY: { default: 1, field: 2 },
      layer3UniformScale: { default: false, field: 0 },
      layer3ColorMultiplier: { default: [1, 1, 1, 1], field: 5, color: 2 },
      layer3Reflection: { default: ReflectionMode.None, field: 1 },
      layer3Offset: { default: 0, field: 2 },
      layer3OffsetVariation: { default: 1, field: 2 },
      layer3AttenuationRadius: { default: -1, field: 2 },
      layer4Count: { default: 1, field: 1 },
      layer4ScaleVariationX: { default: 1, field: 2 },
      layer4ScaleVariationY: { default: 1, field: 2 },
      layer4UniformScale: { default: false, field: 0 },
      layer4ColorMultiplier: { default: [1, 1, 1, 1], field: 5, color: 2 },
      layer4Reflection: { default: ReflectionMode.None, field: 1 },
      layer4Offset: { default: 0, field: 2 },
      layer4OffsetVariation: { default: 1, field: 2 },
      layer4AttenuationRadius: { default: -1, field: 2 },
      unk_er_f1_57: { default: 1, field: 1 },
      bloom: { default: false, field: 0 },
      layer1BloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      layer2BloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      layer3BloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      layer4BloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_ac6_f1_75: { default: -1, field: 2 },
      unk_ac6_f1_76: { default: -1, field: 2 },
      unk_ac6_f1_77: { default: -1, field: 2 },
      unk_ac6_f1_78: { default: -1, field: 2 },
      unk_ac6_f1_79: { default: -1, field: 2 },
      unk_ac6_f1_80: { default: -1, field: 2 },
      unk_er_f2_0: { default: 0, field: 1 },
      unk_er_f2_1: { default: 0, field: 1 },
      unk_er_f2_2: { default: 0, field: 1 },
      unk_er_f2_3: { default: 0, field: 1 },
      unk_er_f2_4: { default: 0, field: 1 },
      unk_er_f2_5: { default: 0, field: 1 },
      unk_er_f2_6: { default: 0, field: 1 },
      unk_er_f2_7: { default: 0, field: 1 },
      unk_er_f2_8: { default: 0, field: 1 },
      unk_er_f2_9: { default: 0, field: 1 },
      unk_er_f2_10: { default: 0, field: 1 },
      unk_er_f2_11: { default: 0, field: 1 },
      unk_er_f2_12: { default: 0, field: 1 },
      unk_er_f2_13: { default: 0, field: 1 },
      unk_er_f2_14: { default: 0, field: 1 },
      unk_er_f2_15: { default: 0, field: 1 },
      unk_er_f2_16: { default: 0, field: 1 },
      unk_er_f2_17: { default: 0, field: 1 },
      unk_er_f2_18: { default: 0, field: 1 },
      unk_er_f2_19: { default: 0, field: 1 },
      unk_er_f2_20: { default: 0, field: 1 },
      unk_er_f2_21: { default: 0, field: 1 },
      unk_er_f2_22: { default: 0, field: 1 },
      unk_er_f2_23: { default: 0, field: 1 },
      unk_er_f2_24: { default: 0, field: 1 },
      unk_er_f2_25: { default: 0, field: 1 },
      unk_er_f2_26: { default: 0, field: 1 },
      unk_er_f2_27: { default: 0, field: 1 },
      unk_er_f2_28: { default: 0, field: 1 },
      unk_er_f2_29: { default: 0, field: 1 },
      unk_er_f2_30: { default: 0, field: 1 },
      unk_er_f2_31: { default: 0, field: 1 },
      unk_er_f2_32: { default: 0, field: 1 },
      unk_er_f2_33: { default: 0, field: 1 },
      unk_er_f2_34: { default: 0, field: 1 },
      unk_er_f2_35: { default: 0, field: 1 },
      unk_er_f2_36: { default: -2, field: 1 },
    },
    games: {
      [Game.Sekiro]: Game.EldenRing,
      [Game.EldenRing]: {
        fields1: ['layer1','layer2','layer3','layer4','blendMode','unk_er_f1_4','sourceSize','opacityTransitionDuration','unk_er_f1_8','layer1Count','layer1ScaleVariationX','layer1ScaleVariationY','layer1UniformScale','layer1ColorMultiplier','layer1Reflection','layer1Offset','layer1OffsetVariation','layer1AttenuationRadius','layer2Count','layer2ScaleVariationX','layer2ScaleVariationY','layer2UniformScale','layer2ColorMultiplier','layer2Reflection','layer2Offset','layer2OffsetVariation','layer2AttenuationRadius','layer3Count','layer3ScaleVariationX','layer3ScaleVariationY','layer3UniformScale','layer3ColorMultiplier','layer3Reflection','layer3Offset','layer3OffsetVariation','layer3AttenuationRadius','layer4Count','layer4ScaleVariationX','layer4ScaleVariationY','layer4UniformScale','layer4ColorMultiplier','layer4Reflection','layer4Offset','layer4OffsetVariation','layer4AttenuationRadius','unk_er_f1_57','bloom','layer1BloomColor','layer2BloomColor','layer3BloomColor','layer4BloomColor'],
        fields2: ['unk_er_f2_0','unk_er_f2_1','unk_er_f2_2','unk_er_f2_3','unk_er_f2_4','unk_er_f2_5','unk_er_f2_6','unk_er_f2_7','unk_er_f2_8','unk_er_f2_9','unk_er_f2_10','unk_er_f2_11','unk_er_f2_12','unk_er_f2_13','unk_er_f2_14','unk_er_f2_15','unk_er_f2_16','unk_er_f2_17','unk_er_f2_18','unk_er_f2_19','unk_er_f2_20','unk_er_f2_21','unk_er_f2_22','unk_er_f2_23','unk_er_f2_24','unk_er_f2_25','unk_er_f2_26','unk_er_f2_27','unk_er_f2_28','unk_er_f2_29','unk_er_f2_30','unk_er_f2_31','unk_er_f2_32','unk_er_f2_33','unk_er_f2_34','unk_er_f2_35','unk_er_f2_36'],
        properties1: ['layer1Width','layer1Height','layer1Color','layer2Width','layer2Height','layer2Color','layer3Width','layer3Height','layer3Color','layer4Width','layer4Height','layer4Color']
      },
      [Game.ArmoredCore6]: {
        fields1: ['layer1','layer2','layer3','layer4','blendMode','unk_er_f1_4','sourceSize','opacityTransitionDuration','unk_er_f1_8','layer1Count','layer1ScaleVariationX','layer1ScaleVariationY','layer1UniformScale','layer1ColorMultiplier','layer1Reflection','layer1Offset','layer1OffsetVariation','layer1AttenuationRadius','layer2Count','layer2ScaleVariationX','layer2ScaleVariationY','layer2UniformScale','layer2ColorMultiplier','layer2Reflection','layer2Offset','layer2OffsetVariation','layer2AttenuationRadius','layer3Count','layer3ScaleVariationX','layer3ScaleVariationY','layer3UniformScale','layer3ColorMultiplier','layer3Reflection','layer3Offset','layer3OffsetVariation','layer3AttenuationRadius','layer4Count','layer4ScaleVariationX','layer4ScaleVariationY','layer4UniformScale','layer4ColorMultiplier','layer4Reflection','layer4Offset','layer4OffsetVariation','layer4AttenuationRadius','unk_er_f1_57','bloom','layer1BloomColor','layer2BloomColor','layer3BloomColor','layer4BloomColor','unk_ac6_f1_75','unk_ac6_f1_76','unk_ac6_f1_77','unk_ac6_f1_78','unk_ac6_f1_79','unk_ac6_f1_80'],
        fields2: Game.EldenRing,
        properties1: Game.EldenRing
      },
      [Game.Nightreign]: Game.ArmoredCore6
    }
  },
  [ActionType.RichModel]: {
    isAppearance: true,
    isParticle: true,
    slotDefault: false,
    props: {
      model: { default: 80201, resource: 1 },
      sizeX: { default: 1, scale: 4 },
      sizeY: { default: 1, scale: 4 },
      sizeZ: { default: 1, scale: 4 },
      rotationX: { default: 0 },
      rotationY: { default: 0 },
      rotationZ: { default: 0 },
      angularSpeedX: { default: 0, time: 1 },
      angularSpeedMultiplierX: { default: 1 },
      angularSpeedY: { default: 0, time: 1 },
      angularSpeedMultiplierY: { default: 1 },
      angularSpeedZ: { default: 0, time: 1 },
      angularSpeedMultiplierZ: { default: 1 },
      color1: { default: [1, 1, 1, 1], color: 2 },
      color2: { default: [1, 1, 1, 1], color: 2 },
      color3: { default: [1, 1, 1, 1], color: 1 },
      unk_er_p1_16: { default: 0 },
      unk_er_p1_17: { default: 0 },
      rgbMultiplier2: { default: 1 },
      unk_er_p1_19: { default: 0 },
      unk_er_p1_20: { default: 0 },
      offsetUV: { default: [0, 0] },
      speedUV: { default: [0, 0], time: 1 },
      speedMultiplierUV: { default: [1, 1] },
      unk_nr_p1_24: { default: 0 },
      unk_nr_p1_25: { default: 0 },
      unk_nr_p1_26: { default: 0 },
      unk_nr_p1_27: { default: 0 },
      unk_nr_p1_28: { default: 0 },
      unk_nr_p1_29: { default: 0 },
      unk_nr_p1_30: { default: 0 },
      unk_nr_p1_31: { default: 0 },
      unk_nr_p1_32: { default: 0 },
      unk_nr_p1_33: { default: 0 },
      unk_nr_p1_34: { default: 0 },
      unk_nr_p1_35: { default: 0 },
      unk_nr_p1_36: { default: 0 },
      unk_nr_p1_37: { default: 0 },
      unk_nr_p1_38: { default: 0 },
      unk_nr_p1_39: { default: 0 },
      unk_nr_p1_40: { default: 0 },
      unk_nr_p1_41: { default: 0 },
      unk_nr_p1_42: { default: 0 },
      unk_nr_p1_43: { default: 0 },
      offsetU: { default: 0, omit: 1 },
      offsetV: { default: 0, omit: 1 },
      speedU: { default: 0, omit: 1 },
      speedMultiplierU: { default: 0, omit: 1 },
      speedV: { default: 0, omit: 1 },
      speedMultiplierV: { default: 0, omit: 1 },
      rgbMultiplier: { default: 1 },
      alphaMultiplier: { default: 1 },
      unk_er_p2_2: { default: 0 },
      unk_er_p2_3: { default: [1, 1, 1, 1] },
      unk_er_p2_4: { default: [1, 1, 1, 1] },
      unk_er_p2_5: { default: [1, 1, 1, 1] },
      unk_er_p2_6: { default: 0 },
      orientation: { default: RichModelOrientationMode.ParticleDirection, field: 1 },
      scaleVariationX: { default: 1, field: 2 },
      scaleVariationY: { default: 1, field: 2 },
      scaleVariationZ: { default: 1, field: 2 },
      uniformScale: { default: false, field: 0 },
      unk_er_f1_5: { default: 1, field: 1 },
      unk_er_f1_6: { default: 1, field: 1 },
      dither: { default: false, field: 0 },
      unk_er_f1_8: { default: -2, field: 1 },
      unk_er_f1_9: { default: -2, field: 1 },
      anibnd: { default: 0, field: 1, resource: 2 },
      animation: { default: 0, field: 1 },
      loopAnimation: { default: true, field: 0 },
      animationSpeed: { default: 1, field: 2, time: 1 },
      unk_er_f1_14: { default: 0, field: 2 },
      unk_er_f1_15: { default: 0, field: 1 },
      unk_er_f1_16: { default: 0, field: 1 },
      unk_er_f1_17: { default: 0, field: 1 },
      unk_er_f1_18: { default: 0, field: 1 },
      unk_er_f1_19: { default: 0, field: 1 },
      unk_er_f1_20: { default: 0, field: 1 },
      unk_er_f1_21: { default: 0, field: 1 },
      unk_er_f1_22: { default: 0, field: 1 },
      unkBlendMode: { default: 0, field: 1 },
      unk_ac6_f1_24: { default: 0, field: 2 },
      unk_ac6_f1_25: { default: -1, field: 2 },
      unk_ac6_f1_26: { default: -1, field: 2 },
      unk_ac6_f1_27: { default: -1, field: 2 },
      unk_ac6_f1_28: { default: -1, field: 2 },
      unk_ac6_f1_29: { default: 0, field: 1 },
      unk_ac6_f1_30: { default: 0, field: 1 },
      unk_ac6_f1_31: { default: 0, field: 2 },
      unk_ac6_f1_32: { default: 0, field: 1 },
      unk_ac6_f1_33: { default: 1, field: 1 },
      unk_ac6_f1_34: { default: 0, field: 1 },
      unk_nr_f1_35: { default: 0, field: 1 },
      unk_nr_f1_36: { default: 0, field: 1 },
      unk_nr_f1_37: { default: 0, field: 1 },
      unk_nr_f1_38: { default: 0, field: 1 },
      unk_nr_f1_39: { default: 0, field: 1 },
      unk_nr_f1_40: { default: 0, field: 1 },
      unk_nr_f1_41: { default: 0, field: 1 },
      unk_nr_f1_42: { default: 0, field: 1 },
      unk_nr_f1_43: { default: 0, field: 1 },
      unk_nr_f1_44: { default: 0, field: 1 },
      unk_nr_f1_45: { default: 0, field: 1 },
      unk_nr_f1_46: { default: 0, field: 1 },
      unk_nr_f1_47: { default: 0, field: 1 },
      unk_nr_f1_48: { default: 0, field: 1 },
      unk_nr_f1_49: { default: 0, field: 1 },
      unk_nr_f1_50: { default: 0, field: 1 },
      unk_nr_f1_51: { default: 0, field: 1 },
      unk_nr_f1_52: { default: 0, field: 1 },
      unk_nr_f1_53: { default: 0, field: 1 },
      unk_nr_f1_54: { default: 0, field: 1 },
      unk_er_f1_24: { default: 0, field: 2 },
      unk_er_f1_25: { default: 1, field: 1 },
      unk_er_f2_0: { default: 0, field: 1 },
      unk_er_f2_1: { default: 0, field: 1 },
      unk_er_f2_2: { default: 8, field: 1 },
      unk_er_f2_3: { default: 0, field: 1 },
      bloomColor: { default: [1, 1, 1, 0], field: 5, color: 2 },
      unk_er_f2_8: { default: 0, field: 1 },
      unk_er_f2_9: { default: 0, field: 1 },
      unk_er_f2_10: { default: 0, field: 1 },
      unk_er_f2_11: { default: 0, field: 1 },
      unk_er_f2_12: { default: 0, field: 1 },
      unk_er_f2_13: { default: 0, field: 1 },
      minFadeDistance: { default: -1, field: 2, scale: 3 },
      minDistance: { default: -1, field: 2, scale: 3 },
      maxFadeDistance: { default: -1, field: 2, scale: 3 },
      maxDistance: { default: -1, field: 2, scale: 3 },
      minDistanceThreshold: { default: -1, field: 2, scale: 3 },
      maxDistanceThreshold: { default: -1, field: 2, scale: 3 },
      unk_er_f2_20: { default: 0, field: 1 },
      unk_er_f2_21: { default: 0, field: 1 },
      unk_er_f2_22: { default: 0, field: 1 },
      unk_er_f2_23: { default: 0, field: 1 },
      unk_er_f2_24: { default: 0, field: 1 },
      unkDepthBlend1: { default: 1, field: 2 },
      unkDepthBlend2: { default: 0, field: 2, scale: 2 },
      unk_er_f2_27: { default: 0, field: 1 },
      unk_er_f2_28: { default: 1, field: 1 },
      unk_er_f2_29: { default: 0, field: 1 },
      unk_er_f2_30: { default: 0, field: 1 },
      unk_er_f2_31: { default: 1, field: 2 },
      unk_er_f2_32: { default: 0, field: 1 },
      unk_er_f2_33: { default: 0, field: 1 },
      unk_er_f2_34: { default: 0.5, field: 2 },
      unk_er_f2_35: { default: -2, field: 1 },
      unk_er_f2_36: { default: -2, field: 1 },
      unk_er_f2_37: { default: 0, field: 1 },
      unk_nr_s10_0: { default: [], s10: 1 },
      unk_nr_s10_1: { default: [], s10: 1 },
      unk_nr_s10_2: { default: [], s10: 1 },
      unk_nr_s10_3: { default: [], s10: 1 },
    },
    games: {
      [Game.EldenRing]: {
        fields1: ['orientation','scaleVariationX','scaleVariationY','scaleVariationZ','uniformScale','unk_er_f1_5','unk_er_f1_6','dither','unk_er_f1_8','unk_er_f1_9','anibnd','animation','loopAnimation','animationSpeed','unk_er_f1_14','unk_er_f1_15','unk_er_f1_16','unk_er_f1_17','unk_er_f1_18','unk_er_f1_19','unk_er_f1_20','unk_er_f1_21','unk_er_f1_22','unkBlendMode','unk_er_f1_24','unk_er_f1_25'],
        fields2: ['unk_er_f2_0','unk_er_f2_1','unk_er_f2_2','unk_er_f2_3','bloomColor','unk_er_f2_8','unk_er_f2_9','unk_er_f2_10','unk_er_f2_11','unk_er_f2_12','unk_er_f2_13','minFadeDistance','minDistance','maxFadeDistance','maxDistance','minDistanceThreshold','maxDistanceThreshold','unk_er_f2_20','unk_er_f2_21','unk_er_f2_22','unk_er_f2_23','unk_er_f2_24','unkDepthBlend1','unkDepthBlend2','unk_er_f2_27','unk_er_f2_28','unk_er_f2_29','unk_er_f2_30','unk_er_f2_31','unk_er_f2_32','unk_er_f2_33','unk_er_f2_34','unk_er_f2_35','unk_er_f2_36','unk_er_f2_37'],
        properties1: ['model','sizeX','sizeY','sizeZ','rotationX','rotationY','rotationZ','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ','color1','color2','color3','unk_er_p1_16','unk_er_p1_17','rgbMultiplier2','unk_er_p1_19','unk_er_p1_20','offsetU','offsetV','speedU','speedMultiplierU','speedV','speedMultiplierV'],
        properties2: ['rgbMultiplier','alphaMultiplier','unk_er_p2_2','unk_er_p2_3','unk_er_p2_4','unk_er_p2_5','unk_er_p2_6']
      },
      [Game.ArmoredCore6]: {
        fields1: ['orientation','scaleVariationX','scaleVariationY','scaleVariationZ','uniformScale','unk_er_f1_5','unk_er_f1_6','dither','unk_er_f1_8','unk_er_f1_9','anibnd','animation','loopAnimation','animationSpeed','unk_er_f1_14','unk_er_f1_15','unk_er_f1_16','unk_er_f1_17','unk_er_f1_18','unk_er_f1_19','unk_er_f1_20','unk_er_f1_21','unk_er_f1_22','unkBlendMode','unk_ac6_f1_24','unk_ac6_f1_25','unk_ac6_f1_26','unk_ac6_f1_27','unk_ac6_f1_28','unk_ac6_f1_29','unk_ac6_f1_30','unk_ac6_f1_31','unk_ac6_f1_32','unk_ac6_f1_33','unk_ac6_f1_34'],
        fields2: Game.EldenRing,
        properties1: ['model','sizeX','sizeY','sizeZ','rotationX','rotationY','rotationZ','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ','color1','color2','color3','unk_er_p1_16','unk_er_p1_17','rgbMultiplier2','unk_er_p1_19','unk_er_p1_20','offsetUV','speedUV','speedMultiplierUV'],
        properties2: Game.EldenRing
      },
      [Game.Nightreign]: {
        fields1: ['orientation','scaleVariationX','scaleVariationY','scaleVariationZ','uniformScale','unk_er_f1_5','unk_er_f1_6','dither','unk_er_f1_8','unk_er_f1_9','anibnd','animation','loopAnimation','animationSpeed','unk_er_f1_14','unk_er_f1_15','unk_er_f1_16','unk_er_f1_17','unk_er_f1_18','unk_er_f1_19','unk_er_f1_20','unk_er_f1_21','unk_er_f1_22','unkBlendMode','unk_ac6_f1_24','unk_ac6_f1_25','unk_ac6_f1_26','unk_ac6_f1_27','unk_ac6_f1_28','unk_ac6_f1_29','unk_ac6_f1_30','unk_ac6_f1_31','unk_ac6_f1_32','unk_ac6_f1_33','unk_ac6_f1_34','unk_nr_f1_35','unk_nr_f1_36','unk_nr_f1_37','unk_nr_f1_38','unk_nr_f1_39','unk_nr_f1_40','unk_nr_f1_41','unk_nr_f1_42','unk_nr_f1_43','unk_nr_f1_44','unk_nr_f1_45','unk_nr_f1_46','unk_nr_f1_47','unk_nr_f1_48','unk_nr_f1_49','unk_nr_f1_50','unk_nr_f1_51','unk_nr_f1_52','unk_nr_f1_53','unk_nr_f1_54'],
        fields2: Game.EldenRing,
        properties1: ['model','sizeX','sizeY','sizeZ','rotationX','rotationY','rotationZ','angularSpeedX','angularSpeedMultiplierX','angularSpeedY','angularSpeedMultiplierY','angularSpeedZ','angularSpeedMultiplierZ','color1','color2','color3','unk_er_p1_16','unk_er_p1_17','rgbMultiplier2','unk_er_p1_19','unk_er_p1_20','offsetUV','speedUV','speedMultiplierUV','unk_nr_p1_24','unk_nr_p1_25','unk_nr_p1_26','unk_nr_p1_27','unk_nr_p1_28','unk_nr_p1_29','unk_nr_p1_30','unk_nr_p1_31','unk_nr_p1_32','unk_nr_p1_33','unk_nr_p1_34','unk_nr_p1_35','unk_nr_p1_36','unk_nr_p1_37','unk_nr_p1_38','unk_nr_p1_39','unk_nr_p1_40','unk_nr_p1_41','unk_nr_p1_42','unk_nr_p1_43'],
        properties2: Game.EldenRing,
        section10s: ['unk_nr_s10_0','unk_nr_s10_1','unk_nr_s10_2','unk_nr_s10_3']
      }
    }
  },
  [ActionType.Unk10100]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      unk_ds3_f1_0: { default: 0, field: 1 },
      unk_ds3_f1_1: { default: 1, field: 1 },
      unk_ds3_f1_2: { default: 1, field: 1 },
      unk_ds3_f1_3: { default: 1, field: 1 },
      unk_ds3_f1_4: { default: 0, field: 1 },
      unk_ds3_f1_5: { default: 0, field: 1 },
      unk_ds3_f1_6: { default: 0, field: 1 },
      unk_ds3_f1_7: { default: 0, field: 1 },
      unk_ds3_f1_8: { default: 0, field: 1 },
      unk_ds3_f1_9: { default: 0, field: 1 },
      unk_ds3_f1_10: { default: 0, field: 1 },
      unk_ds3_f1_11: { default: 0, field: 1 },
      unk_ds3_f1_12: { default: 0, field: 1 },
      unk_ds3_f1_13: { default: 0, field: 1 },
      unk_ds3_f1_14: { default: 0, field: 1 },
      unk_ds3_f1_15: { default: 0, field: 1 },
      unk_ds3_f1_16: { default: 0, field: 1 },
      unk_ds3_f1_17: { default: 0, field: 1 },
      unk_ds3_f1_18: { default: 0, field: 1 },
      unk_ds3_f1_19: { default: 0, field: 1 },
      unk_ds3_f1_20: { default: 0, field: 1 },
      unk_ds3_f1_21: { default: 0, field: 1 },
      unk_ds3_f1_22: { default: 0, field: 1 },
      unk_ds3_f1_23: { default: -1, field: 1 },
      unk_ds3_f1_24: { default: 0, field: 1 },
      unk_ds3_f1_25: { default: 0, field: 1 },
      unk_ds3_f1_26: { default: 0, field: 1 },
      unk_ds3_f1_27: { default: 0, field: 1 },
      unk_ds3_f1_28: { default: 0, field: 1 },
      unk_ds3_f1_29: { default: 0, field: 1 },
      unk_ds3_f1_30: { default: 0, field: 1 },
      unk_ds3_f1_31: { default: 0, field: 1 },
      unk_ds3_f1_32: { default: 0, field: 1 },
      unk_ds3_f1_33: { default: 0, field: 1 },
      unk_ds3_f1_34: { default: 0, field: 1 },
      unk_ds3_f1_35: { default: 0, field: 1 },
      unk_ds3_f1_36: { default: 0, field: 1 },
      unk_ds3_f1_37: { default: 0, field: 1 },
      unk_ds3_f1_38: { default: 0, field: 1 },
      unk_ds3_f1_39: { default: 0, field: 1 },
      unk_ds3_f1_40: { default: 0, field: 1 },
      unk_ds3_f1_41: { default: 0, field: 1 },
      unk_ds3_f1_42: { default: 0, field: 1 },
      unk_ds3_f1_43: { default: 0, field: 1 },
      unk_ds3_f1_44: { default: 0, field: 1 },
      unk_ds3_f1_45: { default: 0, field: 1 },
      unk_ds3_f1_46: { default: 0, field: 1 },
      unk_ds3_f1_47: { default: 0, field: 1 },
      unk_ds3_f1_48: { default: 0, field: 1 },
      unk_ds3_f1_49: { default: 0, field: 1 },
      unk_ds3_f1_50: { default: 0, field: 1 },
      unk_ds3_f1_51: { default: 0, field: 1 },
      unk_ds3_f1_52: { default: 0, field: 1 },
      unk_ds3_f1_53: { default: 0, field: 1 },
      unk_ds3_f1_54: { default: 0, field: 1 },
      unk_ds3_f1_55: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','unk_ds3_f1_1','unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4','unk_ds3_f1_5','unk_ds3_f1_6','unk_ds3_f1_7','unk_ds3_f1_8','unk_ds3_f1_9','unk_ds3_f1_10','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15','unk_ds3_f1_16','unk_ds3_f1_17','unk_ds3_f1_18','unk_ds3_f1_19','unk_ds3_f1_20','unk_ds3_f1_21','unk_ds3_f1_22','unk_ds3_f1_23','unk_ds3_f1_24','unk_ds3_f1_25','unk_ds3_f1_26','unk_ds3_f1_27','unk_ds3_f1_28','unk_ds3_f1_29','unk_ds3_f1_30','unk_ds3_f1_31','unk_ds3_f1_32','unk_ds3_f1_33','unk_ds3_f1_34','unk_ds3_f1_35','unk_ds3_f1_36','unk_ds3_f1_37','unk_ds3_f1_38','unk_ds3_f1_39','unk_ds3_f1_40','unk_ds3_f1_41','unk_ds3_f1_42','unk_ds3_f1_43','unk_ds3_f1_44','unk_ds3_f1_45','unk_ds3_f1_46','unk_ds3_f1_47','unk_ds3_f1_48','unk_ds3_f1_49','unk_ds3_f1_50','unk_ds3_f1_51','unk_ds3_f1_52','unk_ds3_f1_53','unk_ds3_f1_54','unk_ds3_f1_55']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.CancelForce]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      shape: { default: ForceVolumeShape.Sphere, field: 1 },
      sphereRadius: { default: 10, field: 2, scale: 1 },
      boxSize: { default: [0, 0, 0], field: 4, scale: 1 },
      cylinderHeight: { default: 0, field: 2, scale: 1 },
      cylinderRadius: { default: 0, field: 2, scale: 1 },
      squarePrismHeight: { default: 0, field: 2, scale: 1 },
      squarePrismApothem: { default: 0, field: 2, scale: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['shape','sphereRadius','boxSize','cylinderHeight','cylinderRadius','squarePrismHeight','squarePrismApothem']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.WindForce]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      force: { default: 1, time: 1 },
      shape: { default: ForceVolumeShape.Sphere, field: 1 },
      sphereRadius: { default: 10, field: 2, scale: 1 },
      boxSize: { default: [0, 0, 0], field: 4, scale: 1 },
      cylinderHeight: { default: 0, field: 2, scale: 1 },
      cylinderRadius: { default: 0, field: 2, scale: 1 },
      squarePrismHeight: { default: 0, field: 2, scale: 1 },
      squarePrismApothem: { default: 0, field: 2, scale: 1 },
      unk_ds3_f1_9: { default: 0, field: 1 },
      unk_ds3_f1_10: { default: 0, field: 1 },
      unk_ds3_f1_11: { default: 0, field: 1 },
      unk_ds3_f1_12: { default: 0, field: 1 },
      unk_ds3_f1_13: { default: 0, field: 1 },
      unk_ds3_f1_14: { default: 0, field: 1 },
      unk_ds3_f1_15: { default: 0, field: 1 },
      unk_ds3_f1_16: { default: 0, field: 1 },
      unk_ds3_f1_17: { default: 0, field: 1 },
      unk_ds3_f1_18: { default: 0, field: 1 },
      unk_ds3_f1_19: { default: 0, field: 1 },
      unk_ds3_f1_20: { default: 0, field: 1 },
      unk_ds3_f1_21: { default: 0, field: 1 },
      unk_ds3_f1_22: { default: 0, field: 1 },
      unk_ds3_f1_23: { default: 0, field: 1 },
      unk_ds3_f1_24: { default: 0, field: 1 },
      unk_ds3_f1_25: { default: 1, field: 2 },
      unk_ds3_f1_26: { default: 0, field: 1 },
      unk_ds3_f1_27: { default: 0, field: 2 },
      unk_ds3_f1_28: { default: 0, field: 2 },
      unk_ds3_f1_29: { default: 30, field: 1 },
      unk_ds3_f1_30: { default: 0, field: 1 },
      unk_ds3_f1_31: { default: 0, field: 1 },
      unk_ds3_f1_32: { default: 0, field: 1 },
      unk_ds3_f1_33: { default: 0, field: 1 },
      unk_ds3_f1_34: { default: 0, field: 2 },
      unk_ds3_f1_35: { default: 0, field: 2 },
      unk_ds3_f1_36: { default: 0, field: 2 },
      unk_ds3_f1_37: { default: 0, field: 2 },
      forceRandomMultiplierMin: { default: 1, field: 2 },
      forceRandomMultiplierMax: { default: 1, field: 2 },
      unk_ds3_f1_40: { default: 1, field: 2 },
      unk_ds3_f1_41: { default: 1, field: 2 },
      unk_ds3_f1_42: { default: 1, field: 2 },
      unk_ds3_f1_44: { default: 1, field: 2 },
      unk_ds3_f1_45: { default: 1, field: 2 },
      forceMultiplier: { default: 1, field: 2 },
      unk_ds3_f1_47: { default: 1, field: 2 },
      unk_ds3_f1_48: { default: 1, field: 2 },
      unk_sdt_f1_48: { default: 1, field: 2 },
      unk_sdt_f1_49: { default: 1, field: 2 },
      unk_sdt_f1_50: { default: 1, field: 2 },
      unk_sdt_f1_51: { default: 0, field: 2 },
      unk_sdt_f1_52: { default: 0, field: 2 },
      fadeOutTime: { default: 0, field: 1, time: 2 },
      unk_sdt_f1_54: { default: 0, field: 2 },
      unk_sdt_f1_55: { default: 0, field: 2 },
      unk_sdt_f1_56: { default: 1, field: 2 },
      unk_sdt_f1_57: { default: 1, field: 2 },
      unk_sdt_f1_58: { default: 1, field: 2 },
      unk_ds3_f1_49: { default: 10, field: 2 },
      unk_ds3_f1_50: { default: 60, field: 2 },
      unk_ds3_f1_43: { default: 1, field: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['shape','sphereRadius','boxSize','cylinderHeight','cylinderRadius','squarePrismHeight','squarePrismApothem','unk_ds3_f1_9','unk_ds3_f1_10','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15','unk_ds3_f1_16','unk_ds3_f1_17','unk_ds3_f1_18','unk_ds3_f1_19','unk_ds3_f1_20','unk_ds3_f1_21','unk_ds3_f1_22','unk_ds3_f1_23','unk_ds3_f1_24','unk_ds3_f1_25','unk_ds3_f1_26','unk_ds3_f1_27','unk_ds3_f1_28','unk_ds3_f1_29','unk_ds3_f1_30','unk_ds3_f1_31','unk_ds3_f1_32','unk_ds3_f1_33','unk_ds3_f1_34','unk_ds3_f1_35','unk_ds3_f1_36','unk_ds3_f1_37','forceRandomMultiplierMin','forceRandomMultiplierMax','unk_ds3_f1_40','unk_ds3_f1_41','unk_ds3_f1_42','unk_ds3_f1_43','unk_ds3_f1_44','unk_ds3_f1_45','forceMultiplier','unk_ds3_f1_47','unk_ds3_f1_48','unk_ds3_f1_49','unk_ds3_f1_50','fadeOutTime'],
        properties1: ['force']
      },
      [Game.Sekiro]: {
        fields1: ['shape','sphereRadius','boxSize','cylinderHeight','cylinderRadius','squarePrismHeight','squarePrismApothem','unk_ds3_f1_9','unk_ds3_f1_10','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15','unk_ds3_f1_16','unk_ds3_f1_17','unk_ds3_f1_18','unk_ds3_f1_19','unk_ds3_f1_20','unk_ds3_f1_21','unk_ds3_f1_22','unk_ds3_f1_23','unk_ds3_f1_24','unk_ds3_f1_25','unk_ds3_f1_26','unk_ds3_f1_27','unk_ds3_f1_28','unk_ds3_f1_29','unk_ds3_f1_30','unk_ds3_f1_31','unk_ds3_f1_32','unk_ds3_f1_33','unk_ds3_f1_34','unk_ds3_f1_35','unk_ds3_f1_36','unk_ds3_f1_37','forceRandomMultiplierMin','forceRandomMultiplierMax','unk_ds3_f1_40','unk_ds3_f1_41','unk_ds3_f1_42','unk_ds3_f1_44','unk_ds3_f1_45','forceMultiplier','unk_ds3_f1_47','unk_ds3_f1_48','unk_sdt_f1_48','unk_sdt_f1_49','unk_sdt_f1_50','unk_sdt_f1_51','unk_sdt_f1_52','fadeOutTime','unk_sdt_f1_54','unk_sdt_f1_55','unk_sdt_f1_56','unk_sdt_f1_57','unk_sdt_f1_58','unk_ds3_f1_49','unk_ds3_f1_50'],
        properties1: Game.DarkSouls3
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: Game.Sekiro,
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.GravityForce]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      force: { default: 1, time: 1 },
      shape: { default: ForceVolumeShape.Sphere, field: 1 },
      sphereRadius: { default: 10, field: 2, scale: 1 },
      boxSize: { default: [0, 0, 0], field: 4, scale: 1 },
      cylinderHeight: { default: 0, field: 2, scale: 1 },
      cylinderRadius: { default: 0, field: 2, scale: 1 },
      squarePrismHeight: { default: 0, field: 2, scale: 1 },
      squarePrismApothem: { default: 0, field: 2, scale: 1 },
      unk_ds3_f1_9: { default: 0, field: 1 },
      unk_ds3_f1_10: { default: 0, field: 1 },
      unk_ds3_f1_11: { default: 0, field: 1 },
      unk_ds3_f1_12: { default: 0, field: 1 },
      unk_ds3_f1_13: { default: 0, field: 1 },
      unk_ds3_f1_14: { default: 0, field: 1 },
      unk_ds3_f1_15: { default: 0, field: 1 },
      unk_ds3_f1_16: { default: 0, field: 1 },
      unk_ds3_f1_17: { default: 0, field: 1 },
      unk_ds3_f1_18: { default: 0, field: 1 },
      unk_ds3_f1_19: { default: 0, field: 1 },
      unk_ds3_f1_20: { default: 0, field: 1 },
      unk_ds3_f1_21: { default: 0, field: 1 },
      unk_ds3_f1_22: { default: 0, field: 1 },
      unk_ds3_f1_23: { default: 0, field: 1 },
      unk_ds3_f1_24: { default: 0, field: 1 },
      unk_ds3_f1_25: { default: 0, field: 1 },
      unk_ds3_f1_26: { default: 0, field: 1 },
      unk_ds3_f1_27: { default: 0, field: 1 },
      forceRandomMultiplierMin: { default: 1, field: 2 },
      forceRandomMultiplierMax: { default: 1, field: 2 },
      unk_ds3_f1_30: { default: 1, field: 2 },
      unk_ds3_f1_31: { default: 0, field: 1 },
      unk_ds3_f1_32: { default: 0, field: 1 },
      unk_ds3_f1_33: { default: 1, field: 2 },
      unk_ds3_f1_34: { default: 3, field: 1 },
      forceMultiplier: { default: 1, field: 2 },
      unk_ds3_f1_36: { default: 1, field: 2 },
      unk_ds3_f1_37: { default: 1, field: 2 },
      fadeOutTime: { default: 0, field: 1, time: 2 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['shape','sphereRadius','boxSize','cylinderHeight','cylinderRadius','squarePrismHeight','squarePrismApothem','unk_ds3_f1_9','unk_ds3_f1_10','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15','unk_ds3_f1_16','unk_ds3_f1_17','unk_ds3_f1_18','unk_ds3_f1_19','unk_ds3_f1_20','unk_ds3_f1_21','unk_ds3_f1_22','unk_ds3_f1_23','unk_ds3_f1_24','unk_ds3_f1_25','unk_ds3_f1_26','unk_ds3_f1_27','forceRandomMultiplierMin','forceRandomMultiplierMax','unk_ds3_f1_30','unk_ds3_f1_31','unk_ds3_f1_32','unk_ds3_f1_33','unk_ds3_f1_34','forceMultiplier','unk_ds3_f1_36','unk_ds3_f1_37','fadeOutTime'],
        properties1: ['force']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.ForceCollision]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      shape: { default: ForceVolumeShape.Sphere, field: 1 },
      sphereRadius: { default: 10, field: 2, scale: 1 },
      boxSize: { default: [0, 0, 0], field: 4, scale: 1 },
      cylinderHeight: { default: 0, field: 2, scale: 1 },
      cylinderRadius: { default: 0, field: 2, scale: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['shape','sphereRadius','boxSize','cylinderHeight','cylinderRadius']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.TurbulenceForce]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      noiseOffsetX: { default: 0, scale: 1 },
      noiseOffsetY: { default: 0, scale: 1 },
      noiseOffsetZ: { default: 0, scale: 1 },
      force: { default: 1, time: 1 },
      shape: { default: ForceVolumeShape.Sphere, field: 1 },
      sphereRadius: { default: 10, field: 2, scale: 1 },
      boxSize: { default: [0, 0, 0], field: 4, scale: 1 },
      cylinderHeight: { default: 0, field: 2, scale: 1 },
      cylinderRadius: { default: 0, field: 2, scale: 1 },
      squarePrismHeight: { default: 0, field: 2, scale: 1 },
      squarePrismApothem: { default: 0, field: 2, scale: 1 },
      unk_unk_f1_9: { default: 0, field: 1 },
      unk_unk_f1_10: { default: 0, field: 1 },
      unk_unk_f1_11: { default: 0, field: 1 },
      unk_unk_f1_12: { default: 0, field: 1 },
      unk_unk_f1_13: { default: 0, field: 1 },
      unk_unk_f1_14: { default: 0, field: 1 },
      unk_unk_f1_15: { default: 0, field: 1 },
      unk_unk_f1_16: { default: 0, field: 1 },
      unk_unk_f1_17: { default: 0, field: 1 },
      unk_unk_f1_18: { default: 0, field: 1 },
      unk_unk_f1_19: { default: 0, field: 1 },
      unk_unk_f1_20: { default: 0, field: 1 },
      unk_unk_f1_21: { default: 0, field: 1 },
      unk_unk_f1_22: { default: 0, field: 1 },
      unk_unk_f1_23: { default: 0, field: 1 },
      forceRandomMultiplierMin: { default: 1, field: 2 },
      forceRandomMultiplierMax: { default: 1, field: 2 },
      noiseScale: { default: 1, field: 2, scale: 1 },
      unk_unk_f1_27: { default: 0, field: 1 },
      unk_unk_f1_28: { default: 0, field: 1 },
      enableSoftRadius: { default: false, field: 0 },
      softRadius: { default: 1, field: 2, scale: 1 },
      unk_unk_f1_31: { default: 0, field: 1 },
      unk_unk_f1_32: { default: 0, field: 1 },
      unk_unk_f1_33: { default: 0, field: 1 },
      unk_unk_f1_34: { default: 0, field: 1 },
      unk_unk_f1_35: { default: 0, field: 1 },
      unk_unk_f1_36: { default: 0, field: 1 },
      unk_unk_f1_37: { default: 0, field: 1 },
      unk_unk_f1_38: { default: 0, field: 1 },
      unk_unk_f1_39: { default: 0, field: 1 },
      fadeOutTime: { default: 0, field: 1, time: 2 },
      unk_unk_f1_41: { default: 0, field: 1 },
      unk_unk_f1_42: { default: 0, field: 1 },
      unk_unk_f1_43: { default: 0, field: 1 },
      unk_unk_f1_44: { default: 0, field: 1 },
      unk_unk_f1_45: { default: 0, field: 1 },
      unk_unk_f1_46: { default: 0, field: 1 },
      unk_unk_f1_47: { default: 0, field: 1 },
      unk_unk_f1_48: { default: 0, field: 1 },
      unk_unk_f1_49: { default: 0, field: 1 },
      unk_unk_f1_50: { default: 0, field: 1 },
      unk_unk_f1_51: { default: 0, field: 1 },
    },
    games: {
      [Game.Sekiro]: {
        fields1: ['shape','sphereRadius','boxSize','cylinderHeight','cylinderRadius','squarePrismHeight','squarePrismApothem','unk_unk_f1_9','unk_unk_f1_10','unk_unk_f1_11','unk_unk_f1_12','unk_unk_f1_13','unk_unk_f1_14','unk_unk_f1_15','unk_unk_f1_16','unk_unk_f1_17','unk_unk_f1_18','unk_unk_f1_19','unk_unk_f1_20','unk_unk_f1_21','unk_unk_f1_22','unk_unk_f1_23','forceRandomMultiplierMin','forceRandomMultiplierMax','noiseScale','unk_unk_f1_27','unk_unk_f1_28','enableSoftRadius','softRadius','unk_unk_f1_31','unk_unk_f1_32','unk_unk_f1_33','unk_unk_f1_34','unk_unk_f1_35','unk_unk_f1_36','unk_unk_f1_37','unk_unk_f1_38','unk_unk_f1_39','fadeOutTime','unk_unk_f1_41','unk_unk_f1_42','unk_unk_f1_43','unk_unk_f1_44','unk_unk_f1_45','unk_unk_f1_46','unk_unk_f1_47','unk_unk_f1_48','unk_unk_f1_49','unk_unk_f1_50','unk_unk_f1_51'],
        properties1: ['noiseOffsetX','noiseOffsetY','noiseOffsetZ','force']
      },
      [Game.EldenRing]: Game.Sekiro,
      [Game.ArmoredCore6]: Game.Sekiro,
      [Game.Nightreign]: Game.Sekiro
    }
  },
  [ActionType.Unk10400]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      unk_ds3_f1_0: { default: 1, field: 1 },
      unk_ds3_f1_1: { default: 1, field: 1 },
      unk_ds3_f1_2: { default: 1, field: 1 },
      unk_ds3_f1_3: { default: 1, field: 1 },
      unk_ds3_f1_4: { default: 1, field: 1 },
      unk_ds3_f1_5: { default: 1, field: 1 },
      unk_ds3_f1_6: { default: 1, field: 1 },
      unk_ds3_f1_7: { default: 1, field: 1 },
      unk_ds3_f1_8: { default: 1, field: 1 },
      unk_ds3_f1_9: { default: 1, field: 1 },
      unk_ds3_f1_10: { default: 1, field: 1 },
      unk_ds3_f1_11: { default: 1, field: 1 },
      unk_ds3_f1_12: { default: 1, field: 1 },
      unk_ds3_f1_13: { default: 1, field: 1 },
      unk_ds3_f1_14: { default: 1, field: 1 },
      unk_ds3_f1_15: { default: 1, field: 1 },
      unk_ds3_f1_16: { default: 1, field: 1 },
      unk_ds3_f1_17: { default: 1, field: 1 },
      unk_ds3_f1_18: { default: 1, field: 1 },
      unk_ds3_f1_19: { default: 1, field: 1 },
      unk_ds3_f1_20: { default: 1, field: 1 },
      unk_ds3_f1_21: { default: 1, field: 1 },
      unk_ds3_f1_22: { default: 1, field: 1 },
      unk_ds3_f1_23: { default: 1, field: 1 },
      unk_ds3_f1_24: { default: 1, field: 1 },
      unk_ds3_f1_25: { default: 1, field: 1 },
      unk_ds3_f1_26: { default: 1, field: 1 },
      unk_ds3_f1_27: { default: 1, field: 1 },
      unk_ds3_f1_28: { default: 1, field: 1 },
      unk_ds3_f1_29: { default: 1, field: 1 },
      unk_ds3_f1_30: { default: 1, field: 1 },
      unk_ds3_f1_31: { default: 1, field: 1 },
      unk_ds3_f1_32: { default: 1, field: 1 },
      unk_ds3_f1_33: { default: 1, field: 1 },
      unk_ds3_f1_34: { default: 1, field: 1 },
      unk_ds3_f1_35: { default: 1, field: 1 },
      unk_ds3_f1_36: { default: 1, field: 1 },
      unk_ds3_f1_37: { default: 1, field: 1 },
      unk_ds3_f1_38: { default: 1, field: 1 },
      unk_ds3_f1_39: { default: 1, field: 1 },
      unk_ds3_f1_40: { default: 1, field: 1 },
      unk_ds3_f1_41: { default: 1, field: 1 },
      unk_ds3_f1_42: { default: 1, field: 1 },
      unk_ds3_f1_43: { default: 1, field: 1 },
      unk_ds3_f1_44: { default: 1, field: 1 },
      unk_ds3_f1_45: { default: 1, field: 1 },
      unk_ds3_f1_46: { default: 1, field: 1 },
      unk_ds3_f1_47: { default: 1, field: 1 },
      unk_ds3_f1_48: { default: 1, field: 1 },
      unk_ds3_f1_49: { default: 1, field: 1 },
      unk_ds3_f1_50: { default: 1, field: 1 },
      unk_ds3_f1_51: { default: 1, field: 1 },
      unk_ds3_f1_52: { default: 1, field: 1 },
      unk_ds3_f1_53: { default: 1, field: 1 },
      unk_ds3_f1_54: { default: 1, field: 1 },
      unk_ds3_f1_55: { default: 1, field: 1 },
      unk_ds3_f1_56: { default: 1, field: 1 },
      unk_ds3_f1_57: { default: 1, field: 1 },
      unk_ds3_f1_58: { default: 1, field: 1 },
      unk_ds3_f1_59: { default: 1, field: 1 },
      unk_ds3_f1_60: { default: 1, field: 1 },
      unk_ds3_f1_61: { default: 1, field: 1 },
      unk_ds3_f1_62: { default: 1, field: 1 },
      unk_ds3_f1_63: { default: 1, field: 1 },
      unk_ds3_f1_64: { default: 1, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','unk_ds3_f1_1','unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4','unk_ds3_f1_5','unk_ds3_f1_6','unk_ds3_f1_7','unk_ds3_f1_8','unk_ds3_f1_9','unk_ds3_f1_10','unk_ds3_f1_11','unk_ds3_f1_12','unk_ds3_f1_13','unk_ds3_f1_14','unk_ds3_f1_15','unk_ds3_f1_16','unk_ds3_f1_17','unk_ds3_f1_18','unk_ds3_f1_19','unk_ds3_f1_20','unk_ds3_f1_21','unk_ds3_f1_22','unk_ds3_f1_23','unk_ds3_f1_24','unk_ds3_f1_25','unk_ds3_f1_26','unk_ds3_f1_27','unk_ds3_f1_28','unk_ds3_f1_29','unk_ds3_f1_30','unk_ds3_f1_31','unk_ds3_f1_32','unk_ds3_f1_33','unk_ds3_f1_34','unk_ds3_f1_35','unk_ds3_f1_36','unk_ds3_f1_37','unk_ds3_f1_38','unk_ds3_f1_39','unk_ds3_f1_40','unk_ds3_f1_41','unk_ds3_f1_42','unk_ds3_f1_43','unk_ds3_f1_44','unk_ds3_f1_45','unk_ds3_f1_46','unk_ds3_f1_47','unk_ds3_f1_48','unk_ds3_f1_49','unk_ds3_f1_50','unk_ds3_f1_51','unk_ds3_f1_52','unk_ds3_f1_53','unk_ds3_f1_54','unk_ds3_f1_55','unk_ds3_f1_56','unk_ds3_f1_57','unk_ds3_f1_58','unk_ds3_f1_59','unk_ds3_f1_60','unk_ds3_f1_61','unk_ds3_f1_62','unk_ds3_f1_63','unk_ds3_f1_64']
      },
      [Game.Sekiro]: Game.DarkSouls3,
      [Game.EldenRing]: Game.DarkSouls3,
      [Game.ArmoredCore6]: Game.DarkSouls3,
      [Game.Nightreign]: Game.DarkSouls3
    }
  },
  [ActionType.Unk10500]: {
    isAppearance: false,
    isParticle: false,
    slotDefault: true,
    props: {
      rateOfTime: { default: 1, field: 2 },
      limitViewDistance: { default: false, field: 0 },
      maxViewDistance: { default: 0, field: 2, scale: 2 },
      unk_ds3_f1_2: { default: 0, field: 2 },
      unk_ds3_f1_3: { default: 0, field: 2 },
      unk_ds3_f1_4: { default: 0, field: 2 },
      unk_ds3_f1_5: { default: 0, field: 2 },
      unk_ds3_f1_6: { default: 0, field: 1 },
      initialSimulationTime: { default: 0, field: {[Game.DarkSouls3]: 1, [Game.Sekiro]: 1, [Game.EldenRing]: 1, [Game.ArmoredCore6]: 2, [Game.Nightreign]: 1}, time: 2 },
      unk_ds3_f1_8: { default: 0, field: 1 },
      unk_sdt_f1_9: { default: 0, field: 1 },
      unk_nr_f1_10: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['limitViewDistance','maxViewDistance','unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4','unk_ds3_f1_5','unk_ds3_f1_6','initialSimulationTime','unk_ds3_f1_8']
      },
      [Game.Sekiro]: {
        fields1: ['limitViewDistance','maxViewDistance','unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4','unk_ds3_f1_5','unk_ds3_f1_6','initialSimulationTime','unk_ds3_f1_8','unk_sdt_f1_9','rateOfTime']
      },
      [Game.EldenRing]: {
        fields1: ['limitViewDistance','maxViewDistance','unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4','unk_ds3_f1_5','unk_ds3_f1_6','initialSimulationTime','unk_ds3_f1_8','unk_sdt_f1_9'],
        properties1: ['rateOfTime']
      },
      [Game.ArmoredCore6]: {
        fields1: ['limitViewDistance','maxViewDistance','unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4','unk_ds3_f1_5','unk_ds3_f1_6','initialSimulationTime','unk_ds3_f1_8','unk_sdt_f1_9'],
        properties1: Game.EldenRing
      },
      [Game.Nightreign]: {
        fields1: ['limitViewDistance','maxViewDistance','unk_ds3_f1_2','unk_ds3_f1_3','unk_ds3_f1_4','unk_ds3_f1_5','unk_ds3_f1_6','initialSimulationTime','unk_ds3_f1_8','unk_sdt_f1_9','unk_nr_f1_10'],
        properties1: Game.EldenRing
      }
    }
  },
  [ActionType.SpotLight]: {
    isAppearance: true,
    isParticle: false,
    slotDefault: false,
    props: {
      diffuseColor: { default: [1, 1, 1, 1], color: 1 },
      specularColor: { default: [1, 1, 1, 1], color: 1 },
      diffuseMultiplier: { default: 1 },
      specularMultiplier: { default: 1 },
      near: { default: 0.01, scale: 4 },
      far: { default: 50, scale: 4 },
      radiusX: { default: 50, scale: 4 },
      radiusY: { default: 50, scale: 4 },
      unk_ds3_p1_6: { default: 1 },
      unk_ds3_p1_7: { default: 1 },
      unk_sdt_p1_10: { default: 1 },
      unk_sdt_f1_0: { default: 0, field: 1 },
      jitterAndFlicker: { default: false, field: 0 },
      jitterAcceleration: { default: 1, field: 2, scale: 1, time: 4 },
      unk_sdt_f1_3: { default: 0, field: 2 },
      jitterX: { default: 0, field: 2, scale: 1 },
      jitterY: { default: 0, field: 2, scale: 1 },
      jitterZ: { default: 0, field: 2, scale: 1 },
      flickerIntervalMin: { default: 0, field: 2, time: 2 },
      flickerIntervalMax: { default: 1, field: 2, time: 2 },
      flickerBrightness: { default: 0.5, field: 2 },
      shadows: { default: false, field: 0 },
      separateSpecular: { default: false, field: 0 },
      shadowDarkness: { default: 1, field: 2 },
      unk_ds3_f1_3: { default: 2, field: 1 },
      unk_ds3_f1_4: { default: 1, field: 1 },
      fadeOutTime: { default: 0, field: 1, time: 2 },
      unk_sdt_f1_16: { default: 100, field: 1 },
      unk_sdt_f1_17: { default: 0, field: 1 },
      unk_sdt_f1_18: { default: 0, field: 2 },
      volumeDensity: { default: 0, field: 2 },
      unk_sdt_f1_20: { default: 0, field: 2 },
      phaseFunction: { default: true, field: 0 },
      asymmetryParam: { default: 0.75, field: 2 },
      adaptationExponent: { default: 0, field: 2 },
      unk_er_f1_24: { default: 1, field: 1 },
      unk_er_f1_25: { default: 1, field: 2 },
      unk_er_f1_26: { default: 1, field: 1 },
      unk_er_f1_27: { default: 0, field: 1 },
      unk_nr_f1_28: { default: 0, field: 1 },
      unk_ds3_f1_0: { default: 1, field: 1 },
      unk_ds3_f1_5: { default: 1, field: 2 },
      unk_ds3_f1_7: { default: 0, field: 1 },
      unk_ds3_f1_8: { default: 0, field: 1 },
    },
    games: {
      [Game.DarkSouls3]: {
        fields1: ['unk_ds3_f1_0','shadows','shadowDarkness','unk_ds3_f1_3','unk_ds3_f1_4','unk_ds3_f1_5','fadeOutTime','unk_ds3_f1_7','unk_ds3_f1_8'],
        properties1: ['diffuseColor','specularColor','near','far','radiusX','radiusY','unk_ds3_p1_6','unk_ds3_p1_7']
      },
      [Game.Sekiro]: {
        fields1: ['unk_sdt_f1_0','jitterAndFlicker','jitterAcceleration','unk_sdt_f1_3','jitterX','jitterY','jitterZ','flickerIntervalMin','flickerIntervalMax','flickerBrightness','shadows','separateSpecular','shadowDarkness','unk_ds3_f1_3','unk_ds3_f1_4','fadeOutTime','unk_sdt_f1_16','unk_sdt_f1_17','unk_sdt_f1_18','volumeDensity','unk_sdt_f1_20','phaseFunction','asymmetryParam','adaptationExponent'],
        properties1: ['diffuseColor','specularColor','diffuseMultiplier','specularMultiplier','near','far','radiusX','radiusY','unk_ds3_p1_6','unk_ds3_p1_7','unk_sdt_p1_10']
      },
      [Game.EldenRing]: {
        fields1: ['unk_sdt_f1_0','jitterAndFlicker','jitterAcceleration','unk_sdt_f1_3','jitterX','jitterY','jitterZ','flickerIntervalMin','flickerIntervalMax','flickerBrightness','shadows','separateSpecular','shadowDarkness','unk_ds3_f1_3','unk_ds3_f1_4','fadeOutTime','unk_sdt_f1_16','unk_sdt_f1_17','unk_sdt_f1_18','volumeDensity','unk_sdt_f1_20','phaseFunction','asymmetryParam','adaptationExponent','unk_er_f1_24','unk_er_f1_25','unk_er_f1_26','unk_er_f1_27'],
        properties1: Game.Sekiro
      },
      [Game.ArmoredCore6]: Game.EldenRing,
      [Game.Nightreign]: {
        fields1: ['unk_sdt_f1_0','jitterAndFlicker','jitterAcceleration','unk_sdt_f1_3','jitterX','jitterY','jitterZ','flickerIntervalMin','flickerIntervalMax','flickerBrightness','shadows','separateSpecular','shadowDarkness','unk_ds3_f1_3','unk_ds3_f1_4','fadeOutTime','unk_sdt_f1_16','unk_sdt_f1_17','unk_sdt_f1_18','volumeDensity','unk_sdt_f1_20','phaseFunction','asymmetryParam','adaptationExponent','unk_er_f1_24','unk_er_f1_25','unk_er_f1_26','unk_er_f1_27','unk_nr_f1_28'],
        properties1: Game.Sekiro
      }
    }
  }
  /*#ActionData end*/
}
const fieldCompCount = [
  1, // Boolean
  1, // Integer
  1, // Float
  2, // Vector2
  3, // Vector3
  4, // Vector4
]
for (const [type, action] of Object.entries(ActionData)) {
  if (!('props' in action)) continue;
  for (const game of Object.keys(action.games)) {
    const gameData = getActionGameData(type as unknown as ActionType, game as unknown as Game)
    for (const [name, prop] of Object.entries(action.props)) {
      prop.paths ??= {}
      for (const [k, list] of Object.entries(gameData)) {
        const i = list.indexOf(name)
        if (i >= 0) {
          prop.paths[game] = [k, i]
          break
        }
      }
    }
    const rawGameData = action.games[game]
    if (typeof rawGameData === 'object' && 'fields1' in rawGameData && Array.isArray(rawGameData.fields1)) {
      rawGameData.fields1.fieldsCount = 0
      for (const name of gameData.fields1) {
        rawGameData.fields1.fieldsCount += fieldCompCount[
          typeof action.props[name].field === 'number' ? action.props[name].field : action.props[name].field[game]
        ]
      }
    }
    if (typeof rawGameData === 'object' && 'fields2' in rawGameData && Array.isArray(rawGameData.fields2)) {
      rawGameData.fields2.fieldsCount = 0
      for (const name of gameData.fields2) {
        rawGameData.fields2.fieldsCount += fieldCompCount[
          typeof action.props[name].field === 'number' ? action.props[name].field : action.props[name].field[game]
        ]
      }
    }
  }
}

const ConfigActionSlots = {
  [ConfigType.Basic]: [
    [
      ActionType.NodeAttributes
    ],
    [
      ActionType.StaticNodeTransform,
      ActionType.RandomNodeTransform
    ],
    [
      ActionType.NodeAcceleration,
      ActionType.NodeTranslation,
      ActionType.NodeSpin,
      ActionType.NodeAttachToCamera,
      ActionType.NodeAccelerationRandomTurns,
      ActionType.NodeAccelerationPartialFollow,
      ActionType.NodeAccelerationSpin,
      ActionType.NodeSpeed,
      ActionType.NodeSpeedRandomTurns,
      ActionType.NodeSpeedPartialFollow,
      ActionType.NodeSpeedSpin
    ],
    [
      ActionType.NodeSound
    ],
    [
      ActionType.PeriodicEmitter,
      ActionType.EqualDistanceEmitter,
      ActionType.OneTimeEmitter
    ],
    [
      ActionType.PointEmitterShape,
      ActionType.DiskEmitterShape,
      ActionType.RectangleEmitterShape,
      ActionType.SphereEmitterShape,
      ActionType.BoxEmitterShape,
      ActionType.CylinderEmitterShape
    ],
    [
      ActionType.NoSpread,
      ActionType.CircularSpread,
      ActionType.EllipticalSpread,
      ActionType.RectangularSpread
    ],
    [
      ActionType.ParticleModifier
    ],
    [
      ActionType.ParticleAttributes
    ],
    [
      ActionType.PointSprite,
      ActionType.Line,
      ActionType.QuadLine,
      ActionType.BillboardEx,
      ActionType.MultiTextureBillboardEx,
      ActionType.Model,
      ActionType.LegacyTracer,
      ActionType.Distortion,
      ActionType.RadialBlur,
      ActionType.PointLight,
      ActionType.GPUStandardParticle,
      ActionType.GPUStandardCorrectParticle,
      ActionType.Unk10002_Fluid,
      ActionType.LightShaft,
      ActionType.GPUSparkParticle,
      ActionType.GPUSparkCorrectParticle,
      ActionType.Unk10010_Tracer,
      ActionType.Tracer,
      ActionType.WaterInteraction,
      ActionType.LensFlare,
      ActionType.RichModel,
      ActionType.CancelForce,
      ActionType.WindForce,
      ActionType.GravityForce,
      ActionType.ForceCollision,
      ActionType.TurbulenceForce,
      ActionType.SpotLight
    ],
    [
      ActionType.ParticleAcceleration,
      ActionType.ParticleSpeed,
      ActionType.ParticleSpeedRandomTurns,
      ActionType.ParticleSpeedPartialFollow,
      ActionType.ParticleAccelerationRandomTurns,
      ActionType.ParticleAccelerationPartialFollow
    ],
    [
      ActionType.EmissionSound
    ],
    [
      ActionType.Unk130
    ],
    [
      ActionType.NodeForceSpeed,
      ActionType.NodeForceAcceleration
    ],
    [
      ActionType.ParticleForceSpeed,
      ActionType.ParticleForceAcceleration,
      ActionType.ParticleForceCollision
    ]
  ],
  [ConfigType.NodeEmitter]: [
    [
      ActionType.NodeAttributes
    ],
    [
      ActionType.StaticNodeTransform,
      ActionType.RandomNodeTransform
    ],
    [
      ActionType.NodeAcceleration,
      ActionType.NodeTranslation,
      ActionType.NodeSpin,
      ActionType.NodeAttachToCamera,
      ActionType.NodeAccelerationRandomTurns,
      ActionType.NodeAccelerationPartialFollow,
      ActionType.NodeAccelerationSpin,
      ActionType.NodeSpeed,
      ActionType.NodeSpeedRandomTurns,
      ActionType.NodeSpeedSpin
    ],
    [
      ActionType.NodeSound
    ],
    [
      ActionType.PeriodicEmitter,
      ActionType.EqualDistanceEmitter,
      ActionType.OneTimeEmitter
    ],
    [
      ActionType.PointEmitterShape,
      ActionType.DiskEmitterShape,
      ActionType.RectangleEmitterShape,
      ActionType.SphereEmitterShape,
      ActionType.BoxEmitterShape,
      ActionType.CylinderEmitterShape
    ],
    [
      ActionType.NoSpread,
      ActionType.CircularSpread,
      ActionType.EllipticalSpread,
      ActionType.RectangularSpread
    ],
    [
      ActionType.SelectAllNodes,
      ActionType.SelectRandomNode
    ],
    [
      ActionType.EmissionSound
    ],
    [
      ActionType.NodeForceSpeed,
      ActionType.NodeForceAcceleration
    ]
  ]
}

function getActionGameData(type: ActionType, game: Game): FilledActionGameDataEntry {
  const adt = ActionData[type]
  if (!('props' in adt)) {
    return {
      fields1: Object.assign([], { fieldsCount: 0 }),
      fields2: Object.assign([], { fieldsCount: 0 }),
      properties1: [],
      properties2: [],
      section10s: [],
    }
  }
  if (!(game in adt.games)) {
    throw new Error(`${ActionType[type]} does not have game data for ${Game[game]}! This either means that the game does not support this type of action, or that the library is missing data for this action in that game for some other reason.`)
  }
  const data = {...((typeof adt.games[game] === 'number' ? adt.games[adt.games[game] as number] : adt.games[game]) as ActionGameDataEntry)}
  data.fields1 ??= Object.assign([], { fieldsCount: 0 })
  data.fields2 ??= Object.assign([], { fieldsCount: 0 })
  data.properties1 ??= []
  data.properties2 ??= []
  data.section10s ??= []
  if (typeof data.fields1 === 'number') {
    data.fields1 = (adt.games[data.fields1] as ActionGameDataEntry).fields1
  }
  if (typeof data.fields2 === 'number') {
    data.fields2 = (adt.games[data.fields2] as ActionGameDataEntry).fields2
  }
  if (typeof data.properties1 === 'number') {
    data.properties1 = (adt.games[data.properties1] as ActionGameDataEntry).properties1
  }
  if (typeof data.properties2 === 'number') {
    data.properties2 = (adt.games[data.properties2] as ActionGameDataEntry).properties2
  }
  if (typeof data.section10s === 'number') {
    data.section10s = (adt.games[data.section10s] as ActionGameDataEntry).section10s
  }
  return data as FilledActionGameDataEntry
}

//#region Functions - Property
function readProperty<T extends IProperty<any, any> | IModifiableProperty<any, any>>(
  br: BinaryReader,
  modifierProp: T extends IModifiableProperty<any, any> ? false : true
): T {
  const typeEnumA = br.readInt16()
  br.assertUint8(0)
  br.assertUint8(1)
  const type: ValueType =         typeEnumA & 0b00000000_00000011
  const func: PropertyFunction = (typeEnumA & 0b00000000_11110000) >>> 4
  const loop: boolean =       !!((typeEnumA & 0b00010000_00000000) >>> 12)
  br.position += 4 // TypeEnumB
  const fieldCount = br.readInt32()
  br.assertInt32(0)
  const fieldOffset = br.readOffset()
  const modifiers: IModifier<any>[] = []
  if (!modifierProp) {
    const modOffset = br.readOffset()
    const modCount = br.readInt32()
    br.assertInt32(0)
    br.stepIn(modOffset)
    for (let i = 0; i < modCount; ++i) {
      modifiers.push(readModifier(br))
    }
    br.stepOut()
  }
  const fields = readFieldsAt(br, fieldOffset, fieldCount, [func, type]).map(f => f.value)
  switch (func) {
    case PropertyFunction.Zero:
    case PropertyFunction.One:
    case PropertyFunction.Constant:
      return ValueProperty.fromFields(type, func, modifiers, fields) as unknown as T
    case PropertyFunction.Stepped:
    case PropertyFunction.Linear:
    case PropertyFunction.Bezier:
    case PropertyFunction.Hermite:
      return SequenceProperty.fromFields(type, func, loop, modifiers, fields) as unknown as T
    case PropertyFunction.ComponentHermite:
      if (br.game === Game.Heuristic) {
        br.game = Game.ArmoredCore6
      }
      return ComponentSequenceProperty.fromFields(type, loop, modifiers, fields) as unknown as T
    default:
      throw new Error('Unknown property function: ' + func)
  }
}

function writeProperty(
  prop: IProperty<any, any>,
  bw: BinaryWriter,
  game: Game,
  properties: IProperty<any, any>[],
  isModifierProp: boolean
) {
  if (game !== Game.ArmoredCore6 && prop instanceof ComponentSequenceProperty) {
    prop = prop.combineComponents()
  }
  const count = properties.length
  let func: PropertyFunction = prop instanceof ValueProperty ?
    prop.isZero ? PropertyFunction.Zero :
    prop.isOne ? PropertyFunction.One :
    PropertyFunction.Constant :
    prop.function
  const loop = 'loop' in prop ? prop.loop as boolean : false
  const typeEnumA = prop.valueType | func << 4 | +loop << 12
  const typeEnumB = prop.valueType | func << 2 | +loop << 4
  bw.writeInt16(typeEnumA)
  bw.writeUint8(0)
  bw.writeUint8(1)
  if (game === Game.DarkSouls3 || game === Game.Sekiro || game === Game.EldenRing) {
    bw.writeInt32(typeEnumB)
  } else {
    bw.writeInt32(0)
  }
  bw.writeInt32(prop.fieldCount)
  bw.writeInt32(0)
  bw.reserveInt32(`${isModifierProp ? 'Property' : 'ModifiableProperty'}FieldsOffset${count}`)
  bw.writeInt32(0)
  if (!isModifierProp) {
    bw.reserveInt32(`PropertyModifiersOffset${count}`)
    bw.writeInt32(0)
    bw.writeInt32((prop as IModifiableProperty<any, any>).modifiers.length)
    bw.writeInt32(0)
  }
  properties.push(prop)
}

function writePropertyModifiers(prop: IModifiableProperty<any, any>, bw: BinaryWriter, game: Game, index: number, modifiers: IModifier<any>[]) {
  if (prop.modifiers.length === 0) {
    bw.fill(`PropertyModifiersOffset${index}`, 0)
    return
  }
  bw.fill(`PropertyModifiersOffset${index}`, bw.position)
  for (const modifier of prop.modifiers) {
    writeModifier(modifier, bw, game, modifiers)
  }
}

function writePropertyFields(prop: IProperty<any, any>, bw: BinaryWriter, index: number, isModifierProp: boolean): number {
  const offsetName = `${isModifierProp ? 'Property' : 'ModifiableProperty'}FieldsOffset${index}`
  const fieldCount = prop.fieldCount
  if (fieldCount === 0) {
    bw.fill(offsetName, 0)
  } else {
    bw.fill(offsetName, bw.position)
    for (const field of prop.fields) {
      writeField(field, bw)
    }
  }
  return fieldCount
}

//#region Functions - Action
function readAction(
  br: BinaryReader,
  type: number,
  fieldCount1: number,
  propertyCount1: number,
  fieldCount2: number,
  propertyCount2: number,
  section10Count: number
): Action {
  const fieldOffset = br.readOffset()
  const section10Offset = br.readOffset()
  const propertyOffset = br.readOffset()
  br.position += 8 // Unknown offset

  br.stepIn(propertyOffset)
  const properties1: AnyProperty[] = []
  const properties2: AnyProperty[] = []
  for (let i = 0; i < propertyCount1; ++i) {
    properties1.push(readProperty(br, false))
  }
  for (let i = 0; i < propertyCount2; ++i) {
    properties2.push(readProperty(br, false))
  }
  br.stepOut()

  br.stepIn(section10Offset)
  const section10s: number[][] = []
  for (let i = 0; i < section10Count; ++i) {
    section10s.push(readSection10(br))
  }
  br.stepOut()

  br.stepIn(fieldOffset)
  const fields1 = readFields(br, fieldCount1, Action)
  const fields2 = readFields(br, fieldCount2, Action)
  br.stepOut()
  return new Action(type, fields1, fields2, properties1, properties2, section10s)
}

function writeAction(action: Action, bw: BinaryWriter, actions: AnyAction[]) {
  const count = actions.length
  bw.writeInt16(action.type)
  bw.writeUint8(0) // Unk02
  bw.writeUint8(0) // Unk03
  bw.writeInt32(0) // Unk04
  bw.writeInt32(fieldsCount(action.fields1))
  bw.writeInt32(action.section10s.length)
  bw.writeInt32(action.properties1.length)
  bw.writeInt32(fieldsCount(action.fields2))
  bw.writeInt32(0)
  bw.writeInt32(action.properties2.length)
  bw.reserveInt32(`ActionFieldsOffset${count}`)
  bw.writeInt32(0)
  bw.reserveInt32(`ActionSection10sOffset${count}`)
  bw.writeInt32(0)
  bw.reserveInt32(`ActionPropertiesOffset${count}`)
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.writeInt32(0)
  actions.push(action)
}

function writeActionProperties(action: Action, bw: BinaryWriter, game: Game, index: number, properties: IModifiableProperty<any, any>[]) {
  bw.fill(`ActionPropertiesOffset${index}`, bw.position)
  for (const property of action.properties1) {
    writeProperty(property.for(game), bw, game, properties, false)
  }
  for (const property of action.properties2) {
    writeProperty(property.for(game), bw, game, properties, false)
  }
}

function writeActionSection10s(action: Action, bw: BinaryWriter, index: number, section10s: number[][]) {
  bw.fill(`ActionSection10sOffset${index}`, bw.position)
  for (const section10 of action.section10s) {
    writeSection10(section10, bw, section10s)
  }
}

function writeActionFields(action: Action, bw: BinaryWriter, index: number): number {
  if (action.fields1.length + action.fields2.length === 0) {
    bw.fill(`ActionFieldsOffset${index}`, 0)
    return 0
  }
  let count = 0
  bw.fill(`ActionFieldsOffset${index}`, bw.position)
  for (const field of action.fields1) {
    writeField(field, bw)
    count += fieldCompCount[field.type]
  }
  for (const field of action.fields2) {
    writeField(field, bw)
    count += fieldCompCount[field.type]
  }
  return count
}

//#region Functions - DataAction
function readDataAction(
  br: BinaryReader,
  gameData: FilledActionGameDataEntry,
  type: ActionType,
  fieldCount1: number,
  propertyCount1: number,
  fieldCount2: number,
  propertyCount2: number,
  section10Count: number
): DataAction {
  const game = br.game === Game.Heuristic ? Game.EldenRing : br.game
  const fieldOffset = br.readOffset()
  const section10Offset = br.readOffset()
  const propertyOffset = br.readOffset()
  br.position += 8 // Unknown offset

  const adt = ActionData[type]
  if (!('props' in adt)) {
    return new DataActions[type]
  }

  const c: {
    fields1: Field<FieldType>[]
    fields2: Field<FieldType>[]
    properties1: AnyProperty[]
    properties2: AnyProperty[]
    section10s: number[][]
  } = {
    fields1: [],
    fields2: [],
    properties1: [],
    properties2: [],
    section10s: [],
  }

  br.stepIn(propertyOffset)
  for (let i = 0; i < propertyCount1; ++i) {
    c.properties1.push(readProperty(br, false))
  }
  for (let i = 0; i < propertyCount2; ++i) {
    c.properties2.push(readProperty(br, false))
  }
  br.stepOut()

  br.stepIn(section10Offset)
  for (let i = 0; i < section10Count; ++i) {
    c.section10s.push(readSection10(br))
  }
  br.stepOut()

  br.stepIn(fieldOffset)
  if ('fields1' in gameData) {
    c.fields1 = readFieldsWithTypes(br, fieldCount1, gameData.fields1.map((e: string) =>
      typeof adt.props[e].field === 'number' ? adt.props[e].field : adt.props[e].field[game]
    ), null)
  }
  if ('fields2' in gameData) {

    /*
      DS3's action 10012 randomly has an int of -2 at the start of the fields2
      list, which shifts all of the other indices. This checks for that value
      and just skips past it if it's there.
    */
    if (game === Game.DarkSouls3 && type === ActionType.Tracer && br.getInt32(br.position) === -2) {
      fieldCount2--
      br.position += 4
    }

    c.fields2 = readFieldsWithTypes(br, fieldCount2, gameData.fields2.map((e: string) =>
      typeof adt.props[e].field === 'number' ? adt.props[e].field : adt.props[e].field[game]
    ), null)
  }
  br.stepOut()
  let params = Object.fromEntries(
    Object.entries(adt.props).filter(([_, prop]) => game in prop.paths).map(([name, prop]) => {
      const v = c[prop.paths[game][0]][prop.paths[game][1]]
      if (v instanceof Field) {
        return [name, v.value]
      } else {
        return [name, v ?? prop.default]
      }
    })
  )
  if (type in ActionDataConversion && 'read' in ActionDataConversion[type]) {
    params = ActionDataConversion[type].read(params, game)
  }
  if (Object.keys(adt.props).length === 1) {
    return new DataActions[type](Object.values(params)[0])
  }
  return new DataActions[type](params)
}

function writeDataAction(action: DataAction, bw: BinaryWriter, game: Game, actions: AnyAction[]) {
  if (game === Game.Generic) {
    throw new Error('DataActions cannot be formatted for Game.Generic.')
  }
  bw.convertedDataActions.set(action,
    action.type in ActionDataConversion && 'write' in action.$convert ?
      action.$convert.write(action.clone(), game) :
      action
  )
  const ade = action.$data
  const data = getActionGameData(action.type, game)
  const count = actions.length
  bw.writeInt16(action.type)
  bw.writeUint8(0) // Unk02
  bw.writeUint8(0) // Unk03
  bw.writeInt32(0) // Unk04
  bw.writeInt32(data.fields1
    .map(name => fieldCompCount[
      typeof ade.props[name].field === 'number' ? ade.props[name].field : ade.props[name].field[game]
    ])
    .reduce((a, e) => a + e, 0)
  )
  bw.writeInt32(data.section10s.length)
  bw.writeInt32(data.properties1.length)
  bw.writeInt32(data.fields2
    .map(name => fieldCompCount[
      typeof ade.props[name].field === 'number' ? ade.props[name].field : ade.props[name].field[game]
    ])
    .reduce((a, e) => a + e, 0)
  )
  bw.writeInt32(0)
  bw.writeInt32(data.properties2.length)
  bw.reserveInt32(`ActionFieldsOffset${count}`)
  bw.writeInt32(0)
  bw.reserveInt32(`ActionSection10sOffset${count}`)
  bw.writeInt32(0)
  bw.reserveInt32(`ActionPropertiesOffset${count}`)
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.writeInt32(0)
  actions.push(action)
}

function writeDataActionProperties(action: DataAction, bw: BinaryWriter, game: Game, index: number, properties: IModifiableProperty<any, any>[]) {
  const conProps = bw.convertedDataActions.get(action)
  const properties1: AnyProperty[] = action.getProperties(game, 'properties1', conProps)
  const properties2: AnyProperty[] = action.getProperties(game, 'properties2', conProps)
  bw.fill(`ActionPropertiesOffset${index}`, bw.position)
  for (const property of properties1) {
    writeProperty(property, bw, game, properties, false)
  }
  for (const property of properties2) {
    writeProperty(property, bw, game, properties, false)
  }
}

function writeDataActionSection10s(action: DataAction, bw: BinaryWriter, game: Game, index: number, section10s: number[][]) {
  bw.fill(`ActionSection10sOffset${index}`, bw.position)
  for (const section10 of action.getSection10s(game)) {
    writeSection10(section10, bw, section10s)
  }
}

function writeDataActionFields(action: DataAction, bw: BinaryWriter, game: Game, index: number): number {
  const conProps = bw.convertedDataActions.get(action)
  const fields1: Field<FieldType>[] = action.getFields(game, 'fields1', conProps)
  const fields2: Field<FieldType>[] = action.getFields(game, 'fields2', conProps)
  if (fields1.length + fields2.length === 0) {
    bw.fill(`ActionFieldsOffset${index}`, 0)
    return 0
  }
  let count = 0
  bw.fill(`ActionFieldsOffset${index}`, bw.position)
  for (const field of fields1) {
    writeField(field, bw)
    count += fieldCompCount[field.type]
  }
  for (const field of fields2) {
    writeField(field, bw)
    count += fieldCompCount[field.type]
  }
  return count
}

//#region Functions - AnyAction
function readAnyAction(br: BinaryReader): AnyAction {
  const type = br.readInt16()
  br.position += 6
  // br.readUint8() // Unk02
  // br.readUint8() // Unk03
  // br.readInt32() // Unk04
  const fieldCount1 = br.readInt32()
  const section10Count = br.readInt32()
  const propertyCount1 = br.readInt32()
  const fieldCount2 = br.readInt32()
  br.assertInt32(0)
  const propertyCount2 = br.readInt32()

  if (br.game !== Game.Generic && type in ActionData) {
    let game = br.game
    heuristic: if (game === Game.Heuristic) {
      if (type === ActionType.ParticleForceCollision) {
        game = br.game = Game.ArmoredCore6
        break heuristic
      }
      if (type === ActionType.Unk10500) {
        if (propertyCount1 === 0) {
          game = br.game = Game.Sekiro
          break heuristic
        }
        const f7 = br.getInt32(br.position + 4 * 7)
        if (f7 < 0 || f7 >= 1e6) {
          game = br.game = Game.ArmoredCore6
          break heuristic
        }
      }
      if (type === ActionType.LevelsOfDetailThresholds && fieldCount1 === 6) {
        game = br.game = Game.ArmoredCore6
        break heuristic
      }
      if (type === ActionType.BillboardEx && fieldCount2 === 46) {
        game = br.game = Game.ArmoredCore6
        break heuristic
      }
      if (type === ActionType.MultiTextureBillboardEx && fieldCount2 === 47) {
        game = br.game = Game.ArmoredCore6
        break heuristic
      }
      if (type === ActionType.Model && fieldCount2 === 39) {
        game = br.game = Game.ArmoredCore6
        break heuristic
      }
      if (type === ActionType.Tracer && fieldCount2 === 42) {
        game = br.game = Game.ArmoredCore6
        break heuristic
      }
      if (type === ActionType.LensFlare) {
        if (fieldCount1 > 75) {
          game = br.game = Game.ArmoredCore6
        } else {
          game = br.game = Game.EldenRing
        }
        break heuristic
      }
      if (type === ActionType.RichModel) {
        if (fieldCount1 > 26 || propertyCount1 === 24) {
          game = br.game = Game.ArmoredCore6
        } else {
          game = br.game = Game.EldenRing
        }
        break heuristic
      }
      game = Game.EldenRing
    }
    const data = getActionGameData(type, game)
    if (
      section10Count <= data.section10s.length &&
      fieldCount1 <= data.fields1.fieldsCount &&
      ( // Deal with DS3's action 10012 special case where it has 1 extra field
        // that is skipped while reading
        game === Game.DarkSouls3 && type === ActionType.Tracer ?
        fieldCount2 - 1 :
        fieldCount2
      ) <= data.fields2.fieldsCount &&
      propertyCount1 <= data.properties1.length &&
      propertyCount2 <= data.properties2.length
    ) {
      return readDataAction(br, data, type, fieldCount1, propertyCount1, fieldCount2, propertyCount2, section10Count)
    } else {
      return readAction(br, type, fieldCount1, propertyCount1, fieldCount2, propertyCount2, section10Count)
    }
  } else {
    return readAction(br, type, fieldCount1, propertyCount1, fieldCount2, propertyCount2, section10Count)
  }
}

function writeAnyAction(action: AnyAction, bw: BinaryWriter, game: Game, actions: AnyAction[]) {
  if (action instanceof DataAction) {
    if ('props' in action.$data && action.$data.games[game] === -2) {
      writeAction(action.$convert.fallback(action, game), bw, actions)
    } else {
      writeDataAction(action, bw, game, actions)
    }
  } else {
    writeAction(action, bw, actions)
  }
}

function writeAnyActionProperties(action: AnyAction, bw: BinaryWriter, game: Game, index: number, properties: IModifiableProperty<any, any>[]) {
  if (action instanceof DataAction) {
    writeDataActionProperties(action, bw, game, index, properties)
  } else {
    writeActionProperties(action, bw, game, index, properties)
  }
}

function writeAnyActionSection10s(action: AnyAction, bw: BinaryWriter, game: Game, index: number, section10s: number[][]) {
  if (action instanceof DataAction) {
    writeDataActionSection10s(action, bw, game, index, section10s)
  } else {
    writeActionSection10s(action, bw, index, section10s)
  }
}

function writeAnyActionFields(action: AnyAction, bw: BinaryWriter, game: Game, index: number): number {
  if (action instanceof DataAction) {
    return writeDataActionFields(action, bw, game, index)
  } else {
    return writeActionFields(action, bw, index)
  }
}

//#region Functions - Node
function readNode(br: BinaryReader): Node {
  const type = br.readInt16()
  br.assertUint8(0)
  br.assertUint8(1)
  br.assertInt32(0)
  const configCount = br.readInt32()
  const actionCount = br.readInt32()
  const nodeCount = br.readInt32()
  br.assertInt32(0)
  const configOffset = br.readOffset()
  const actionOffset = br.readOffset()
  const nodeOffset = br.readOffset()
  br.stepIn(nodeOffset)
  const nodes = []
  for (let i = 0; i < nodeCount; ++i) {
    nodes.push(readNode(br))
  }
  br.stepOut()
  br.stepIn(configOffset)
  const configs = []
  for (let i = 0; i < configCount; ++i) {
    configs.push(readConfig(br))
  }
  br.stepOut()
  br.stepIn(actionOffset)
  const actions = []
  for (let i = 0; i < actionCount; ++i) {
    actions.push(readAnyAction(br))
  }
  br.stepOut()
  if (br.game !== Game.Generic) switch (type) {
    case NodeType.Root:
      if (configCount === 0 && actionCount === (br.game === Game.DarkSouls3 || br.game === Game.Sekiro ? 3 : 4)) {
        return new RootNode(
          nodes,
          br.game === Game.DarkSouls3 || br.game === Game.Sekiro ? null :
            actions.find(e => e.type >= 700 && e.type <= 702) ?? new Action(ActionType.SimulateTermination),
          actions.find(e => e.type === ActionType.Unk10100),
          actions.find(e => e.type === ActionType.Unk10400),
          actions.find(e => e.type === ActionType.Unk10500)
        )
      }
      break
    case NodeType.Proxy:
      if (configCount === 0 && actionCount === 1 && actions[0] instanceof SFXReference) {
        return new ProxyNode(actions[0].sfx)
      }
      break
    case NodeType.LevelsOfDetail:
      if (actionCount === 1 && actions[0] instanceof StateConfigMap) {
        return new LevelsOfDetailNode(configs, nodes).mapStates(...actions[0].configIndices)
      }
      break
    case NodeType.Basic:
      if (actionCount === 1 && actions[0] instanceof StateConfigMap) {
        return new BasicNode(configs, nodes).mapStates(...actions[0].configIndices)
      }
      break
    case NodeType.NodeEmitter:
      if (actionCount === 1 && actions[0] instanceof StateConfigMap) {
        return new NodeEmitterNode(configs, nodes).mapStates(...actions[0].configIndices)
      }
      break
  }
  return new GenericNode(type, actions, configs, nodes)
}

function writeNode(node: Node, bw: BinaryWriter, game: Game, nodes: Node[]) {
  if (game === Game.Generic && !(node instanceof GenericNode)) {
    throw new Error('Non-generic node classes cannot be formatted for Game.Generic.')
  }
  const count = nodes.length
  let configCount = 0
  let actionCount = 0
  let childCount = 0
  if (node instanceof GenericNode) {
    configCount = node.configs.length
    actionCount = node.actions.length
    childCount = node.nodes.length
  } else if (node instanceof NodeWithConfigs) {
    configCount = node.configs.length
    actionCount = 1
    childCount = node.nodes.length
  } else if (node instanceof RootNode) {
    actionCount = game === Game.DarkSouls3 || game === Game.Sekiro ? 3 : 4
    childCount = node.nodes.length
  } else if (node instanceof ProxyNode) {
    actionCount = 1
  }
  bw.writeInt16(node.type)
  bw.writeUint8(0)
  bw.writeUint8(1)
  bw.writeInt32(0)
  bw.writeInt32(configCount)
  bw.writeInt32(actionCount)
  bw.writeInt32(childCount)
  bw.writeInt32(0)
  bw.reserveInt32(`NodeConfigsOffset${count}`)
  bw.writeInt32(0)
  bw.reserveInt32(`NodeActionsOffset${count}`)
  bw.writeInt32(0)
  bw.reserveInt32(`NodeChildNodesOffset${count}`)
  bw.writeInt32(0)
  nodes.push(node)
}

function writeNodeChildren(node: Node, bw: BinaryWriter, game: Game, nodes: Node[]) {
  const num = nodes.indexOf(node)
  let childCount = 0
  if (node instanceof GenericNode || node instanceof NodeWithConfigs || node instanceof RootNode) {
    childCount = node.nodes.length
  }
  if (childCount === 0) {
    bw.fill(`NodeChildNodesOffset${num}`, 0)
  } else {
    bw.fill(`NodeChildNodesOffset${num}`, bw.position)
    const children = node.getNodes(game)
    for (const node of children) {
      writeNode(node, bw, game, nodes)
    }
    for (const node of children) {
      writeNodeChildren(node, bw, game, nodes)
    }
  }
}

function writeNodeConfigs(node: Node, bw: BinaryWriter, game: Game, index: number, configCounter: { value: number }) {
  let configCount = 0
  if (node instanceof GenericNode || node instanceof NodeWithConfigs) {
    configCount = node.configs.length
  }
  if (configCount === 0) {
    bw.fill(`NodeConfigsOffset${index}`, 0)
  } else {
    bw.fill(`NodeConfigsOffset${index}`, bw.position)
    const nodeConfigs = node.getConfigs(game)
    for (let i = 0; i < nodeConfigs.length; ++i) {
      writeConfig(nodeConfigs[i], bw, game, configCounter.value + i)
    }
    configCounter.value += nodeConfigs.length
  }
}

function writeNodeActions(node: Node, bw: BinaryWriter, game: Game, index: number, configCounter: { value: number }, actions: Action[]) {
  bw.fill(`NodeActionsOffset${index}`, bw.position)
  const nodeActions = node.getActions(game)
  const nodeConfigs = node.getConfigs(game)
  for (const action of nodeActions) {
    writeAnyAction(action, bw, game, actions)
  }
  for (let i = 0; i < nodeConfigs.length; ++i) {
    writeConfigActions(nodeConfigs[i], bw, game, configCounter.value + i, actions)
  }
  configCounter.value += nodeConfigs.length
}

//#region Functions - Config
function readConfig(br: BinaryReader): IConfig {
  const type = br.readInt16()
  br.assertUint8(0)
  br.assertUint8(1)
  br.assertInt32(0)
  br.assertInt32(0)
  const actionCount = br.readInt32()
  br.assertInt32(0)
  br.assertInt32(0)
  const actionOffset = br.readOffset()
  br.stepIn(actionOffset)
  const actions = []
  for (let i = 0; i < actionCount; ++i) {
    actions.push(readAnyAction(br))
  }
  br.stepOut()
  if (br.game === Game.Generic) {
    return new NodeConfig(type, actions)
  } else if (type === ConfigType.LevelsOfDetail && actionCount === 1 && actions[0] instanceof LevelsOfDetailThresholds) {
    const lod = actions[0]
    return new LevelsOfDetailConfig(lod.duration, [
      lod.threshold0,
      lod.threshold1,
      lod.threshold2,
      lod.threshold3,
      lod.threshold4,
    ])
  } else if (type === ConfigType.Basic && actionCount <= 15) {
    return new BasicConfig(actions)
  } else if (type === ConfigType.NodeEmitter && actionCount <= 10) {
    return new NodeEmitterConfig(actions)
  } else {
    return new NodeConfig(type, actions)
  }
}

function writeConfig(config: IConfig, bw: BinaryWriter, game: Game, index: number) {
  bw.writeInt16(config.type)
  bw.writeUint8(0)
  bw.writeUint8(1)
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.writeInt32(config.getActionCount(game))
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.reserveInt32(`ConfigActionsOffset${index}`)
  bw.writeInt32(0)
}

function writeConfigActions(config: IConfig, bw: BinaryWriter, game: Game, index: number, actions: Action[]) {
  bw.fill(`ConfigActionsOffset${index}`, bw.position)
  for (const action of config.getActions(game)) {
    writeAnyAction(action, bw, game, actions)
  }
}

//#region Functions - Modifier
function readModifier(br: BinaryReader): IModifier<ValueType> {
  const typeEnumA = br.readUint16()
  const modifierType = Modifier.enumAToType(typeEnumA)
  if (!(modifierType in ModifierType)) {
    throw new Error('Unrecognized modifier type: ' + typeEnumA)
  }
  const valueType = typeEnumA & 0b11
  if (!(modifierType in ModifierType)) {
    throw new Error('Unknown property modifier type enum A: ' + typeEnumA)
  }
  br.assertUint8(0)
  br.assertUint8(1)
  br.position += 4 // typeEnumB
  const fieldCount = br.readInt32()
  const propertyCount = br.readInt32()
  const fieldOffset = br.readOffset()
  const propertyOffset = br.readOffset()
  br.stepIn(propertyOffset)
  const properties = []
  for (let i = 0; i < propertyCount; ++i) {
    properties.push(readProperty(br, true))
  }
  br.stepOut()
  if (br.game === Game.Generic) {
    const fields = readFieldsAt(br, fieldOffset, fieldCount, this)
    return new GenericModifier(modifierType, valueType, fields, properties)
  } else switch (modifierType) {
    case ModifierType.RandomDelta: {
      const expFieldCount = (valueType + 1) * 2
      if (fieldCount !== expFieldCount) {
        console.warn(`Warning: Invalid field count for ${ValueType[valueType]} RandomDelta modifier: ${fieldCount}, expected ${expFieldCount}.`)
      }
      const fields = readFieldsWithTypesAt(br, fieldOffset, expFieldCount, [
        ...arrayOf(valueType + 1, () => FieldType.Integer),
        ...arrayOf(valueType + 1, () => FieldType.Float),
      ], this) as NumericalField[]
      if (valueType === ValueType.Scalar) {
        return new RandomDeltaModifier(fields[1].value, fields[0].value)
      }
      return new RandomDeltaModifier(
        fields.slice(valueType + 1).map(e => e.value) as Vector,
        fields.slice(0, valueType + 1).map(e => e.value) as Vector,
      )
    }
    case ModifierType.RandomRange: {
      const expFieldCount = (valueType + 1) * 3
      if (fieldCount !== expFieldCount) {
        console.warn(`Warning: Invalid field count for ${ValueType[valueType]} RandomRange modifier: ${fieldCount}, expected ${expFieldCount}.`)
      }
      const fields = readFieldsWithTypesAt(br, fieldOffset, expFieldCount, [
        ...arrayOf(valueType + 1, () => FieldType.Integer),
        ...arrayOf((valueType + 1) * 2, () => FieldType.Float),
      ], this) as NumericalField[]
      if (valueType === ValueType.Scalar) {
        return new RandomRangeModifier(fields[1].value, fields[2].value, fields[0].value)
      }
      return new RandomRangeModifier(
        fields.slice(valueType + 1, (valueType + 1) * 2).map(e => e.value) as Vector,
        fields.slice((valueType + 1) * 2).map(e => e.value) as Vector,
        fields.slice(0, valueType + 1).map(e => e.value) as Vector,
      )
    }
    case ModifierType.RandomFraction: {
      const expFieldCount = (valueType + 1) * 2
      if (fieldCount !== expFieldCount) {
        console.warn(`Warning: Invalid field count for ${ValueType[valueType]} RandomFraction modifier: ${fieldCount}, expected ${expFieldCount}.`)
      }
      const fields = readFieldsWithTypesAt(br, fieldOffset, expFieldCount, [
        ...arrayOf(valueType + 1, () => FieldType.Integer),
        ...arrayOf(valueType + 1, () => FieldType.Float),
      ], this) as NumericalField[]
      if (valueType === ValueType.Scalar) {
        return new RandomFractionModifier(fields[1].value, fields[0].value)
      }
      return new RandomFractionModifier(
        fields.slice(valueType + 1).map(e => e.value) as Vector,
        fields.slice(0, valueType + 1).map(e => e.value) as Vector,
      )
    }
    case ModifierType.ExternalValue1: {
      const expFieldCount = 1
      if (fieldCount !== expFieldCount) {
        console.warn(`Warning: Invalid field count for ${ValueType[valueType]} ExternalValue1 modifier: ${fieldCount}, expected ${expFieldCount}.`)
      }
      const fields = readFieldsWithTypesAt(br, fieldOffset, expFieldCount, [FieldType.Integer], this) as NumericalField[]
      return new ExternalValue1Modifier(fields[0].value, properties[0])
    }
    case ModifierType.ExternalValue2: {
      const expFieldCount = 1
      if (fieldCount !== expFieldCount) {
        console.warn(`Warning: Invalid field count for ${ValueType[valueType]} ExternalValue2 modifier: ${fieldCount}, expected ${expFieldCount}.`)
      }
      const fields = readFieldsWithTypesAt(br, fieldOffset, expFieldCount, [FieldType.Integer], this) as NumericalField[]
      return new ExternalValue2Modifier(fields[0].value, properties[0])
    }
  }
}

function writeModifier(modifier: IModifier<ValueType>, bw: BinaryWriter, game: Game, modifiers: IModifier<ValueType>[]) {
  const count = modifiers.length
  bw.writeInt16(Modifier.typeToEnumA(modifier.type, modifier.valueType))
  bw.writeUint8(0)
  bw.writeUint8(1)
  bw.writeInt32(Modifier.enumBValues[game][modifier.type] | modifier.valueType)
  bw.writeInt32(modifier.getFieldCount())
  bw.writeInt32(modifier.getPropertyCount())
  bw.reserveInt32(`Section8FieldsOffset${count}`)
  bw.writeInt32(0)
  bw.reserveInt32(`Section8Section9sOffset${count}`)
  bw.writeInt32(0)
  modifiers.push(modifier)
}

function writeModifierProperties(modifier: IModifier<ValueType>, bw: BinaryWriter, game: Game, index: number, properties: IProperty<any, any>[]) {
  bw.fill(`Section8Section9sOffset${index}`, bw.position)
  for (const property of modifier.getProperties(game)) {
    // Modifier props can't have modifiers, so it's safe to not use .for(game) here
    writeProperty(property, bw, game, properties, true)
  }
}

function writeModifierFields(modifier: IModifier<ValueType>, bw: BinaryWriter, index: number): number {
  bw.fill(`Section8FieldsOffset${index}`, bw.position)
  const fields = modifier.getFields()
  let count = 0
  for (const field of fields) {
    writeField(field, bw)
    count += fieldCompCount[field.type]
  }
  return count
}

//#region Functions - Section10
function readSection10(br: BinaryReader) {
  const offset = br.readOffset()
  const count = br.readInt32()
  br.assertInt32(0)
  const values: number[] = []
  br.stepIn(offset)
  for (let i = count; i > 0; i--) {
    values.push(br.readInt32())
  }
  br.stepOut()
  return values
}

function writeSection10(s10: number[], bw: BinaryWriter, section10s: number[][]) {
  const count = section10s.length
  bw.reserveInt32(`Section10FieldsOffset${count}`)
  bw.writeInt32(0)
  bw.writeInt32(s10.length)
  bw.writeInt32(0)
  section10s.push(s10)
}

function writeSection10Fields(s10: number[], bw: BinaryWriter, index: number): number {
  if (s10.length === 0) {
    bw.fill(`Section10FieldsOffset${index}`, 0)
  } else {
    bw.fill(`Section10FieldsOffset${index}`, bw.position)
    for (const value of s10) {
      bw.writeInt32(value)
    }
  }
  return s10.length
}

//#region Functions - State
function readState(br: BinaryReader) {
  br.assertInt32(0)
  const count = br.readInt32()
  const offset = br.readOffset()
  br.stepIn(offset)
  const conditions: StateCondition[] = []
  for (let i = 0; i < count; ++i) {
    conditions.push(readStateCondition(br))
  }
  br.stepOut()
  return new State(conditions)
}

function writeState(state: State, bw: BinaryWriter, index: number) {
  bw.writeInt32(0)
  bw.writeInt32(state.conditions.length)
  bw.reserveInt32(`StateConditionsOffset${index}`)
  bw.writeInt32(0)
}

function writeStateConditions(conditions: StateCondition[], bw: BinaryWriter, index: number, acc: StateCondition[]) {
  bw.fill(`StateConditionsOffset${index}`, bw.position)
  for (const condition of conditions) {
    writeStateCondition(condition, bw, acc)
  }
}

//#region Functions - State Condition
function readStateCondition(br: BinaryReader) {
  const bf1 = br.readInt16()
  const operator = bf1 & 0b11
  const unk1 = (bf1 & 0b1100) >>> 2
  br.assertUint8(0)
  br.assertUint8(1)
  br.assertInt32(0)
  const targetStateIndex = br.readInt32()
  br.assertInt32(0)
  const leftOperand = br.assertInt16(-4, -3, -2, -1)
  br.assertUint8(0)
  br.assertUint8(1)
  br.assertInt32(0)
  const hasLeftValue = !!br.assertInt32(0, 1)
  br.assertInt32(0)
  const leftOffset = br.readOffset()
  br.assertInt32(0)
  br.assertInt32(0)
  br.assertInt32(0)
  br.assertInt32(0)
  const rightOperand = br.assertInt16(-4, -3, -2, -1)
  br.assertUint8(0)
  br.assertUint8(1)
  br.assertInt32(0)
  const hasRightValue = !!br.assertInt32(0, 1)
  br.assertInt32(0)
  const rightOffset = br.readOffset()
  br.assertInt32(0)
  br.assertInt32(0)
  br.assertInt32(0)
  br.assertInt32(0)
  return new StateCondition(
    operator,
    unk1,
    targetStateIndex,
    leftOperand,
    hasLeftValue ? readStateConditionOperandValue(br, leftOperand, leftOffset) : null,
    rightOperand,
    hasRightValue ? readStateConditionOperandValue(br, rightOperand, rightOffset) : null,
  ).sortOperands()
}

function readStateConditionOperandValue(br: BinaryReader, type: number, offset: number) {
  switch (type) {
    case OperandType.Literal: {
      br.stepIn(offset)
      const value = br.readFloat32()
      br.stepOut()
      return value
    }
    case OperandType.External: {
      br.stepIn(offset)
      const value = br.readInt32()
      br.stepOut()
      return value
    }
    case OperandType.UnkMinus2:
    case OperandType.StateTime:
      br.stepIn(offset)
      const value = br.readInt32()
      br.stepOut()
      console.warn(
        `Warning: Unexpected value for operand: ${OperandType[type]} - ${value}`,
        'This operand type should not have a value, so the value will be ignored.',
        'In most cases, this is caused by other (outdated) tools being used to modify the FXR file.'
      )
      return null
  }
}

function writeFormattedStateCondition(con: StateCondition, bw: BinaryWriter, acc: StateCondition[]) {
  const count = acc.length
  bw.writeInt16(con.operator | con.unk1 << 2)
  bw.writeUint8(0)
  bw.writeUint8(1)
  bw.writeInt32(0)
  bw.writeInt32(con.nextState)
  bw.writeInt32(0)
  bw.writeInt16(con.leftOperandType)
  bw.writeInt8(0)
  bw.writeInt8(1)
  bw.writeInt32(0)
  bw.writeInt32(+(con.leftOperandValue !== null))
  bw.writeInt32(0)
  bw.reserveInt32(`ConditionLeftOffset${count}`)
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.writeInt16(con.rightOperandType)
  bw.writeInt8(0)
  bw.writeInt8(1)
  bw.writeInt32(0)
  bw.writeInt32(+(con.rightOperandValue !== null))
  bw.writeInt32(0)
  bw.reserveInt32(`ConditionRightOffset${count}`)
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.writeInt32(0)
  bw.writeInt32(0)
  acc.push(con)
}

function writeStateCondition(con: StateCondition, bw: BinaryWriter, acc: StateCondition[]) {
  writeFormattedStateCondition(con.formatCondition(), bw, acc)
}

function writeStateConditionFields(con: StateCondition, bw: BinaryWriter, index: number): number {
  let count = 0
  if (con.leftOperandValue === null) {
    bw.fill(`ConditionLeftOffset${index}`, 0)
  } else {
    if (con.leftOperandType === OperandType.Literal) {
      bw.fill(`ConditionLeftOffset${index}`, bw.position)
      bw.writeFloat32(con.leftOperandValue)
    } else {
      bw.fill(`ConditionLeftOffset${index}`, bw.position)
      bw.writeInt32(con.leftOperandValue)
    }
    count++
  }
  if (con.rightOperandValue === null) {
    bw.fill(`ConditionRightOffset${index}`, 0)
  } else {
    if (con.rightOperandType === OperandType.Literal) {
      bw.fill(`ConditionRightOffset${index}`, bw.position)
      bw.writeFloat32(con.rightOperandValue)
    } else {
      bw.fill(`ConditionRightOffset${index}`, bw.position)
      bw.writeInt32(con.rightOperandValue)
    }
    count++
  }
  return count
}

//#region Functions - Field
function readField(br: BinaryReader, context: any, index: number) {
  let field: NumericalField = null
  let isInt = false

  if (context?.[0] in PropertyFunction) {
    if (context[0] === PropertyFunction.ComponentHermite) {
      isInt = index > 0 && index <= context[1] + 1
    } else if (context[0] !== PropertyFunction.Constant) {
      isInt = !index
    }
  } else {
    const single = br.getFloat32(br.position)
    if (single >=  9.99999974737875E-05 && single <  1000000.0 ||
        single <= -9.99999974737875E-05 && single > -1000000.0
    ) {
      field = new FloatField(single)
    } else {
      isInt = true
    }
  }

  if (field === null) {
    if (isInt) {
      field = new IntField(br.getInt32(br.position))
    } else {
      field = new FloatField(br.getFloat32(br.position))
    }
  }

  br.position += 4
  return field
}

function readFields(br: BinaryReader, count: number, context: any) {
  const fields: NumericalField[] = []
  for (let i = 0; i < count; ++i) {
    fields.push(readField(br, context, i))
  }
  return fields
}

function readFieldsAt(br: BinaryReader, offset: number, count: number, context: any) {
  br.stepIn(offset)
  const fields = readFields(br, count, context)
  br.stepOut()
  return fields
}

function readFieldsWithTypes(br: BinaryReader, count: number, types: FieldType[], context: any): Field<FieldType>[] {
  const fields: Field<FieldType>[] = []
  for (let i = 0, j = 0; i < count; j++) {
    switch (types[j]) {
      case FieldType.Boolean:
        i++
        fields.push(new BoolField(!!br.assertInt32(0, 1)))
        break
      case FieldType.Integer:
        i++
        fields.push(new IntField(br.readInt32()))
        break
      case FieldType.Float:
        i++
        fields.push(new FloatField(br.readFloat32()))
        break
      case FieldType.Vector2:
        i += 2
        fields.push(new Vector2Field([ br.readFloat32(), br.readFloat32() ]))
        break
      case FieldType.Vector3:
        i += 3
        fields.push(new Vector3Field([ br.readFloat32(), br.readFloat32(), br.readFloat32() ]))
        break
      case FieldType.Vector4:
        i += 4
        fields.push(new Vector4Field([
          br.readFloat32(),
          br.readFloat32(),
          br.readFloat32(),
          br.readFloat32()
        ]))
        break
      default:
        fields.push(readField(br, context, 0))
    }
  }
  return fields
}

function readFieldsWithTypesAt(
  br: BinaryReader,
  offset: number,
  count: number,
  types: FieldType[],
  context: any
): Field<FieldType>[] {
  br.stepIn(offset)
  const fields = readFieldsWithTypes(br, count, types, context)
  br.stepOut()
  return fields
}

function writeField(field: Field<FieldType>, bw: BinaryWriter) {
  switch (field.type) {
    case FieldType.Boolean: return bw.writeInt32(+field.value)
    case FieldType.Integer: return bw.writeInt32(field.value as number)
    case FieldType.Float: return bw.writeFloat32(field.value as number)
    case FieldType.Vector2:
      bw.writeFloat32(field.value[0])
      bw.writeFloat32(field.value[1])
      break
    case FieldType.Vector3:
      bw.writeFloat32(field.value[0])
      bw.writeFloat32(field.value[1])
      bw.writeFloat32(field.value[2])
      break
    case FieldType.Vector4:
      bw.writeFloat32(field.value[0])
      bw.writeFloat32(field.value[1])
      bw.writeFloat32(field.value[2])
      bw.writeFloat32(field.value[3])
      break
    default: throw new Error('Invalid field type: ' + field.type)
  }
}

//#region Conversion / Utility
const deg2rad = Math.PI / 180

function arrayOf<T>(size: number, func: (index: number) => T): T[] {
  return Array(size).fill(null).map((e, i) => func(i))
}

function randomInt32() {
  let v: number
  do {
    v = Math.random() * 2**32 | 0
  } while (Math.abs(v) < 1000)
  return v
}

function uniqueArray<T>(a: T[]) {
  return Array.from(new Set(a))
}

function lerp(a: number, b: number, t: number) {
  return a + (b - a) * t
}

function interpolateSegments(arr: number[], targetS: number, maxSegments: number): number[] {
  const totalDuration = arr[arr.length - 1] - arr[0]
  const s = totalDuration / Math.min(Math.ceil(totalDuration / targetS), maxSegments)
  const result: number[] = []
  for (let i = 0; i < arr.length - 1; i++) {
    const start = arr[i]
    const len = arr[i + 1] - start
    const subdivs = Math.ceil(len / s)
    const step = len / subdivs
    result.push(start)
    for (let j = 1; j < subdivs; j++) {
      result.push(start + j * step)
    }
  }
  result.push(arr[arr.length - 1])
  return result
}

function cubicBezier(p0: number, p1: number, p2: number, p3: number, t: number) {
  const k = 1 - t
  return k * (k * k * p0 + 3 * t * (k * p1 + t * p2)) + t * t * t * p3
}

function surroundingKeyframes<K extends AnyKeyframe<T>, T extends ValueType>(keyframes: K[], position: number) {
  let max = -Infinity
  keyframes = keyframes.filter(kf => {
    if (kf.position < max) {
      return false
    } else {
      max = kf.position
      return true
    }
  })

  let prevKeyframe: K, nextKeyframe: K

  for (const kf of keyframes) {
    if (kf.position <= position) {
      prevKeyframe = kf
    } else {
      nextKeyframe = kf
      break
    }
  }

  return { prevKeyframe, nextKeyframe }
}

function stepKeyframes<T extends ValueType>(keyframes: IBasicKeyframe<T>[], position: number): TypeMap.PropertyValue[T] {
  if (keyframes.length === 1) {
    return keyframes[0].value
  }

  let nearestKeyframe: IBasicKeyframe<T>

  for (const kf of keyframes) {
    if (kf.position <= position) {
      nearestKeyframe = kf
    } else {
      break
    }
  }

  return nearestKeyframe.value
}

function lerpKeyframes<T extends ValueType>(keyframes: IBasicKeyframe<T>[], position: number): TypeMap.PropertyValue[T] {
  if (keyframes.length === 1) {
    return keyframes[0].value
  }

  const { prevKeyframe, nextKeyframe } = surroundingKeyframes(keyframes, position)

  if (!prevKeyframe) {
    return nextKeyframe.value
  } else if (!nextKeyframe) {
    return prevKeyframe.value
  }

  const t = (position - prevKeyframe.position) / (nextKeyframe.position - prevKeyframe.position)

  if (typeof prevKeyframe.value === 'number') {
    return lerp(prevKeyframe.value, nextKeyframe.value as number, t) as TypeMap.PropertyValue[T]
  } else {
    return prevKeyframe.value.map((e, i) => lerp(e, nextKeyframe.value[i], t)) as TypeMap.PropertyValue[T]
  }
}

function bezierInterpKeyframes<T extends ValueType>(keyframes: IBezierKeyframe<T>[], position: number): TypeMap.PropertyValue[T] {
  if (keyframes.length === 1) {
    return keyframes[0].value
  }

  const { prevKeyframe, nextKeyframe } = surroundingKeyframes(keyframes, position)

  if (!prevKeyframe) {
    return nextKeyframe.value
  } else if (!nextKeyframe) {
    return prevKeyframe.value
  }

  const x = (position - prevKeyframe.position) / (nextKeyframe.position - prevKeyframe.position)

  if (Array.isArray(prevKeyframe.value)) {
    return prevKeyframe.value.map((_, i) => {
      const v1 = prevKeyframe.value[i]
      const v2 = nextKeyframe.value[i]
      const t1 = prevKeyframe.p1[i]
      const t2 = nextKeyframe.p2[i]
      return cubicBezier(v1, v1 + t1 / 3, v2 - t2 / 3, v2, x)
    }) as TypeMap.PropertyValue[T]
  } else {
    const v1 = prevKeyframe.value as number
    const v2 = nextKeyframe.value as number
    const t1 = prevKeyframe.p1 as number
    const t2 = nextKeyframe.p2 as number
    return cubicBezier(v1, v1 + t1 / 3, v2 - t2 / 3, v2, x) as TypeMap.PropertyValue[T]
  }
}

const hermiteInterpKeyframes = (() => {
  /*
    This approximates the interpolation done in Curve2 properties. An exact
    calculation would be better and probably faster, but as of writing this the
    formula has not been discovered.

    Hermite interpolation requires each point to have a tangent vector, but
    these properties only have a tangent angle, so the magnitude is missing.
    This probably means it's either fixed or calculated in some way based on
    the property values and/or the angles.

    This approximation uses 9 cubic Bezier curves that closely match 9
    configurations of tangent angles. The two angles are the two axes of a 3x3
    grid of these 9 curves, and so the 4 nearest curves are found and bilinear
    interpolation is used to blend their values. The approximation is pretty
    accurate, even for values outside of its range ([0,π/2]), but it is not
    perfect. The 9 cubic Bezier curves can be tweaked to improve accuracy a
    bit, but even if those are perfect, the approximation may still not be.
  */

  const calcBezier = (a: number, b: number, t: number) => t * ((t + 3 * (a - b) * t + (3 * b - 6 * a)) * t + (3 * a))
  const getSlope = (a: number, b: number, t: number) => 3 * (t * (t + 3 * (a - b) * t + 2 * (b - 2 * a)) + a)

  function binarySubdivide(x: number, a: number, b: number, x1: number, x2: number) {
    let currentX: number, t: number, i = 0
    do {
      t = a + (b - a) / 2
      currentX = calcBezier(x1, x2, t) - x
      if (currentX > 0) {
        b = t
      } else {
        a = t
      }
    } while (Math.abs(currentX) > 1e-7 && ++i < 10)
    return t
  }

  function newtonRaphson(x: number, t: number, x1: number, x2: number) {
    for (let i = 4; i > 0; i--) {
      const currentSlope = getSlope(x1, x2, t)
      if (currentSlope === 0) {
        return t
      }
      t -= (calcBezier(x1, x2, t) - x) / currentSlope
    }
    return t
  }

  const samplesCount = 11
  const sampleStepSize = 1 / (samplesCount - 1)
  const samplesLastIndex = samplesCount - 1

  function cssCubicBezier(x1: number, y1: number, x2: number, y2: number) {
    if (x1 === y1 && x2 === y2) {
      return (x: number) => x
    }

    const samples = new Float32Array(samplesCount)
    for (var i = samplesLastIndex; i >= 0; i--) {
      samples[i] = calcBezier(x1, x2, i * sampleStepSize)
    }

    const getTForX = (x: number) => {
      let intervalStart = 0
      let i = 1

      for (; i !== samplesLastIndex && samples[i] <= x; i++) {
        intervalStart += sampleStepSize
      }
      i--

      const t = intervalStart + (x - samples[i]) * sampleStepSize / (samples[i + 1] - samples[i])

      const slope = getSlope(x1, x2, t)
      if (slope === 0) {
        return t
      } else if (slope >= 1e-3) {
        return newtonRaphson(x, t, x1, x2)
      } else {
        return binarySubdivide(x, intervalStart, intervalStart + sampleStepSize, x1, x2)
      }
    }

    return (x: number) => {
      if (x === 0 || x === 1) {
        return x
      }
      return calcBezier(y1, y2, getTForX(x))
    }
  }

  const hermiteApproxFuncs = [
    cssCubicBezier(0.3, 0.1, 0.7, 0.9),     cssCubicBezier(0.135, 0.135, 0.525, 1),    cssCubicBezier(0.015, 0.675, 0.33, 1),
    cssCubicBezier(0.475, 0, 0.865, 0.865), (x: number) => x,                          cssCubicBezier(0.015, 0.9, 0.5, 0.5),
    cssCubicBezier(0.71, 0, 0.985, 0.37),   cssCubicBezier(0.525, 0.525, 0.965, 0.07), cssCubicBezier(0.065, 1.4, 0.935, -0.4),
  ]
  function approxHermite(t1: number, t2: number, x: number) {
    const t1x2 = t1 * 2
    const t2x2 = t2 * 2
    const ix = Math.max(0, Math.min(1, Math.floor(t1x2)))
    const iy = Math.max(0, Math.min(1, Math.floor(t2x2)))
    const i = ix + 3 * iy
    const t1x2f = t1x2 - ix
    return lerp(
      lerp(hermiteApproxFuncs[i](x), hermiteApproxFuncs[i+1](x), t1x2f),
      lerp(hermiteApproxFuncs[i+3](x), hermiteApproxFuncs[i+4](x), t1x2f),
      t2x2 - iy
    )
  }

  return function hermiteInterpKeyframes<T extends ValueType>(keyframes: IHermiteKeyframe<T>[], position: number): TypeMap.PropertyValue[T] {
    if (keyframes.length === 1) {
      return keyframes[0].value
    }

    const { prevKeyframe, nextKeyframe } = surroundingKeyframes(keyframes, position)

    if (!prevKeyframe) {
      return nextKeyframe.value
    } else if (!nextKeyframe) {
      return prevKeyframe.value
    }

    const x = (position - prevKeyframe.position) / (nextKeyframe.position - prevKeyframe.position)

    if (Array.isArray(prevKeyframe.value)) {
      return prevKeyframe.value.map((_, i) => {
        const t1 = prevKeyframe.t1[i] / Math.PI * 2
        const t2 = prevKeyframe.t2[i] / Math.PI * 2
        return lerp(
          prevKeyframe.value[i],
          nextKeyframe.value[i],
          approxHermite(t1, t2, x)
        )
      }) as TypeMap.PropertyValue[T]
    } else {
      const t1 = (prevKeyframe.t1 as number) / Math.PI * 2
      const t2 = (prevKeyframe.t2 as number) / Math.PI * 2
      return lerp(
        prevKeyframe.value as number,
        nextKeyframe.value as number,
        approxHermite(t1, t2, x)
      ) as TypeMap.PropertyValue[T]
    }
  }
})()

function filterMillisecondDiffs(nums: Iterable<number>) {
  const a = Array.from(nums)
  const result: number[] = []
  const visited = new Set<number>()

  for (let i = 0; i < a.length; i++) if (!visited.has(a[i])) {
    const ai = a[i]
    let sum = ai
    let count = 1
    visited.add(ai)

    for (let j = i + 1; j < a.length; j++) {
      const aj = a[j]
      if (Math.abs(ai - aj) < 0.001) {
        sum += aj
        count++
        visited.add(aj)
      }
    }

    result.push(sum / count)
  }

  return result
}

/**
 * Multiplies one number, vector, or a property of either kind by another
 * number, vector, or property.
 * 
 * Multiplying two vectors of different dimensionalities is not supported, but
 * a vector and a scalar will work.
 * @param av1 Left operand.
 * @param av2 Right operand.
 */
function anyValueMult<T extends AnyValue>(av1: AnyValue, av2: AnyValue): T {
  // If p2 is none of these, it's invalid, likely undefined or null, it must
  // either return something or throw to avoid a recursive loop.
  if (!(
    typeof av2 === 'number' ||
    Array.isArray(av2) ||
    av2 instanceof Property
  )) {
    throw new Error('Invalid operand for anyValueMult: ' + av2)
  }

  if (typeof av1 === 'number') {
    if (av1 === 1) {
      return (av2 instanceof Property ? av2.clone() : Array.isArray(av2) ? av2.slice() : av2) as T
    } else if (typeof av2 === 'number') {
      return av1 * av2 as T
    } else if (Array.isArray(av2)) {
      return av2.map(e => e * (av1 as number)) as unknown as T
    } else if (av2 instanceof Property) {
      return av2.clone().scale(av1) as unknown as T
    }
  } else if (Array.isArray(av1)) {
    if (Array.isArray(av2)) {
      return av2.map((e, i) => e * av1[i]) as unknown as T
    } else if (av2 instanceof ValueProperty) {
      let mods = av2.modifiers
      if (av2.valueType === ValueType.Scalar) {
        mods = mods.map(mod => Modifier.vectorFromScalar(mod, (av1 as Vector).length - 1))
      }
      return new ValueProperty(
        av1.length - 1,
        anyValueMult(av1, av2.value),
        mods.map(mod => Modifier.multPropertyValue(mod, av1))
      ) as unknown as T
    } else if (av2 instanceof SequenceProperty || av2 instanceof ComponentSequenceProperty) {
      let mods = av2.modifiers
      if (av2.valueType === ValueType.Scalar) {
        mods = mods.map(mod => Modifier.vectorFromScalar(mod, (av1 as Vector).length - 1))
      }
      if (av2 instanceof SequenceProperty) {
        return new SequenceProperty(
          av1.length - 1,
          av2.function,
          av2.loop,
          av2.keyframes.map(kf => Keyframe.scale(Keyframe.copy(kf), av1 as Vector)),
          mods.map(mod => Modifier.multPropertyValue(mod, av1))
        ) as unknown as T
      } else {
        const cav2 = av2
        return new ComponentSequenceProperty(
          av2.loop,
          av1.map((c, i) => cav2.components[cav2.components.length === 1 ? 0 : i].keyframes
            .map(kf => Keyframe.scale(Keyframe.copy(kf), c))
          ) as GenComponents<IHermiteKeyframe<ValueType.Scalar>[], ValueType>,
          mods.map(mod => Modifier.multPropertyValue(mod, av1))
        ) as unknown as T
      }
    }
  } else if (av1 instanceof ValueProperty) {
    if (av2 instanceof ValueProperty) {
      const cav1 = av1
      const cav2 = av2
      let av1Mods = cav1.modifiers
      let av2Mods = cav2.modifiers
      const vt = Math.max(cav1.valueType, cav2.valueType)
      if (vt > ValueType.Scalar && cav1.valueType === ValueType.Scalar) {
        av1Mods = av1Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      if (vt > ValueType.Scalar && cav2.valueType === ValueType.Scalar) {
        av2Mods = av2Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      return new ValueProperty(vt, anyValueMult(av1.value, av2.value), [
        ...av1Mods.map(mod => Modifier.multPropertyValue(mod, cav2.value)),
        ...av2Mods.map(mod => Modifier.multPropertyValue(mod, cav1.value)),
      ]) as unknown as T
    } else if (av2 instanceof SequenceProperty) {
      const cav1 = av1
      const cav2 = av2
      let av1Mods = av1.modifiers
      let av2Mods = av2.modifiers
      const vt = Math.max(av1.valueType, av2.valueType)
      if (vt > ValueType.Scalar && av1.valueType === ValueType.Scalar) {
        av1Mods = av1Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      if (vt > ValueType.Scalar && av2.valueType === ValueType.Scalar) {
        av2Mods = av2Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      return new SequenceProperty(
        vt,
        av2.function,
        av2.loop,
        av2.keyframes.map(kf => Keyframe.scale(Keyframe.copy(kf), cav1.value)),
        [
          ...av1Mods.map(mod => Modifier.multPropertyValue(mod, cav2.valueAt(0))),
          ...av2Mods.map(mod => Modifier.multPropertyValue(mod, cav1.value)),
        ]
      ) as unknown as T
    } else if (av2 instanceof ComponentSequenceProperty) {
      const cav1 = av1
      const cav2 = av2
      let av1Mods = av1.modifiers
      let av2Mods = av2.modifiers
      const vt = Math.max(av1.valueType, av2.valueType)
      if (vt > ValueType.Scalar && av1.valueType === ValueType.Scalar) {
        av1Mods = av1Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      if (vt > ValueType.Scalar && av2.valueType === ValueType.Scalar) {
        av2Mods = av2Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      return new ComponentSequenceProperty(
        av2.loop,
        arrayOf(vt + 1, i => cav2.components[cav2.componentCount === 1 ? 0 : i].keyframes
          .map(kf => Keyframe.scale(Keyframe.copy(kf), typeof cav1.value === 'number' ? cav1.value : cav1.value[i]))
        ) as GenComponents<IHermiteKeyframe<ValueType.Scalar>[], ValueType>,
        [
          ...av1Mods.map(mod => Modifier.multPropertyValue(mod, cav2.valueAt(0))),
          ...av2Mods.map(mod => Modifier.multPropertyValue(mod, cav1.value)),
        ]
      ) as unknown as T
    }
  } else if (
    (av1 instanceof SequenceProperty || av1 instanceof ComponentSequenceProperty) &&
    (av2 instanceof SequenceProperty || av2 instanceof ComponentSequenceProperty)
  ) {
    if (av1 instanceof ComponentSequenceProperty) {
      av1 = av1.combineComponents()
    }
    if (av2 instanceof ComponentSequenceProperty) {
      av2 = av2.combineComponents()
    }
    const cav1 = av1 as SequenceProperty<any, any>
    const cav2 = av2 as SequenceProperty<any, any>
    const posSet = new Set<number>()
    for (const keyframe of cav1.keyframes) {
      posSet.add(keyframe.position)
    }
    for (const keyframe of cav2.keyframes) {
      posSet.add(keyframe.position)
    }
    const positions = filterMillisecondDiffs(posSet).sort((a, b) => a - b)
    let av1Mods = cav1.modifiers
    let av2Mods = cav2.modifiers
    const vt = Math.max(cav1.valueType, cav2.valueType)
    if (vt > ValueType.Scalar && cav1.valueType === ValueType.Scalar) {
      av1Mods = av1Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
    }
    if (vt > ValueType.Scalar && cav2.valueType === ValueType.Scalar) {
      av2Mods = av2Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
    }
    return new LinearProperty(
      cav1.loop && cav2.loop,
      (av1.function === PropertyFunction.Linear && av2.function === PropertyFunction.Linear ?
        positions :
        filterMillisecondDiffs(interpolateSegments(positions, 0.1, 40))
      ).map(e => new Keyframe(e,
        anyValueMult(cav1.valueAt(e), cav2.valueAt(e)) as PropertyValue
      ))
    ).withModifiers(
      ...av1Mods.map(mod => Modifier.multPropertyValue(mod, cav2.valueAt(0))),
      ...av2Mods.map(mod => Modifier.multPropertyValue(mod, cav1.valueAt(0))),
    ) as unknown as T
  }

  // If none of the stuff above returned, p1 is more complex than p2, so just
  // swap them and return the result of that instead.
  return anyValueMult(av2, av1)
}

/**
 * Adds one number, vector, or a property of either kind to another number,
 * vector, or property.
 * 
 * Adding two vectors of different dimensionalities is not supported, but
 * a vector and a scalar will work.
 * @param av1 Left operand.
 * @param av2 Right operand.
 */
function anyValueSum<T extends AnyValue>(av1: AnyValue, av2: AnyValue): T {
  // If p2 is none of these, it's invalid, likely undefined or null, it must
  // either return something or throw to avoid a recursive loop.
  if (!(
    typeof av2 === 'number' ||
    Array.isArray(av2) ||
    av2 instanceof Property
  )) {
    throw new Error('Invalid operand for anyValueSum: ' + av2)
  }

  if (typeof av1 === 'number') {
    if (av1 === 0) {
      return (av2 instanceof Property ? av2.clone() : Array.isArray(av2) ? av2.slice() : av2) as T
    } else if (typeof av2 === 'number') {
      return av1 + av2 as T
    } else if (Array.isArray(av2)) {
      return av2.map(e => e + (av1 as number)) as unknown as T
    } else if (av2 instanceof ValueProperty) {
      return new ValueProperty(
        av2.valueType,
        anyValueSum(av1, av2.value),
        av2.modifiers.map(mod => mod.clone())
      ) as unknown as T
    } else if (av2 instanceof SequenceProperty) {
      return new SequenceProperty(
        av2.valueType,
        av2.function,
        av2.loop,
        av2.keyframes.map(kf => Keyframe.add(Keyframe.copy(kf), (av1 as number))),
        av2.modifiers.map(mod => mod.clone())
      ) as unknown as T
    } else if (av2 instanceof ComponentSequenceProperty) {
      return new ComponentSequenceProperty(
        av2.loop,
        av2.components.map(
          c => c.keyframes.map(kf => Keyframe.add(Keyframe.copy(kf), av1 as number))
        ) as GenComponents<IHermiteKeyframe<ValueType.Scalar>[], ValueType>,
        av2.modifiers.map(mod => mod.clone())
      ) as unknown as T
    }
  } else if (Array.isArray(av1)) {
    if (Array.isArray(av2)) {
      return av2.map((e, i) => e + av1[i]) as unknown as T
    } else if (av2 instanceof ValueProperty) {
      let mods = av2.modifiers
      if (av2.valueType === ValueType.Scalar) {
        mods = mods.map(mod => Modifier.vectorFromScalar(mod, (av1 as Vector).length - 1))
      }
      return new ValueProperty(
        av1.length - 1,
        anyValueSum(av1, av2.value),
        mods.map(mod => mod.clone())
      ) as unknown as T
    } else if (av2 instanceof SequenceProperty) {
      let mods = av2.modifiers
      if (av2.valueType === ValueType.Scalar) {
        mods = mods.map(mod => Modifier.vectorFromScalar(mod, (av1 as Vector).length - 1))
      }
      return new SequenceProperty(
        av1.length - 1,
        av2.function,
        av2.loop,
        av2.keyframes.map(kf => Keyframe.add(Keyframe.copy(kf), (av1 as Vector))),
        mods.map(mod => mod.clone())
      ) as unknown as T
    } else if (av2 instanceof ComponentSequenceProperty) {
      const cav2 = av2
      let mods = cav2.modifiers
      if (cav2.valueType === ValueType.Scalar) {
        mods = mods.map(mod => Modifier.vectorFromScalar(mod, (av1 as Vector).length - 1))
      }
      return new ComponentSequenceProperty(
        cav2.loop,
        av1.map((c, i) => cav2.components[cav2.componentCount === 1 ? 0 : i].keyframes
          .map(kf => Keyframe.add(Keyframe.copy(kf), c))
        ) as GenComponents<IHermiteKeyframe<ValueType.Scalar>[], ValueType>,
        mods.map(mod => mod.clone())
      ) as unknown as T
    }
  } else if (av1 instanceof ValueProperty) {
    if (av2 instanceof ValueProperty) {
      let av1Mods = av1.modifiers
      let av2Mods = av2.modifiers
      const vt = Math.max(av1.valueType, av2.valueType)
      if (vt > ValueType.Scalar && av1.valueType === ValueType.Scalar) {
        av1Mods = av1Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      if (vt > ValueType.Scalar && av2.valueType === ValueType.Scalar) {
        av2Mods = av2Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      return new ValueProperty(vt, anyValueSum(av1.value, av2.value), [
        ...av1Mods.map(mod => mod.clone()),
        ...av2Mods.map(mod => mod.clone()),
      ]) as unknown as T
    } else if (av2 instanceof SequenceProperty) {
      let av1Mods = av1.modifiers
      let av2Mods = av2.modifiers
      const vt = Math.max(av1.valueType, av2.valueType)
      if (vt > ValueType.Scalar && av1.valueType === ValueType.Scalar) {
        av1Mods = av1Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      if (vt > ValueType.Scalar && av2.valueType === ValueType.Scalar) {
        av2Mods = av2Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      return new SequenceProperty(
        vt,
        av2.function,
        av2.loop,
        av2.keyframes.map(kf => Keyframe.add(Keyframe.copy(kf), (av1 as ValueProperty<any>).value)),
        [
          ...av1Mods.map(mod => mod.clone()),
          ...av2Mods.map(mod => mod.clone()),
        ]
      ) as unknown as T
    } else if (av2 instanceof ComponentSequenceProperty) {
      const cav1 = av1
      const cav2 = av2
      let av1Mods = cav1.modifiers
      let av2Mods = cav2.modifiers
      const vt = Math.max(cav1.valueType, cav2.valueType)
      if (vt > ValueType.Scalar && cav1.valueType === ValueType.Scalar) {
        av1Mods = av1Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      if (vt > ValueType.Scalar && cav2.valueType === ValueType.Scalar) {
        av2Mods = av2Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
      }
      return new ComponentSequenceProperty(
        cav2.loop,
        arrayOf(vt + 1, i => cav2.components[cav2.componentCount === 1 ? 0 : i].keyframes
          .map(kf => Keyframe.add(Keyframe.copy(kf), typeof cav1.value === 'number' ? cav1.value : cav1.value[i]))
        ) as GenComponents<IHermiteKeyframe<ValueType.Scalar>[], ValueType>,
        [
          ...av1Mods.map(mod => mod.clone()),
          ...av2Mods.map(mod => mod.clone()),
        ]
      ) as unknown as T
    }
  } else if (
    (av1 instanceof SequenceProperty || av1 instanceof ComponentSequenceProperty) &&
    (av2 instanceof SequenceProperty || av2 instanceof ComponentSequenceProperty)
  ) {
    if (av1 instanceof ComponentSequenceProperty) {
      av1 = av1.combineComponents()
    }
    if (av2 instanceof ComponentSequenceProperty) {
      av2 = av2.combineComponents()
    }
    const cav1 = av1 as SequenceProperty<any, any>
    const cav2 = av2 as SequenceProperty<any, any>
    const posSet = new Set<number>()
    for (const keyframe of cav1.keyframes) {
      posSet.add(keyframe.position)
    }
    for (const keyframe of cav2.keyframes) {
      posSet.add(keyframe.position)
    }
    const positions = filterMillisecondDiffs(posSet).sort((a, b) => a - b)
    let av1Mods = cav1.modifiers
    let av2Mods = cav2.modifiers
    const vt = Math.max(cav1.valueType, cav2.valueType)
    if (vt > ValueType.Scalar && cav1.valueType === ValueType.Scalar) {
      av1Mods = av1Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
    }
    if (vt > ValueType.Scalar && cav2.valueType === ValueType.Scalar) {
      av2Mods = av2Mods.map(mod => Modifier.vectorFromScalar(mod, vt))
    }
    return new LinearProperty(
      cav1.loop && cav2.loop,
      (av1.function === PropertyFunction.Linear && av2.function === PropertyFunction.Linear ?
        positions :
        filterMillisecondDiffs(interpolateSegments(positions, 0.1, 40))
      ).map(e => new Keyframe(e,
        anyValueSum(cav1.valueAt(e), cav2.valueAt(e)) as PropertyValue
      ))
    ).withModifiers(
      ...av1Mods.map(mod => mod.clone()),
      ...av2Mods.map(mod => mod.clone()),
    ) as unknown as T
  }

  // If none of the stuff above returned, p1 is more complex than p2, so just
  // swap them and return the result of that instead.
  return anyValueSum(av2, av1)
}

/**
 * Subtracts one number, vector, or a property of either kind to another
 * number, vector, or property.
 * 
 * Subtracting two vectors of different dimensionalities is not supported, but
 * a vector and a scalar will work.
 * @param av1 Left operand.
 * @param av2 Right operand.
 */
function anyValueDiff<T extends AnyValue>(av1: AnyValue, av2: AnyValue): T {
  return anyValueSum(av1, anyValueMult(-1, av2))
}

function steppedToLinearProperty<T extends ValueType>(prop: SequenceProperty<T, PropertyFunction.Stepped>) {
  return new LinearProperty(prop.loop, prop.keyframes.flatMap((kf, i, a) => [
    new Keyframe(i === 0 ? 0 : a[i].position - 0.001, kf.value),
    Keyframe.copy(kf)
  ]).slice(1, -1))
}

function combineComponents<T extends VectorValueType>(...comps: TypeMap.VectorComponents[T]): TypeMap.Value[T] {
  comps = comps.map(
    c => c instanceof SequenceProperty && c.function === PropertyFunction.Stepped ? steppedToLinearProperty(c) : c
  ) as TypeMap.VectorComponents[T]
  if (!comps.some(c => c instanceof Property)) {
    return comps as TypeMap.Value[T]
  }
  const hasCurveComp = comps.some(e =>
    e instanceof SequenceProperty && (
      e.function === PropertyFunction.Bezier ||
      e.function === PropertyFunction.Hermite
    ) ||
    e instanceof ComponentSequenceProperty
  )
  const positions = new Set<number>()
  for (const comp of comps) {
    if (comp instanceof SequenceProperty) {
      for (const keyframe of comp.keyframes) {
        positions.add(keyframe.position)
      }
    } else if (comp instanceof ComponentSequenceProperty) {
      for (const keyframe of comp.components[0].keyframes) {
        positions.add(keyframe.position)
      }
    }
  }
  function combineModifiers() {
    const origMods = comps.map(c => c instanceof Property ? c.modifiers : [])
    const mappedComps = new Set
    const out: (IModifier<ValueType.Scalar>[] | IModifier<ValueType>)[] = []
    const max = origMods.reduce((a, e) => Math.max(a, e.length), 0)
    for (let i = 0; i < max; i++) {
      for (const [j, a] of origMods.entries()) {
        const mod = a[i]
        if (!(i in a) || mappedComps.has(mod)) continue;
        mappedComps.add(mod)
        if (
          mod instanceof ExternalValue1Modifier ||
          mod instanceof ExternalValue2Modifier
        ) {
          out.push(Modifier.vectorFromScalar(mod, comps.length - 1))
          continue
        }
        const o = Array(origMods.length).with(j, mod)
        out.push(o)
        for (let k = i; k < max; k++) {
          for (const [l, b] of origMods.entries()) {
            if (
              !(k in b) || 
              l === j ||
              b[k].type !== mod.type ||
              o[l] !== undefined ||
              mappedComps.has(b[k])
            ) continue;
            o[l] = b[k]
            mappedComps.add(b[k])
          }
        }
      }
    }
    for (const o of out) {
      if (!Array.isArray(o)) continue;
      let type: ModifierType
      for (const m of o) {
        if (m !== undefined) {
          type = m.type
          break
        }
      }
      for (let i = origMods.length - 1; i >= 0; i--) {
        if (o[i] === undefined) switch (type) {
          case ModifierType.RandomDelta:
            o[i] = new RandomDeltaModifier(0, 0)
            break
          case ModifierType.RandomRange:
            o[i] = new RandomRangeModifier(0, 0, 0)
            break
          case ModifierType.RandomFraction:
            o[i] = new RandomFractionModifier(0, 0)
            break
        }
      }
    }
    return out.map(e => {
      if (!Array.isArray(e)) return e
      switch (e[0].type) {
        case ModifierType.RandomDelta:
          return new RandomDeltaModifier(
            e.map(m => (m as RandomDeltaModifier<ValueType.Scalar>).max) as TypeMap.PropertyValue[T],
            e.map(m => (m as RandomDeltaModifier<ValueType.Scalar>).seed) as TypeMap.PropertyValue[T]
          )
        case ModifierType.RandomRange:
          return new RandomRangeModifier(
            e.map(m => (m as RandomRangeModifier<ValueType.Scalar>).min) as TypeMap.PropertyValue[T],
            e.map(m => (m as RandomRangeModifier<ValueType.Scalar>).max) as TypeMap.PropertyValue[T],
            e.map(m => (m as RandomRangeModifier<ValueType.Scalar>).seed) as TypeMap.PropertyValue[T]
          )
        case ModifierType.RandomFraction:
          return new RandomFractionModifier(
            e.map(m => (m as RandomFractionModifier<ValueType.Scalar>).max) as TypeMap.PropertyValue[T],
            e.map(m => (m as RandomFractionModifier<ValueType.Scalar>).seed) as TypeMap.PropertyValue[T]
          )
      }
    }) as IModifier<T>[]
  }
  if (positions.size >= 2) {
    const keyframes: Keyframe<T>[] = (hasCurveComp ?
      filterMillisecondDiffs(interpolateSegments(Array.from(positions).sort((a, b) => a - b), 0.1, 40)) :
      Array.from(positions).sort((a, b) => a - b)
    ).map(e => new Keyframe(e, comps.map(c => c instanceof Property ? c.valueAt(e) : c) as TypeMap.PropertyValue[T]))
    return new LinearProperty<T>(
      comps.some(e => (e instanceof SequenceProperty || e instanceof ComponentSequenceProperty) && e.loop),
      keyframes
    ).withModifiers(...combineModifiers()) as unknown as TypeMap.Property[T]
  } else {
    return new ConstantProperty<T>(
      comps.map(c => c instanceof Property ? c.valueAt(0) : c) as TypeMap.PropertyValue[T]
    ).withModifiers(...combineModifiers()) as unknown as TypeMap.Property[T]
  }
}

function separateComponents<T extends VectorValueType>(value: TypeMap.Value[T]): TypeMap.VectorComponents[T] {
  if (value instanceof Property) {
    return value.separateComponents() as TypeMap.VectorComponents[T]
  } else {
    return value as TypeMap.PropertyValue[T]
  }
}

function fieldsCount(fields: Field<FieldType>[]) {
  let count = 0
  for (const field of fields) count += fieldCompCount[field.type]
  return count
}

function getComponentCount(v: AnyValue | boolean): 1 | 2 | 3 | 4 {
  const cc = isVector(v) ? v.length : isVectorValue(v) ? v.componentCount : 1
  if (cc < 1 || cc > 4) {
    throw new Error('Invalid value.')
  }
  return cc
}

/**
 * Gets the {@link ValueType} of a given value.
 * @param v The value to get the type of.
 */
function getValueType<T extends ValueType>(v: TypeMap.Property[T] | TypeMap.PropertyValue[T]): T {
  return (getComponentCount(v) - 1) as T
}

function setVectorComponent(vec: VectorValue, componentIndex: number, value: ScalarValue): VectorValue {
  const cc = getComponentCount(vec)
  return anyValueSum(
    combineComponents(...Array(cc).fill(0).with(componentIndex, value) as VectorComponents),
    anyValueMult(
      Array(cc).fill(1).with(componentIndex, 0) as VectorValue,
      vec
    )
  )
}

function isVector(v: any): v is Vector {
  return Array.isArray(v) && v.length > 1 && v.length <= 4
}

function isScalarValue(v: any): v is ScalarValue {
  return (
    typeof v === 'number' ||
    v instanceof Property && v.valueType === ValueType.Scalar
  )
}

function isVectorValue(v: any): v is VectorValue {
  return (
    (Array.isArray(v) && v.length > 1 && v.length <= 4) ||
    v instanceof Property && v.valueType !== ValueType.Scalar
  )
}

function mod(n: number, d: number) {
  return ((n % d) + d) % d
}

function rgbToHsv(r: number, g: number, b: number): Vector3 {
  const min = Math.min(r, g, b)
  const max = Math.max(r, g, b)
  const delta = max - min
  let h: number = 0, s: number = 0
  if (delta !== 0) {
    s = delta / max
    const dr = (((max - r) / 6) + (delta / 2)) / delta
    const dg = (((max - g) / 6) + (delta / 2)) / delta
    const db = (((max - b) / 6) + (delta / 2)) / delta
    switch (max) {
      case r: h = db - dg; break;
      case g: h = (1 / 3) + dr - db; break;
      case b: h = (2 / 3) + dg - dr; break;
    }
    h = mod(h, 1)
  }
  return [h, s, max]
}

function hsvToRgb(h: number, s: number, v: number): Vector3 {
  let r: number = v, g: number = v, b: number = v
  if (s !== 0) {
    const vh = mod(h * 6, 6)
    const ih = Math.floor(vh)
    const v1 = v * (1 - s)
    const v2 = v * (1 - s * (vh - ih))
    const v3 = v * (1 - s * (1 - (vh - ih)))
    switch (ih) {
      case 0: r = v  ; g = v3 ; b = v1; break;
      case 1: r = v2 ; g = v  ; b = v1; break;
      case 2: r = v1 ; g = v  ; b = v3; break;
      case 3: r = v1 ; g = v2 ; b = v ; break;
      case 4: r = v3 ; g = v1 ; b = v ; break;
      case 5: r = v  ; g = v1 ; b = v2; break;
    }
  }
  return [r, g, b]
}

/**
 * A template tag function for converting hexadecimal color codes to
 * {@link Vector4} colors. Here are some examples of how it can be used:
 * ```js
 * // Regular 6-digit format:
 * hex`FF0000` // Red, is converted to [1, 0, 0, 1]
 * 
 * // Short 3-digit format:
 * hex`F00` // Red, equivalent to FF0000
 * 
 * // 8- and 4-digit formats for controlling the alpha value:
 * hex`00FF007F` // Half-transparent green
 * hex`FF0F` // Opaque yellow, equivalent to FFFF00
 * 
 * // The color codes are case-insensitive:
 * hex`58f` // Sky blue, equivalent to 5588FF
 * hex`fF0eaB` // Magenta, equivalent to FF0EAB
 * 
 * // Usage in properties:
 * new LinearProperty(true, [
 *   new Keyframe(0, hex`f00`),
 *   new Keyframe(1, hex`0f0`),
 *   new Keyframe(2, hex`00f`),
 *   new Keyframe(3, hex`f00`),
 * ])
 * ```
 */
function hex(strings: TemplateStringsArray, ...values: any[]): Vector4 {
  let hexStr = strings
    .reduce((result, str, i) => result + str + (values[i] || ''), '')
    .replace(/^#/, '')
  if (hexStr.length === 3) {
    hexStr = hexStr.split('').map(char => char + char).join('')
  } else if (hexStr.length === 4) {
    hexStr = hexStr.split('').map(char => char + char).join('')
  } else if (hexStr.length !== 6 && hexStr.length !== 8) {
    throw new Error(`Invalid hex color string length: ${hexStr}`)
  }
  const r = parseInt(hexStr.slice(0, 2), 16) / 255
  const g = parseInt(hexStr.slice(2, 4), 16) / 255
  const b = parseInt(hexStr.slice(4, 6), 16) / 255
  const a = hexStr.length === 8 ? parseInt(hexStr.slice(6, 8), 16) / 255 : 1
  return [r, g, b, a]
}

function randomItem<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)]
}

function averagePaletteEntries<T extends Recolor.ColorPalette[keyof Recolor.ColorPalette]>(entries: T): T {
  if (entries.length === 1) {
    return entries
  }
  const obj: { [x: string]: any } = {}
  for (const entry of entries) {
    for (const p of Object.keys(entry)) {
      obj[p] = anyValueSum(obj[p] ?? 0, entry[p])
    }
  }
  for (const p of Object.keys(obj)) {
    obj[p] = anyValueMult(1 / entries.length, obj[p])
  }
  return [obj] as T
}

function assertValidFXRID(id: number) {
  if (id < 0 || id >= 1e9) {
    throw new Error(
      `FXR ID out of range: ${id} - The ID must be a positive integer less than ${1e9.toLocaleString()}.`
    )
  }
  if (id !== Math.trunc(id)) {
    throw new Error(
      `Non-integer FXR ID: ${id} - The ID must be a positive integer less than ${1e9.toLocaleString()}.`
    )
  }
}

function normalizeVector3([x, y, z]: Vector3): Vector3 {
  const l = Math.sqrt(x * x + y * y + z * z)
  return [
    x / l,
    y / l,
    z / l,
  ]
}

function constantValueOf(v: AnyValue) {
  return v instanceof Property ? v.valueAt(0) : v
}

function scalePropMods<T extends ValueType>(prop: Property<T, PropertyFunction>, factor: TypeMap.PropertyValue[T] | number) {
  for (let i = prop.modifiers.length - 1; i >= 0; i--) {
    prop.modifiers[i] = Modifier.multPropertyValue(prop.modifiers[i], factor)
  }
}

function clampPropValue<T extends PropertyValue>(v: T, min: T, max: T): T {
  if (Array.isArray(v) && Array.isArray(min) && Array.isArray(max)) {
    return v.map((e, i) => Math.max(min[i], Math.min(max[i], e))) as T
  } else if (!Array.isArray(v) && !Array.isArray(min) && !Array.isArray(max)) {
    return Math.max(min, Math.min(max, v)) as T
  } else {
    throw new Error('Invalid property type inputs.')
  }
}

function lerpPropValue<T extends PropertyValue>(v1: T, v2: T, t: number): T {
  if (isVector(v1) && isVector(v2)) {
    return v1.map((e, i) => lerp(e, v2[i], t)) as T
  } else if (typeof v1 === 'number' && typeof v2 === 'number') {
    return lerp(v1, v2, t) as T
  } else {
    throw new Error('')
  }
}

function findIntersections<T extends ValueType>(
  keyframe1: Keyframe<T>,
  keyframe2: Keyframe<T>,
  minValue: TypeMap.PropertyValue[T],
  maxValue: TypeMap.PropertyValue[T]
): Keyframe<T>[] {
  const { position: x1, value: y1 } = keyframe1
  const { position: x2, value: y2 } = keyframe2

  if (y1 === y2) {
    return []
  }

  function interpolate(y1: number, y2: number, minValue: number, maxValue: number) {
    const slope = (y2 - y1) / (x2 - x1)
    const positions: number[] = []

    const tMin = (minValue - y1) / slope
    if (tMin > 0 && tMin < (x2 - x1)) {
      const xMin = x1 + tMin
      if (xMin >= x1 && xMin <= x2) {
        positions.push(xMin)
      }
    }

    const tMax = (maxValue - y1) / slope
    if (tMax > 0 && tMax < (x2 - x1)) {
      const xMax = x1 + tMax
      if (xMax >= x1 && xMax <= x2) {
        positions.push(xMax)
      }
    }

    return positions
  }

  const results: Keyframe<T>[] = []
  if (typeof y1 === 'number' && typeof y2 === 'number') {
    const positions = interpolate(y1, y2, minValue as number, maxValue as number)
    results.push(...positions.map(x => new Keyframe(x, clampPropValue(lerpPropValue(y1, y2, (x - x1) / (x2 - x1)), minValue, maxValue))))
  } else if (Array.isArray(y1) && Array.isArray(y2)) {
    const comps = y1.length
    for (let c = 0; c < comps; c++) {
      const positions = interpolate(y1[c], y2[c], minValue[c], maxValue[c])
      results.push(...positions.map(x => new Keyframe(x, clampPropValue(lerpPropValue(y1, y2, (x - x1) / (x2 - x1)), minValue, maxValue))))
    }
  }
  return results
}

function clampKeyframes<T extends ValueType>(
  keyframes: Keyframe<T>[],
  min: TypeMap.PropertyValue[T],
  max: TypeMap.PropertyValue[T]
): Keyframe<T>[] {
  const clampedKeyframes: Keyframe<T>[] = []
  for (let i = 0; i < keyframes.length - 1; i++) {
    const kf1 = keyframes[i]
    clampedKeyframes.push(
      new Keyframe(kf1.position, clampPropValue(kf1.value, min, max)),
      ...findIntersections(kf1, keyframes[i + 1], min, max)
    )
  }
  const lastKeyframe = keyframes[keyframes.length - 1]
  clampedKeyframes.push(new Keyframe(lastKeyframe.position, clampPropValue(lastKeyframe.value, min, max)))
  return clampedKeyframes
}

function clampProp<T extends ValueType>(
  prop: Property<T, PropertyFunction>,
  min: TypeMap.PropertyValue[T],
  max: TypeMap.PropertyValue[T]
): Property<T, PropertyFunction> {
  let clone = prop.clone().minify()
  if (clone instanceof ValueProperty) {
    clone.value = clampPropValue(clone.value, min, max)
  } else if (clone instanceof SequenceProperty || clone instanceof ComponentSequenceProperty) {
    if (clone instanceof ComponentSequenceProperty) {
      clone = clone.combineComponents()
    }
    let seq = clone as SequenceProperty<T, SequencePropertyFunction>
    if (seq.function !== PropertyFunction.Stepped && seq.function !== PropertyFunction.Linear) {
      const posSet = new Set<number>()
      for (const keyframe of seq.keyframes) {
        posSet.add(keyframe.position)
      }
      const positions = filterMillisecondDiffs(posSet).sort((a, b) => a - b)
      seq = new LinearProperty(
        seq.loop,
        filterMillisecondDiffs(interpolateSegments(positions, 0.1, 40))
          .map(e => new Keyframe(e, seq.valueAt(e)))
      )
    }
    if (seq.function === PropertyFunction.Stepped) {
      for (const kf of seq.keyframes) {
        kf.value = clampPropValue(kf.value, min, max)
      }
    } else {
      seq.keyframes = clampKeyframes(seq.keyframes, min, max)
    }
    seq.sortKeyframes()
    clone = seq
  }
  return clone.minify()
}

const FLOAT32_EPSILON = 2 ** -23
function f32Equal(a: number, b: number) {
  return Math.abs(a - b) <= FLOAT32_EPSILON
}

function propValueEqual(a: PropertyValue, b: PropertyValue) {
  if (isVector(a) && isVector(b)) {
    return a.every((e, i) => f32Equal(e, b[i]))
  } else if (!isVector(a) && !isVector(b)) {
    return f32Equal(a, b)
  }
  return false
}

function anyMatch<T>(iterator: Iterable<T>, predicate: (value: T) => boolean): boolean {
  for (const value of iterator) {
    if (predicate(value)) {
      return true
    }
  }
  return false
}

/**
 * Generates a random scalar seed.
 * 
 * The function can be useful together with the randomization modifiers for
 * properties:
 * - {@link RandomDeltaModifier}
 * - {@link RandomRangeModifier}
 * - {@link RandomFractionModifier}
 * 
 * Or the functions that generate simple properties with these modifiers:
 * - {@link RandomDeltaProperty}
 * - {@link RandomRangeProperty}
 * - {@link RandomFractionProperty}
 * 
 * To link multiple random values, so that they change the same amount if
 * randomized at the same time, you can use this function to generate a seed
 * that you can use multiple times. For example:
 * ```js
 * const seed = randomSeed()
 * new PointLight({
 *   separateSpecular: true,
 *   diffuseMultiplier: RandomDeltaProperty(1, 5, seed),
 *   specularMultiplier: RandomDeltaProperty(1, 5, seed),
 * })
 * ```
 * Here, the point light that was created will randomize to have the same
 * specular multiplier as its diffuse multiplier. This example is not the best, because
 * this could also have been done by setting
 * {@link PointLight.separateSpecular separateSpecular} to false, but it
 * should at least show how this functions.
 */
function randomSeed(): number

/**
 * Generates a random seed of the given type.
 * 
 * The function can be useful together with the randomization modifiers for
 * properties:
 * - {@link RandomDeltaModifier}
 * - {@link RandomRangeModifier}
 * - {@link RandomFractionModifier}
 * 
 * Or the functions that generate simple properties with these modifiers:
 * - {@link RandomDeltaProperty}
 * - {@link RandomRangeProperty}
 * - {@link RandomFractionProperty}
 * 
 * To link multiple random values, so that they change the same amount if
 * randomized at the same time, you can use this function to generate a seed
 * that you can use multiple times. For example:
 * ```js
 * const seed = randomSeed(ValueType.Vector4)
 * new PointLight({
 *   separateSpecular: true,
 *   diffuseColor: RandomDeltaProperty([1, 1, 1, 1], [0.5, 0.5, 0.5, 0], seed),
 *   specularColor: RandomDeltaProperty([1, 1, 1, 1], [0.5, 0.5, 0.5, 0], seed),
 * })
 * ```
 * Here, the point light that was created will randomize to have the same
 * specular color as its diffuse color. This example is not the best, because
 * this could also have been done by setting
 * {@link PointLight.separateSpecular separateSpecular} to false, but it
 * should at least show how this functions.
 * @param type The type of seed to generate.
 */
function randomSeed(type: ValueType): TypeMap.PropertyValue[typeof type]
function randomSeed(type: ValueType = ValueType.Scalar): TypeMap.PropertyValue[typeof type] {
  switch (type) {
    case ValueType.Scalar: return randomInt32()
    case ValueType.Vector2: return [randomInt32(), randomInt32()]
    case ValueType.Vector3: return [randomInt32(), randomInt32(), randomInt32()]
    case ValueType.Vector4: return [randomInt32(), randomInt32(), randomInt32(), randomInt32()]
    default: throw new Error(`Invalid value type: ${type}`)
  }
}

function validateDataActionProp(container: any, name: string, prop: ActionDataProp) {
  if (!(container[name] instanceof Property) && typeof container[name] !== typeof prop.default) {
    throw new Error(`${ActionType[container.type]}.${name} is not of the correct type.`)
  }

  if ('s10' in prop) {
    if (!Array.isArray(container[name]) || container[name].some(e => typeof e !== 'number')) {
      throw new Error(`${ActionType[container.type]}.${name} must be an array of numbers.`)
    }
    return
  }

  const cc = getComponentCount(container[name])
  const defCC = getComponentCount(prop.default)
  if (cc !== defCC) {
    throw new Error(`${ActionType[container.type]}.${name} has ${cc} components, but is expected to have ${defCC}.`)
  }
}

function clampVector<T extends Vector>(v: T, min: T, max: T): T {
  return v.map((e, i) => Math.max(min[i], Math.min(max[i], e))) as T
}

function clampVec4Value(v: Vector4Value, min: Vector4 = [0, 0, 0, 0], max: Vector4 = [1, 1, 1, 1]) {
  return v instanceof Property ? v.clamp(min, max) : clampVector(v, min, max)
}

function genFilledPaletteAndFunctions(inputPalette: Recolor.ColorPalette) {
  if (!(
    'commonParticleNormal' in inputPalette ||
    'commonParticleMultiply' in inputPalette ||
    'commonParticleAdd' in inputPalette ||
    'commonParticleSubtract' in inputPalette ||
    'distortionParticle' in inputPalette ||
    'blurParticle' in inputPalette ||
    'light' in inputPalette ||
    'gpuParticle' in inputPalette ||
    'lensFlare' in inputPalette
  )) {
    throw new Error('Invalid color palette.')
  }
  const palette: Recolor.ColorPalette = {}
  for (const [k, v] of Object.entries(inputPalette) as Entries<Recolor.ColorPalette>) switch (k) {
    case 'commonParticleNormal':
    case 'commonParticleMultiply':
    case 'commonParticleAdd':
    case 'commonParticleSubtract':
      palette[k] = v.map(e => ({
        modifier: Property.fromJSON(e.modifier),
        color1: Property.fromJSON(e.color1),
        color2: Property.fromJSON(e.color2),
        color3: Property.fromJSON(e.color3),
        rgbMultiplier: Property.fromJSON(e.rgbMultiplier),
        bloomColor: e.bloomColor,
      }))
      break
    case 'distortionParticle':
    case 'blurParticle':
      palette[k] = v.map(e => ({
        modifier: Property.fromJSON(e.modifier),
        color: Property.fromJSON(e.color),
        rgbMultiplier: Property.fromJSON(e.rgbMultiplier),
        bloomColor: e.bloomColor,
      }))
      break
    case 'light':
      palette[k] = v.map(e => ({
        diffuseColor: Property.fromJSON(e.diffuseColor),
        diffuseMultiplier: Property.fromJSON(e.diffuseMultiplier),
        ...'specularColor' in e && {
          specularColor: Property.fromJSON(e.specularColor),
          specularMultiplier: Property.fromJSON(e.specularMultiplier),
        }
      }))
      break
    case 'gpuParticle':
      palette[k] = v.map(e => ({
        color: Property.fromJSON(e.color),
        rgbMultiplier: e.rgbMultiplier,
        colorMin: e.colorMin,
        colorMax: e.colorMax,
        ...'bloomColor' in e && {
          bloomColor: e.bloomColor
        }
      }))
      break
    case 'lensFlare':
      palette[k] = v.map(e => ({
        color: Property.fromJSON(e.color),
        colorMultiplier: e.colorMultiplier,
        bloomColor: e.bloomColor,
      }))
      break
  }

  // Set up fallbacks for missing palette entries
  if (!('commonParticleNormal' in palette)) {
    if (
      'commonParticleMultiply' in palette ||
      'commonParticleAdd' in palette ||
      'commonParticleSubtract' in palette
    ) {
      palette.commonParticleNormal =
        palette.commonParticleMultiply ??
        palette.commonParticleAdd ??
        palette.commonParticleSubtract
    } else if ('gpuParticle' in palette) {
      const e = averagePaletteEntries(palette.gpuParticle)[0]
      palette.commonParticleNormal = [{
        modifier: new ConstantProperty([1, 1, 1, 1]),
        color1: new ConstantProperty([1, 1, 1, 1]),
        color2: new ConstantProperty([1, 1, 1, 1]),
        color3: e.color,
        bloomColor: e.bloomColor ?? [1, 1, 1, 1],
        rgbMultiplier: new ConstantProperty(e.rgbMultiplier),
      }]
    } else if ('lensFlare' in palette) {
      const e = averagePaletteEntries(palette.lensFlare)[0]
      palette.commonParticleNormal = [{
        modifier: new ConstantProperty([1, 1, 1, 1]),
        color1: new ConstantProperty([1, 1, 1, 1]),
        color2: new ConstantProperty([1, 1, 1, 1]),
        color3: e.color,
        bloomColor: e.bloomColor,
        rgbMultiplier: new ConstantProperty(Math.max(...e.colorMultiplier.slice(0, 3))),
      }]
    } else if ('distortionParticle' in palette) {
      const e = averagePaletteEntries(palette.distortionParticle)[0]
      palette.commonParticleNormal = [{
        modifier: e.modifier,
        color1: new ConstantProperty([1, 1, 1, 1]),
        color2: new ConstantProperty([1, 1, 1, 1]),
        color3: e.color,
        bloomColor: e.bloomColor,
        rgbMultiplier: e.rgbMultiplier,
      }]
    } else if ('blurParticle' in palette) {
      const e = averagePaletteEntries(palette.blurParticle)[0]
      palette.commonParticleNormal = [{
        modifier: e.modifier,
        color1: new ConstantProperty([1, 1, 1, 1]),
        color2: new ConstantProperty([1, 1, 1, 1]),
        color3: e.color,
        bloomColor: e.bloomColor,
        rgbMultiplier: e.rgbMultiplier,
      }]
    } else if ('light' in palette) {
      const e = averagePaletteEntries(palette.light)[0]
      palette.commonParticleNormal = [{
        modifier: new ConstantProperty([1, 1, 1, 1]),
        color1: new ConstantProperty([1, 1, 1, 1]),
        color2: new ConstantProperty([1, 1, 1, 1]),
        color3: e.diffuseColor,
        bloomColor: [1, 1, 1, 0],
        rgbMultiplier: e.diffuseMultiplier,
      }]
    }
  }
  palette.commonParticleMultiply ??= palette.commonParticleNormal
  palette.commonParticleAdd ??= palette.commonParticleNormal
  palette.commonParticleSubtract ??= palette.commonParticleNormal
  let avgCommonNormal: Recolor.PaletteSlots['CommonParticle']
  if (!('distortionParticle' in palette)) {
    avgCommonNormal ??= averagePaletteEntries(palette.commonParticleNormal)[0]
    palette.distortionParticle = [{
      modifier: new ConstantProperty([1, 1, 1, 1]),
      color: new ConstantProperty([1, 1, 1, 1]),
      rgbMultiplier: 1,
      bloomColor: [1, 1, 1, 0]
    }]
  }
  palette.blurParticle ??= palette.distortionParticle
  if (!('light' in palette)) {
    avgCommonNormal ??= averagePaletteEntries(palette.commonParticleNormal)[0]
    palette.light = [{
      diffuseColor: anyValueMult(
        anyValueMult(
          avgCommonNormal.color1,
          avgCommonNormal.color2
        ),
        avgCommonNormal.color3,
      ),
      diffuseMultiplier: avgCommonNormal.rgbMultiplier,
    }]
  }
  if (!('gpuParticle' in palette)) {
    avgCommonNormal ??= averagePaletteEntries(palette.commonParticleNormal)[0]
    palette.gpuParticle = [{
      color: anyValueMult(
        anyValueMult(
          avgCommonNormal.color1,
          avgCommonNormal.color2
        ),
        avgCommonNormal.color3,
      ),
      rgbMultiplier: avgCommonNormal.rgbMultiplier.valueAt(0),
      colorMin: [0, 0, 0, 0],
      colorMax: [0, 0, 0, 0],
      bloomColor: avgCommonNormal.bloomColor,
    }]
  }
  if (!('lensFlare' in palette)) {
    avgCommonNormal ??= averagePaletteEntries(palette.commonParticleNormal)[0]
    palette.lensFlare = [{
      color: anyValueMult(
        anyValueMult(
          avgCommonNormal.color1,
          avgCommonNormal.color2
        ),
        avgCommonNormal.color3,
      ),
      colorMultiplier: [1, 1, 1, 1],
      bloomColor: avgCommonNormal.bloomColor,
    }]
  }

  function durationFallback(action: any, secondary?: any) {
    if (!(action instanceof NodeAttributes || action instanceof ParticleAttributes)) {
      action = { duration: 1 }
    }
    if (!(secondary instanceof NodeAttributes || secondary instanceof ParticleAttributes)) {
      secondary = { duration: 1 }
    }
    return () => {
      let d = action.duration instanceof Property ?
        action.duration.valueAt(0) :
        action.duration
      if (d <= 0) {
        d = secondary.duration instanceof Property ?
          secondary.duration.valueAt(0) :
          secondary.duration
      }
      if (d <= 0) {
        d = 1
      }
      return d
    }
  }

  function proc<T>(
    paletteProp: AnyValue,
    c: T,
    k: keyof T,
    durationFallback: () => number = () => 1
  ) {
    if (k === 'bloomColor') {
      ;(c[k] as any) = (paletteProp as Vector4).with(3, Math.min(1, paletteProp[3]) * c[k][3]) as Vector4
    } else if (
      paletteProp instanceof SequenceProperty ||
      paletteProp instanceof ComponentSequenceProperty
    ) {
      const d = (
        c[k] instanceof SequenceProperty ||
        c[k] instanceof ComponentSequenceProperty ?
          c[k].duration :
          durationFallback()
      )
      let alpha: ScalarValue
      if (isVectorValue(c[k]) && getComponentCount(c[k] as AnyValue) === 4) {
        alpha = separateComponents(c[k])[3]
      }
      ;(c[k] as any) = paletteProp.clone()
      ;(c[k] as any).duration = d
      if (isVectorValue(c[k]) && getComponentCount(c[k] as AnyValue) === 4) {
        ;(c[k] as any) = setVectorComponent(c[k] as any, 3, alpha)
      }
      if (c[k] instanceof Property) {
        ;(c[k] as VectorProperty) = c[k].minify()
      }
    } else {
      if (isVectorValue(c[k])) {
        ;(c[k] as VectorValue) = setVectorComponent(
          (
            paletteProp instanceof Property ? paletteProp.clone() :
            (paletteProp as Vector).slice()
          ) as VectorValue,
          3, separateComponents(c[k])[3]
        )
        if (c[k] instanceof Property) {
          ;(c[k] as VectorProperty) = c[k].minify()
        }
      } else {
        ;(c[k] as any) = (
          paletteProp instanceof Property ? paletteProp.clone() :
          paletteProp
        )
      }
    }
  }

  return { palette, durationFallback, proc }
}

function valueWithType<T extends ValueType>(type: T, val: number): TypeMap.PropertyValue[T] {
  return (type === ValueType.Scalar ? val : arrayOf(type + 1, () => val)) as TypeMap.PropertyValue[T]
}

function isNodeArray<T>(list: T | Node[]): list is Node[] {
  return list[0] instanceof Node
}

function getLoop(prop: AnyValue): boolean {
  if (prop instanceof SequenceProperty || prop instanceof ComponentSequenceProperty) {
    return prop.loop
  }
  return false
}

function setLoop(prop: AnyValue, loop: boolean): AnyValue {
  if (prop instanceof SequenceProperty || prop instanceof ComponentSequenceProperty) {
    prop.loop = loop
  }
  return prop
}

const GameVersionMap = {
  [Game.DarkSouls3]: FXRVersion.DarkSouls3,
  [Game.Sekiro]: FXRVersion.Sekiro,
  [Game.EldenRing]: FXRVersion.Sekiro,
  [Game.ArmoredCore6]: FXRVersion.Sekiro,
  [Game.Nightreign]: FXRVersion.Sekiro,
}

const ActionDataConversion: Partial<Record<ActionType, ActionDataConversionEntry<any>>> = {
  [ActionType.StaticNodeTransform]: {
    read(props: Props<StaticNodeTransform>, game: Game) {
      props.offset[0] *= -1
      props.rotation[0] *= -1
      return props
    },
    write(props: Props<StaticNodeTransform>, game: Game) {
      props.offset[0] *= -1
      props.rotation[0] *= -1
      return props
    },
    minify(this: StaticNodeTransform): AnyAction {
      if (
        this.offset.every(e => e === 0) &&
        this.rotation.every(e => e === 0)
      ) {
        return new Action
      }
      return this
    }
  },
  [ActionType.RandomNodeTransform]: {
    read(props: Props<RandomNodeTransform>, game: Game) {
      props.offset[0] *= -1
      return props
    },
    write(props: Props<RandomNodeTransform>, game: Game) {
      props.offset[0] *= -1
      return props
    },
    minify(this: RandomNodeTransform): AnyAction {
      if (
        this.offsetVariance.every(e => e === 0) &&
        this.rotationVariance.every(e => e === 0)
      ) {
        return ActionDataConversion[ActionType.StaticNodeTransform].minify.call(
          new StaticNodeTransform(this).assign({
            // For some reason, StaticNodeTransform flips the X rotation, but
            // this one doesn't, even though the X offset is flipped in both.
            rotation: [-this.rotation[0], this.rotation[1], this.rotation[2]]
          })
        )
      }
      return this
    }
  },
  [ActionType.ParticleSpeedRandomTurns]: {
    read(props: Props<ParticleSpeedRandomTurns>, game: Game) {
      props.turnInterval = props.turnInterval / 50
      return props
    },
    write(props: Props<ParticleSpeedRandomTurns>, game: Game) {
      props.turnInterval = Math.round(props.turnInterval * 50)
      return props
    }
  },
  [ActionType.ParticleSpeedPartialFollow]: {
    read(props: Props<ParticleSpeedPartialFollow>, game: Game) {
      props.turnInterval = props.turnInterval / 50
      props.followRotation = !props.followRotation
      return props
    },
    write(props: Props<ParticleSpeedPartialFollow>, game: Game) {
      props.turnInterval = Math.round(props.turnInterval * 50)
      props.followRotation = !props.followRotation
      return props
    }
  },
  [ActionType.NodeAccelerationRandomTurns]: {
    read(props: Props<NodeAccelerationRandomTurns>, game: Game) {
      props.turnInterval = props.turnInterval / 50
      return props
    },
    write(props: Props<NodeAccelerationRandomTurns>, game: Game) {
      props.turnInterval = Math.round(props.turnInterval * 50)
      return props
    }
  },
  [ActionType.ParticleAccelerationRandomTurns]: {
    read(props: Props<ParticleAccelerationRandomTurns>, game: Game) {
      props.turnInterval = props.turnInterval / 50
      return props
    },
    write(props: Props<ParticleAccelerationRandomTurns>, game: Game) {
      props.turnInterval = Math.round(props.turnInterval * 50)
      return props
    }
  },
  [ActionType.ParticleAccelerationPartialFollow]: {
    read(props: Props<ParticleAccelerationPartialFollow>, game: Game) {
      props.turnInterval = props.turnInterval / 50
      props.followRotation = !props.followRotation
      return props
    },
    write(props: Props<ParticleAccelerationPartialFollow>, game: Game) {
      props.turnInterval = Math.round(props.turnInterval * 50)
      props.followRotation = !props.followRotation
      return props
    }
  },
  [ActionType.NodeAccelerationPartialFollow]: {
    read(props: Props<NodeAccelerationPartialFollow>, game: Game) {
      props.turnInterval = props.turnInterval / 50
      props.followRotation = !props.followRotation
      return props
    },
    write(props: Props<NodeAccelerationPartialFollow>, game: Game) {
      props.turnInterval = Math.round(props.turnInterval * 50)
      props.followRotation = !props.followRotation
      return props
    }
  },
  [ActionType.NodeSpeedRandomTurns]: {
    read(props: Props<NodeSpeedRandomTurns>, game: Game) {
      props.turnInterval = props.turnInterval / 50
      return props
    },
    write(props: Props<NodeSpeedRandomTurns>, game: Game) {
      props.turnInterval = Math.round(props.turnInterval * 50)
      return props
    }
  },
  [ActionType.NodeSpeedPartialFollow]: {
    read(props: Props<NodeSpeedPartialFollow>, game: Game) {
      props.turnInterval = props.turnInterval / 50
      props.followRotation = !props.followRotation
      return props
    },
    write(props: Props<NodeSpeedPartialFollow>, game: Game) {
      props.turnInterval = Math.round(props.turnInterval * 50)
      props.followRotation = !props.followRotation
      return props
    }
  },
  [ActionType.StateConfigMap]: {
    minify(this: StateConfigMap): StateConfigMap {
      if (this.configIndices.length > 1 && this.configIndices.every(e => e === 0)) {
        return new StateConfigMap
      }
      return this
    }
  },
  [ActionType.Distortion]: {
    read(props: Props<Distortion>, game: Game) {
      props.stirSpeed = anyValueMult(180 / Math.PI, props.stirSpeed)
      return props
    },
    write(props: Props<Distortion>, game: Game) {
      props.stirSpeed = anyValueMult(Math.PI / 180, props.stirSpeed)
      return props
    }
  },
  [ActionType.PointLight]: {
    read(props: Props<PointLight>, game: Game) {
      props.fadeOutTime = props.fadeOutTime / 30
      if (game === Game.DarkSouls3) {
        props.diffuseMultiplier = 10
        props.specularMultiplier = 10
      }
      return props
    },
    write(props: Props<PointLight>, game: Game) {
      props.fadeOutTime = Math.round(props.fadeOutTime * 30)
      if (game === Game.DarkSouls3) {
        const diffuseComps = separateComponents(props.diffuseColor)
        props.diffuseColor = combineComponents<ValueType.Vector4>(
          ...diffuseComps.slice(0, 3) as Vector3Components,
          anyValueMult(diffuseComps[3], anyValueMult(1/10, props.diffuseMultiplier))
        ) as Vector4Value
        const specularComps = separateComponents(props.specularColor)
        props.specularColor = combineComponents<ValueType.Vector4>(
          ...specularComps.slice(0, 3) as Vector3Components,
          anyValueMult(specularComps[3], anyValueMult(1/10, props.specularMultiplier))
        ) as Vector4Value
      }
      return props
    }
  },
  [ActionType.RichModel]: {
    read(props: any, game: Game) {
      if (game === Game.EldenRing) {
        props.offsetUV = combineComponents(props.offsetU, props.offsetV)
        props.speedUV = combineComponents(props.speedU, props.speedV)
        props.speedMultiplierUV = combineComponents(props.speedMultiplierU, props.speedMultiplierV)
      }
      return props
    },
    write(props: any, game: Game) {
      if (game === Game.EldenRing) {
        ;[props.offsetU, props.offsetV] = separateComponents(props.offsetUV)
        ;[props.speedU, props.speedV] = separateComponents(props.speedUV)
        ;[props.speedMultiplierU, props.speedMultiplierV] = separateComponents(props.speedMultiplierUV)
      }
      return props
    }
  },
  [ActionType.GPUStandardParticle]: {
    read(props: Props<GPUStandardParticle>, game: Game) {
      if (props.particleUniformScale) {
        /*
          This action's uniform scale field acts differently from every other
          action that has it. Instead of just ignoring the Y size-related
          fields and properties, the X and Y size are added together. So, to
          make this class work more consistently with the other ones, this
          adds the Y value to the X value and sets the Y value to 0.
        */
        props.particleSizeX += props.particleSizeY
        props.particleSizeY = 0
        props.particleSizeXMin += props.particleSizeYMin
        props.particleSizeYMin = 0
        props.particleSizeXMax += props.particleSizeYMax
        props.particleSizeYMax = 0
        props.particleGrowthAccelerationXMin += props.particleGrowthAccelerationYMin
        props.particleGrowthAccelerationYMin = 0
        props.particleGrowthAccelerationXMax += props.particleGrowthAccelerationYMax
        props.particleGrowthAccelerationYMax = 0
        props.particleGrowthRateX = anyValueSum(props.particleGrowthRateX, props.particleGrowthRateY)
        props.particleGrowthRateY = 0
        props.particleGrowthRateXStatic += props.particleGrowthRateYStatic
        props.particleGrowthRateYStatic = 0
      }
      props.emissionIntervalMin /= 30
      props.emissionIntervalMax /= 30
      props.particleDuration /= 30
      props.particleRandomTurnIntervalMax /= 30

      props.particleAngularAccelerationZ = anyValueMult(180 / Math.PI, props.particleAngularAccelerationZ)
      return props
    },
    write(props: Props<GPUStandardParticle>, game: Game) {
      if (props.particleUniformScale) {
        props.particleSizeY = 0
        props.particleSizeYMin = 0
        props.particleSizeYMax = 0
        props.particleGrowthAccelerationYMin = 0
        props.particleGrowthAccelerationYMax = 0
        props.particleGrowthRateY = 0
        props.particleGrowthRateYStatic = 0
      }
      props.emissionIntervalMin = Math.round(props.emissionIntervalMin * 30)
      props.emissionIntervalMax = Math.round(props.emissionIntervalMax * 30)
      props.particleDuration = Math.round(props.particleDuration * 30)
      props.particleRandomTurnIntervalMax = Math.round(props.particleRandomTurnIntervalMax * 30)

      props.particleAngularAccelerationZ = anyValueMult(Math.PI / 180, props.particleAngularAccelerationZ)
      return props
    }
  },
  [ActionType.GPUStandardCorrectParticle]: {
    read(props: Props<GPUStandardCorrectParticle>, game: Game) {
      if (props.particleUniformScale) {
        /*
          This action's uniform scale field acts differently from every other
          action that has it. Instead of just ignoring the Y size-related
          fields and properties, the X and Y size are added together. So, to
          make this class work more consistently with the other ones, this
          adds the Y value to the X value and sets the Y value to 0.
        */
        props.particleSizeX += props.particleSizeY
        props.particleSizeY = 0
        props.particleSizeXMin += props.particleSizeYMin
        props.particleSizeYMin = 0
        props.particleSizeXMax += props.particleSizeYMax
        props.particleSizeYMax = 0
        props.particleGrowthAccelerationXMin += props.particleGrowthAccelerationYMin
        props.particleGrowthAccelerationYMin = 0
        props.particleGrowthAccelerationXMax += props.particleGrowthAccelerationYMax
        props.particleGrowthAccelerationYMax = 0
        props.particleGrowthRateX = anyValueSum(props.particleGrowthRateX, props.particleGrowthRateY)
        props.particleGrowthRateY = 0
        props.particleGrowthRateXStatic += props.particleGrowthRateYStatic
        props.particleGrowthRateYStatic = 0
      }
      props.emissionIntervalMin /= 30
      props.emissionIntervalMax /= 30
      props.particleDuration /= 30
      props.particleRandomTurnIntervalMax /= 30

      props.particleAngularAccelerationZ = anyValueMult(180 / Math.PI, props.particleAngularAccelerationZ)
      return props
    },
    write(props: Props<GPUStandardCorrectParticle>, game: Game) {
      if (props.particleUniformScale) {
        props.particleSizeY = 0
        props.particleSizeYMin = 0
        props.particleSizeYMax = 0
        props.particleGrowthAccelerationYMin = 0
        props.particleGrowthAccelerationYMax = 0
        props.particleGrowthRateY = 0
        props.particleGrowthRateYStatic = 0
      }
      props.emissionIntervalMin = Math.round(props.emissionIntervalMin * 30)
      props.emissionIntervalMax = Math.round(props.emissionIntervalMax * 30)
      props.particleDuration = Math.round(props.particleDuration * 30)
      props.particleRandomTurnIntervalMax = Math.round(props.particleRandomTurnIntervalMax * 30)

      props.particleAngularAccelerationZ = anyValueMult(Math.PI / 180, props.particleAngularAccelerationZ)
      return props
    },
    fallback(action: GPUStandardCorrectParticle, game: Game) {
      return new GPUStandardParticle(action).toAction(game)
    }
  },
  [ActionType.GPUSparkParticle]: {
    read(props: Props<GPUSparkParticle>, game: Game) {
      props.emissionInterval /= 30
      props.emissionIntervalMin /= 30
      props.emissionIntervalMax /= 30
      props.particleDuration /= 30
      return props
    },
    write(props: Props<GPUSparkParticle>, game: Game) {
      props.emissionInterval = Math.round(props.emissionInterval * 30)
      props.emissionIntervalMin = Math.round(props.emissionIntervalMin * 30)
      props.emissionIntervalMax = Math.round(props.emissionIntervalMax * 30)
      props.particleDuration = Math.round(props.particleDuration * 30)
      return props
    }
  },
  [ActionType.GPUSparkCorrectParticle]: {
    read(props: Props<GPUSparkCorrectParticle>, game: Game) {
      props.emissionInterval /= 30
      props.emissionIntervalMin /= 30
      props.emissionIntervalMax /= 30
      props.particleDuration /= 30
      return props
    },
    write(props: Props<GPUSparkCorrectParticle>, game: Game) {
      props.emissionInterval = Math.round(props.emissionInterval * 30)
      props.emissionIntervalMin = Math.round(props.emissionIntervalMin * 30)
      props.emissionIntervalMax = Math.round(props.emissionIntervalMax * 30)
      props.particleDuration = Math.round(props.particleDuration * 30)
      return props
    }
  },
  [ActionType.WindForce]: {
    read(props: Props<WindForce>, game: Game) {
      if ('fadeOutTime' in props) {
        props.fadeOutTime = props.fadeOutTime / 30
      }
      return props
    },
    write(props: Props<WindForce>, game: Game) {
      props.fadeOutTime = Math.round(props.fadeOutTime * 30)
      return props
    }
  },
  [ActionType.GravityForce]: {
    read(props: Props<GravityForce>, game: Game) {
      props.fadeOutTime = props.fadeOutTime / 30
      return props
    },
    write(props: Props<GravityForce>, game: Game) {
      props.fadeOutTime = Math.round(props.fadeOutTime * 30)
      return props
    }
  },
  [ActionType.TurbulenceForce]: {
    read(props: Props<TurbulenceForce>, game: Game) {
      props.fadeOutTime = props.fadeOutTime / 30
      return props
    },
    write(props: Props<TurbulenceForce>, game: Game) {
      props.fadeOutTime = Math.round(props.fadeOutTime * 30)
      return props
    }
  },
  [ActionType.Unk10500]: {
    read(props: Props<Unk10500>, game: Game) {
      if (game !== Game.ArmoredCore6) {
        props.initialSimulationTime = props.initialSimulationTime / 30
      }
      return props
    },
    write(props: Props<Unk10500>, game: Game) {
      if (game === Game.EldenRing) {
        props.initialSimulationTime = Math.round(props.initialSimulationTime * 30)
      }
      return props
    }
  },
  [ActionType.SpotLight]: {
    read(props: Props<SpotLight>, game: Game) {
      props.fadeOutTime = props.fadeOutTime / 30
      if (game === Game.DarkSouls3) {
        props.diffuseColor = anyValueMult(1/255, props.diffuseColor) as Vector4Value
        props.specularColor = anyValueMult(1/255, props.specularColor) as Vector4Value
        props.diffuseMultiplier = 255/100
        props.specularMultiplier = 255/100
      } else {
        props.diffuseMultiplier = anyValueMult(1/10, props.diffuseMultiplier) as ScalarValue
        props.specularMultiplier = anyValueMult(1/10, props.specularMultiplier) as ScalarValue
      }
      return props
    },
    write(props: Props<SpotLight>, game: Game) {
      props.fadeOutTime = Math.round(props.fadeOutTime * 30)
      if (game === Game.DarkSouls3) {
        props.diffuseColor = anyValueMult(anyValueMult(100, props.diffuseMultiplier), props.diffuseColor) as Vector4Value
        props.specularColor = anyValueMult(anyValueMult(100, props.specularMultiplier), props.specularColor) as Vector4Value
      } else {
        props.diffuseMultiplier = anyValueMult(10, props.diffuseMultiplier) as ScalarValue
        props.specularMultiplier = anyValueMult(10, props.specularMultiplier) as ScalarValue
      }
      return props
    }
  }
}

//#region Binary Reader/Writer
class BinaryReader extends DataView<ArrayBufferLike> {

  position: number = 0
  littleEndian: boolean = true
  round: boolean = false
  game: Game = Game.Heuristic
  steps: number[] = []
  memOffset: bigint = 0n

  getInt16(offset: number) {
    return super.getInt16(offset, this.littleEndian)
  }

  getUint16(offset: number) {
    return super.getUint16(offset, this.littleEndian)
  }

  getInt32(offset: number) {
    return super.getInt32(offset, this.littleEndian)
  }

  getUint32(offset: number) {
    return super.getUint32(offset, this.littleEndian)
  }

  getFloat32(offset: number) {
    if (this.round) {
      const f = +super.getFloat32(offset, this.littleEndian).toPrecision(7)
      const a = Math.abs(f)
      return a < 1e-6 ? 0 : a < 1 ? +String(f).slice(0, 8) : f
    } else {
      return super.getFloat32(offset, this.littleEndian)
    }
  }

  getFloat64(offset: number) {
    return super.getFloat64(offset, this.littleEndian)
  }

  getBigInt64(offset: number) {
    return super.getBigInt64(offset, this.littleEndian)
  }

  getBigUint64(offset: number) {
    return super.getBigUint64(offset, this.littleEndian)
  }

  readUint8() {
    return this.getUint8(this.position++)
  }

  readBool() {
    const b = this.readUint8()
    if (b <= 1) {
      return !!b
    } else {
      throw new Error(`readBool encountered non-boolean value: 0x${b.toString(16).padStart(2, '0')}`)
    }
  }

  readInt16() {
    const value = this.getInt16(this.position)
    this.position += 2
    return value
  }

  readUint16() {
    const value = this.getUint16(this.position)
    this.position += 2
    return value
  }

  readInt32() {
    const value = this.getInt32(this.position)
    this.position += 4
    return value
  }

  readUint32() {
    const value = this.getUint32(this.position)
    this.position += 4
    return value
  }

  readFloat32() {
    const value = this.getFloat32(this.position)
    this.position += 4
    return value
  }

  readInt64() {
    const value = this.getBigInt64(this.position)
    this.position += 8
    return value
  }

  readUint64() {
    const value = this.getBigUint64(this.position)
    this.position += 8
    return value
  }

  readOffset() {
    const o = this.readUint64()
    return Number(o - this.memOffset)
  }

  getInt32s(offset: number, count: number) {
    return arrayOf(count, i => this.getInt32(offset + i * 4))
  }

  assertUint8(...ui8s: number[]) {
    const ocp = this.position
    const value = this.readUint8()
    for (const ui8 of ui8s) {
      if (value === ui8) return value
    }
    throw new Error(`Read: ${value} | Expected: ${ui8s.join(', ')} | Position: ${ocp}`)
  }

  assertInt16(...i16s: number[]) {
    const ocp = this.position
    const value = this.readInt16()
    for (const i16 of i16s) {
      if (value === i16) return value
    }
    throw new Error(`Read: ${value} | Expected: ${i16s.join(', ')} | Position: ${ocp}`)
  }

  assertUint16(...ui16s: number[]) {
    const ocp = this.position
    const value = this.readUint16()
    for (const ui16 of ui16s) {
      if (value === ui16) return value
    }
    throw new Error(`Read: ${value} | Expected: ${ui16s.join(', ')} | Position: ${ocp}`)
  }

  assertInt32(...i32s: number[]) {
    const ocp = this.position
    const value = this.readInt32()
    for (const i32 of i32s) {
      if (value === i32) return value
    }
    throw new Error(`Read: ${value} | Expected: ${i32s.join(', ')} | Position: ${ocp}`)
  }

  assertUint32(...ui32s: number[]) {
    const ocp = this.position
    const value = this.readUint32()
    for (const ui32 of ui32s) {
      if (value === ui32) return value
    }
    throw new Error(`Read: ${value} | Expected: ${ui32s.join(', ')} | Position: ${ocp}`)
  }

  assertASCII(ascii: string) {
    const ocp = this.position
    const value: string = String.fromCharCode.apply(null, ascii.split('').map(() => this.readUint8()))
    if (value !== ascii) {
      throw new Error(`Read: ${value} | Expected: ${ascii} | Position: ${ocp}`)
    }
    return value
  }

  stepIn(offset: number) {
    this.steps.push(this.position)
    this.position = offset
  }

  stepOut() {
    if (this.steps.length === 0) {
      throw new Error('Reader is already stepped all the way out.')
    }
    this.position = this.steps.pop() ?? 0
  }

}

interface ReservationList {
  [name: string]: { offset: number, size: 1 | 2 | 4, func?: string }
}

class BinaryWriter {

  static #te = new TextEncoder

  littleEndian: boolean
  array: number[] = []
  reservations: ReservationList = {}

  #transBuf = new ArrayBuffer(4)
  #transDV = new DataView(this.#transBuf)
  #transArr16 = new Int8Array(this.#transBuf, 0, 2)
  #transArr32 = new Int8Array(this.#transBuf, 0, 4)

  convertedDataActions = new Map<DataAction, any>

  constructor(littleEndian: boolean = true) {
    this.littleEndian = littleEndian
  }

  get position() {
    return this.array.length
  }

  writeBool(b: boolean) {
    this.array.push(+b)
  }

  writeInt8(i8: number) {
    this.array.push(i8)
  }

  writeUint8(ui8: number) {
    this.array.push(ui8)
  }

  writeInt16(i16: number) {
    this.#transDV.setInt16(0, i16, this.littleEndian)
    this.array.push(...this.#transArr16)
  }

  writeUint16(ui16: number) {
    this.#transDV.setUint16(0, ui16, this.littleEndian)
    this.array.push(...this.#transArr16)
  }

  writeInt32(i32: number) {
    this.#transDV.setInt32(0, i32, this.littleEndian)
    this.array.push(...this.#transArr32)
  }

  writeUint32(ui32: number) {
    this.#transDV.setUint32(0, ui32, this.littleEndian)
    this.array.push(...this.#transArr32)
  }

  writeFloat32(f32: number) {
    // Make sure that the value is not -0
    f32 = f32 === 0 ? 0 : f32
    this.#transDV.setFloat32(0, f32, this.littleEndian)
    this.array.push(...this.#transArr32)
  }

  writeInt8s(i8s: number[]) {
    for (const i8 of i8s) this.writeInt8(i8)
  }

  writeUint8s(ui8s: number[]) {
    for (const ui8 of ui8s) this.writeUint8(ui8)
  }

  writeInt16s(i16s: number[]) {
    for (const i16 of i16s) this.writeInt16(i16)
  }

  writeUint16s(ui16s: number[]) {
    for (const ui16 of ui16s) this.writeUint16(ui16)
  }

  writeInt32s(i32s: number[]) {
    for (const i32 of i32s) this.writeInt32(i32)
  }

  writeUint32s(ui32s: number[]) {
    for (const ui32 of ui32s) this.writeUint32(ui32)
  }

  writeFloat32s(f32s: number[]) {
    for (const f32 of f32s) this.writeFloat32(f32)
  }

  writeString(s: string) {
    this.array.push(...BinaryWriter.#te.encode(s))
  }

  reserveInt8(name: string) {
    this.reservations[name] = {
      offset: this.array.length,
      size: 1
    }
    this.writeInt8(0)
  }

  reserveUint8(name: string) {
    this.reservations[name] = {
      offset: this.array.length,
      size: 1
    }
    this.writeUint8(0)
  }

  reserveInt16(name: string) {
    this.reservations[name] = {
      offset: this.array.length,
      size: 2,
      func: 'setInt16'
    }
    this.writeInt16(0)
  }

  reserveUint16(name: string) {
    this.reservations[name] = {
      offset: this.array.length,
      size: 2,
      func: 'setUint16'
    }
    this.writeUint16(0)
  }

  reserveInt32(name: string) {
    this.reservations[name] = {
      offset: this.array.length,
      size: 4,
      func: 'setInt32'
    }
    this.writeInt32(0)
  }

  reserveUint32(name: string) {
    this.reservations[name] = {
      offset: this.array.length,
      size: 4,
      func: 'setUint32'
    }
    this.writeUint32(0)
  }

  reserveFloat32(name: string) {
    this.reservations[name] = {
      offset: this.array.length,
      size: 4,
      func: 'setFloat32'
    }
    this.writeFloat32(0)
  }

  fill(name: string, value: number) {
    if (!(name in this.reservations)) {
      throw new Error('Key is not reserved: ' + name)
    }
    const reservation = this.reservations[name]
    switch (reservation.size) {
      case 1: {
        this.array.splice(reservation.offset, 1, value)
        break
      }
      case 2: {
        this.#transDV[reservation.func as string](0, value, this.littleEndian)
        this.array.splice(reservation.offset, 2, ...this.#transArr16)
        break
      }
      case 4: {
        this.#transDV[reservation.func as string](0, value, this.littleEndian)
        this.array.splice(reservation.offset, 4, ...this.#transArr32)
        break
      }
    }
    delete this.reservations[name]
  }

  pad(align: number) {
    while (this.array.length % align > 0) this.writeInt8(0)
  }

  getArrayBuffer() {
    return new Uint8Array(this.array).buffer
  }

}

//#region FXR
export interface FXRReadOptions {
  /**
   * This can be enabled to round floats to 7 significant digits. It defaults
   * to false.
   */
  round?: boolean
}

/**
 * A set of rules for filtering out certain values when serializing objects.
 */
export enum FXRSerializeFilter {
  /**
   * Do not filter out anything from the output JSON.
   * 
   * This filter option keeps all information about the object in the JSON
   * output.
   */
  None = 0,
  /**
   * Filter out all default values in order to make the output JSON more
   * compact.
   * 
   * This is the most compact filter option.
   */
  Defaults,
  /**
   * Filter out all unknown properties with default values in order to make the
   * output JSON more compact.
   * 
   * This filter option keeps labeled properties and default actions in the
   * output JSON.
   */
  DefaultUnknowns,
  /**
   * Filter out all unknown properties with default values and default action
   * values in order to make the output JSON more compact.
   * 
   * This filter option keeps labeled properties in the output JSON.
   */
  DefaultUnknownsAndActions,
}

/**
 * An object containing options for the `serialize` method in most classes that
 * are part of the FXR tree structure.
 */
export interface FXRSerializeOptions {
  /**
   * A rule used to filter out certain values in the output JSON, which can be
   * used to reduce the size of the output without losing any important
   * information.
   */
  filter?: FXRSerializeFilter
  /**
   * Forces actions to not be filtered out. This is mainly used internally to
   * stop generic classes from outputting nonsense when the {@link filter}
   * allows removing default actions, but it may also be useful if you want to
   * prevent actions from disappearing entirely from the output.
   */
  requireActionDefinition?: boolean
}

/**
 * Note: This assumes the case is a default value.
 */
function serializeFilter(
  c: 'nodeList' | 'action' | 'property' | 'unknownProperty',
  filter = FXRSerializeFilter.None
): boolean {
  switch (filter) {
    case FXRSerializeFilter.None: return false
    case FXRSerializeFilter.Defaults: return true
    case FXRSerializeFilter.DefaultUnknowns:
      return c === 'unknownProperty' || c === 'nodeList'
    case FXRSerializeFilter.DefaultUnknownsAndActions:
      return c === 'unknownProperty' || c === 'action' || c === 'nodeList'
  }
  return false
}

/**
 * An effects resource (FXR, version 4 or 5) for FromSoftware's game engine.
 * Used in most of FromSoftware's modern games:
 * - Dark Souls III
 * - Sekiro: Shadows Die Twice
 * - Elden Ring
 * - Armored Core VI Fires of Rubicon
 * - Elden Ring Nightreign
 */
class FXR {

  #gameHint: Game = Game.Generic
  states: State[]
  root: RootNode | GenericNode

  /**
   * @param id Internal FXR ID. This ID is used to refer to the effect in other
   * effects, or in params, TAE, and possibly other parts of the game.
   * 
   * This ID must be between 1 and 999,999,999 (inclusive), and it must match
   * the ID in the FXR's filename. If the internal ID does not match the
   * filename, it may cause unexpected behavior.
   * @param terminate Controls whether or not to add a state that causes the
   * effect to terminate when {@link ExternalValue external value} 0 becomes 1.
   * @param rootChildren A list of nodes to add as direct children of the root
   * node.
   */
  constructor(id: number, terminate?: boolean, rootChildren?: Node[])

  /**
   * @param id Internal FXR ID. This ID is used to refer to the effect in other
   * effects, or in params, TAE, and possibly other parts of the game.
   * 
   * This ID must be between 1 and 999,999,999 (inclusive), and it must match
   * the ID in the FXR's filename. If the internal ID does not match the
   * filename, it may cause unexpected behavior.
   * @param duration A duration for the effect. This is applied through a state
   * with a condition that compares the state time to the duration value.
   * @param rootChildren A list of nodes to add as direct children of the root
   * node.
   */
  constructor(id: number, duration?: number, rootChildren?: Node[])

  /**
   * @param id Internal FXR ID. This ID is used to refer to the effect in other
   * effects, or in params, TAE, and possibly other parts of the game.
   * 
   * This ID must be between 1 and 999,999,999 (inclusive), and it must match
   * the ID in the FXR's filename. If the internal ID does not match the
   * filename, it may cause unexpected behavior.
   * @param states A list of states for the effect.
   * @param rootChildren A list of nodes to add as direct children of the root
   * node.
   */
  constructor(id: number, states?: State[], rootChildren?: Node[])

  /**
   * @param id Internal FXR ID. This ID is used to refer to the effect in other
   * effects, or in params, TAE, and possibly other parts of the game.
   * 
   * This ID must be between 1 and 999,999,999 (inclusive), and it must match
   * the ID in the FXR's filename. If the internal ID does not match the
   * filename, it may cause unexpected behavior.
   * @param terminate Controls whether or not to add a state that causes the
   * effect to terminate when {@link ExternalValue external value} 0 becomes 1.
   * @param root The root node of the effect.
   */
  constructor(id: number, terminate?: boolean, root?: RootNode | GenericNode)

  /**
   * @param id Internal FXR ID. This ID is used to refer to the effect in other
   * effects, or in params, TAE, and possibly other parts of the game.
   * 
   * This ID must be between 1 and 999,999,999 (inclusive), and it must match
   * the ID in the FXR's filename. If the internal ID does not match the
   * filename, it may cause unexpected behavior.
   * @param duration A duration for the effect. This is applied through a state
   * with a condition that compares the state time to the duration value.
   * @param root The root node of the effect.
   */
  constructor(id: number, duration?: number, root?: RootNode | GenericNode)

  /**
   * @param id Internal FXR ID. This ID is used to refer to the effect in other
   * effects, or in params, TAE, and possibly other parts of the game.
   * 
   * This ID must be between 1 and 999,999,999 (inclusive), and it must match
   * the ID in the FXR's filename. If the internal ID does not match the
   * filename, it may cause unexpected behavior.
   * @param states A list of states for the effect.
   * @param root The root node of the effect.
   */
  constructor(id: number, states?: State[], root?: RootNode | GenericNode)

  constructor(
    public id: number,
    states: State[] | boolean | number = [ new State ],
    root: RootNode | GenericNode | Node[] = new RootNode,
  ) {
    if (typeof states === 'boolean') {
      if (states) {
        this.states = [ State.from('ext(0) < 1') ]
      } else {
        this.states = [ new State ]
      }
    } else if (typeof states === 'number') {
      this.states = [
        new State([
          new StateCondition(
            Operator.LessThan, 2, -1,
            OperandType.StateTime, null,
            OperandType.Literal, states
          )
        ])
      ]
    } else {
      this.states = states
    }
    if (Array.isArray(root)) {
      this.root = new RootNode(root)
    } else {
      this.root = root
    }
  }

  /**
   * Parses an FXR file.
   * 
   * This uses the fs module from Node.js to read the file. If you are
   * targeting browers, pass an {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer ArrayBuffer} or {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView ArrayBufferView} of the contents of the file instead.
   * @param filePath A path to the FXR file to parse.
   * @param game The game the FXR file is for. Defaults to
   * {@link Game.Heuristic}, which will make the function try to figure out
   * what it is for automatically.
   * 
   * Accuracy of {@link Game.Heuristic} (with valid FXRs):
   * - Dark Souls 3: **Perfect, 100%**
   * - Sekiro: **Perfect, 100%**
   * - Elden Ring: **Low**
   * - Armored Core 6: **Low**
   * - Elden Ring Nightreign: **Perfect, 100%**
   * 
   * For Elden Ring and Armored Core 6, it will still correctly parse the file,
   * but {@link gameHint} will be *very* unreliable.
   */
  static read<T extends typeof FXR>(
    this: T,
    filePath: string,
    game?: Game,
    { round }?: FXRReadOptions
  ): Promise<InstanceType<T>>

  /**
   * Parses an FXR file.
   * @param buffer {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer ArrayBuffer} or {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView ArrayBufferView} of the
   * contents of the FXR file to parse.
   * @param game The game the FXR file is for. Defaults to
   * {@link Game.Heuristic}, which will make the function try to figure out
   * what it is for automatically.
   * 
   * Accuracy of {@link Game.Heuristic} (with valid FXRs):
   * - Dark Souls 3: **Perfect, 100%**
   * - Sekiro: **Perfect, 100%**
   * - Elden Ring: **Low**
   * - Armored Core 6: **Low**
   * - Elden Ring Nightreign: **Perfect, 100%**
   * 
   * For Elden Ring and Armored Core 6, it will still correctly parse the file,
   * but {@link gameHint} will be *very* unreliable.
   */
  static read<T extends typeof FXR>(
    this: T,
    buffer: ArrayBufferLike | ArrayBufferView<ArrayBufferLike>,
    game?: Game,
    { round }?: FXRReadOptions
  ): InstanceType<T>

  /**
   * Parses an FXR file.
   * @param input A path to the FXR file to parse, or an {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer ArrayBuffer} or {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView ArrayBufferView} of the contents of the FXR file.
   * @param game The game the FXR file is for. Defaults to
   * {@link Game.Heuristic}, which will make the function try to figure out
   * what it is for automatically.
   * 
   * Accuracy of {@link Game.Heuristic} (with valid FXRs):
   * - Dark Souls 3: **Perfect, 100%**
   * - Sekiro: **Perfect, 100%**
   * - Elden Ring: **Low**
   * - Armored Core 6: **Low**
   * - Elden Ring Nightreign: **Perfect, 100%**
   * 
   * For Elden Ring and Armored Core 6, it will still correctly parse the file,
   * but {@link gameHint} will be *very* unreliable.
   */
  static read<T extends typeof FXR>(
    this: T,
    input: string | ArrayBufferLike | ArrayBufferView<ArrayBufferLike>,
    game: Game = Game.Heuristic,
    { round }: FXRReadOptions = {}
  ): Promise<InstanceType<T>> | InstanceType<T> {
    round ??= false
    if (typeof input === 'string') {
      return import('node:fs/promises').then(async fs =>
        this.read((await fs.readFile(input as string)).buffer, game, { round })
      )
    }
    if (ArrayBuffer.isView(input)) {
      input = input.buffer
    } else if (!(input instanceof ArrayBuffer)) {
      throw new Error('Invalid input type. Input must be a file path string, or an ArrayBuffer or ArrayBufferView of the file contents.')
    }
    const br = new BinaryReader(input)
    br.round = round
    br.game = game

    br.assertASCII('FXR\0')

    if (game === Game.Heuristic) {
      const unk4 = br.assertInt16(0, 1) // Minor version???
      if (unk4 === 1) {
        br.game = game = Game.Nightreign
      }
    } else if (game === Game.Generic) {
      br.assertInt16(0, 1)
    } else if (game === Game.Nightreign) {
      br.assertInt16(1)
    } else {
      br.assertInt16(0)
    }
    if (game === Game.Generic || game === Game.Heuristic) {
      const version = br.assertInt16(
        FXRVersion.DarkSouls3,
        FXRVersion.Sekiro
      )
      if (game === Game.Heuristic && version === FXRVersion.DarkSouls3) {
        br.game = game = Game.DarkSouls3
      }
    } else {
      br.assertInt16(GameVersionMap[game])
    }
    br.assertInt32(1)
    const id = br.readInt32()
    const stateListOffset = br.readInt32()
    br.assertInt32(1) // StateMachineCount
    const statesOffset = br.readInt32()
    br.position += 3 * 4
    // br.readInt32() // StateCount
    // br.readInt32() // ConditionOffset
    // br.readInt32() // ConditionCount
    const nodeOffset = br.readInt32()
    br.position += 15 * 4
    // br.readInt32() // NodeCount
    // br.readInt32() // ConfigOffset
    // br.readInt32() // ConfigCount
    // br.readInt32() // ActionOffset
    // br.readInt32() // ActionCount
    // br.readInt32() // PropertyOffset
    // br.readInt32() // PropertyCount
    // br.readInt32() // Section8Offset
    // br.readInt32() // Section8Count
    // br.readInt32() // Section9Offset
    // br.readInt32() // Section9Count
    // br.readInt32() // Section10Offset
    // br.readInt32() // Section10Count
    // br.readInt32() // FieldOffset
    // br.readInt32() // FieldCount
    br.assertInt32(1)
    br.assertInt32(0)

    // let sfxReferences: number[] = []
    // let externalValues1: number[] = []
    // let externalValues2: number[] = []
    // let unkEmpty: number[] = []

    // if (version === FXRVersion.Sekiro) {
    //   const sfxReferencesOffset = br.readInt32()
    //   const sfxReferencesCount  = br.readInt32()
    //   const externalValues1Offset = br.readInt32()
    //   const externalValues1Count  = br.readInt32()
    //   const externalValues2Offset = br.readInt32()
    //   const externalValues2Count  = br.readInt32()
    //   br.readInt32()
    //   br.assertInt32(0)
    //   // const unkEmptyOffset = br.readInt32()
    //   // const unkEmptyCount  = br.readInt32()

    //   sfxReferences = br.getInt32s(sfxReferencesOffset, sfxReferencesCount)
    //   externalValues1 = br.getInt32s(externalValues1Offset, externalValues1Count)
    //   externalValues2 = br.getInt32s(externalValues2Offset, externalValues2Count)
    //   // unkEmpty = br.getInt32s(unkEmptyOffset, unkEmptyCount)
    // }

    br.position = stateListOffset
    br.assertInt32(0)
    const stateCount = br.readInt32()
    const statesPtr = br.readInt64()
    br.memOffset = statesPtr - BigInt(statesOffset)
    br.stepIn(statesOffset)
    const states: State[] = []
    for (let i = 0; i < stateCount; ++i) {
      states.push(readState(br))
    }
    br.stepOut()

    br.position = nodeOffset
    const rootNode = readNode(br) as RootNode | GenericNode

    const fxr = new this(
      id,
      states,
      rootNode,
      // sfxReferences,
      // externalValues1,
      // externalValues2,
      // unkEmpty,
    ) as InstanceType<T>

    fxr.#gameHint = br.game

    return fxr
  }

  /**
   * Serialize to the FXR file format.
   * @param game The game to write this FXR for.
   * 
   * Defaults to {@link Game.Heuristic}, which means it will use the
   * {@link gameHint game hint}, unless the hint is also
   * {@link Game.Heuristic}, in which case it will throw an error, because the
   * game is unknowable.
   * @returns ArrayBuffer containing the contents of the FXR file.
   */
  toArrayBuffer(game: Game = Game.Heuristic) {
    if (game === Game.Heuristic) {
      if (this.#gameHint === Game.Heuristic) {
        throw new Error('What game this FXR is for is unknowable. Please provide a game to write the FXR for.')
      }
      game = this.#gameHint
    }
    assertValidFXRID(this.id)
    const version = GameVersionMap[game]
    const bw = new BinaryWriter
    bw.writeString('FXR\0')
    bw.writeInt16(game === Game.Nightreign ? 1 : 0)
    bw.writeUint16(version)
    bw.writeInt32(1)
    bw.writeInt32(this.id)
    bw.reserveInt32('StateListOffset')
    bw.writeInt32(1)
    bw.reserveInt32('StatesOffset1')
    bw.writeInt32(this.states.length)
    bw.reserveInt32('ConditionOffset')
    bw.reserveInt32('ConditionCount')
    bw.reserveInt32('NodeOffset')
    bw.reserveInt32('NodeCount')
    bw.reserveInt32('ConfigOffset')
    bw.reserveInt32('ConfigCount')
    bw.reserveInt32('ActionOffset')
    bw.reserveInt32('ActionCount')
    bw.reserveInt32('PropertyOffset')
    bw.reserveInt32('PropertyCount')
    bw.reserveInt32('Section8Offset')
    bw.reserveInt32('Section8Count')
    bw.reserveInt32('Section9Offset')
    bw.reserveInt32('Section9Count')
    bw.reserveInt32('Section10Offset')
    bw.reserveInt32('Section10Count')
    bw.reserveInt32('FieldOffset')
    bw.reserveInt32('FieldCount')
    bw.writeInt32(1)
    bw.writeInt32(0)

    const refs = version === FXRVersion.Sekiro ? this.getReferences() : {
      sfx: [],
      externalValues1: [],
      externalValues2: [],
    }
    if (version === FXRVersion.Sekiro) {
      bw.reserveInt32('SFXReferencesOffset')
      bw.writeInt32(refs.sfx.length)
      bw.reserveInt32('ExternalValues1Offset')
      bw.writeInt32(refs.externalValues1.length)
      bw.reserveInt32('ExternalValues2Offset')
      bw.writeInt32(refs.externalValues2.length)
      // bw.reserveInt32('UnkEmptyOffset')
      // bw.writeInt32(this.unkEmpty.length)
      bw.writeInt32(0)
      bw.writeInt32(0)
    }

    let rateOfTime = 1
    if (this.root instanceof RootNode) {
      if (this.root.rateOfTime instanceof Property) {
        rateOfTime = this.root.rateOfTime.valueAt(0)
      } else {
        rateOfTime = this.root.rateOfTime
      }
    }

    bw.fill('StateListOffset', bw.position)
    bw.writeInt32(0)
    bw.writeInt32(this.states.length)
    bw.reserveInt32('StatesOffset2')
    bw.writeInt32(0)
    bw.pad(16)
    bw.fill('StatesOffset1', bw.position)
    bw.fill('StatesOffset2', bw.position)
    for (let i = 0; i < this.states.length; ++i) {
      writeState(this.states[i], bw, i)
    }

    bw.pad(16)
    bw.fill('ConditionOffset', bw.position)
    const conditions: StateCondition[] = []
    for (let i = 0; i < this.states.length; ++i) {
      const cons = game === Game.DarkSouls3 ? this.states[i].conditions.map(c => {
        if (c.leftOperandType === OperandType.StateTime && c.rightOperandType === OperandType.Literal) {
          return new StateCondition(
            c.operator,
            c.unk1,
            c.nextState,
            c.leftOperandType,
            c.leftOperandValue,
            c.rightOperandType,
            c.rightOperandValue / rateOfTime,
          )
        } else if (c.rightOperandType === OperandType.StateTime && c.leftOperandType === OperandType.Literal) {
          return new StateCondition(
            c.operator,
            c.unk1,
            c.nextState,
            c.leftOperandType,
            c.leftOperandValue / rateOfTime,
            c.rightOperandType,
            c.rightOperandValue,
          )
        } else {
          return c
        }
      }) : this.states[i].conditions
      writeStateConditions(cons, bw, i, conditions)
    }
    bw.fill('ConditionCount', conditions.length)
    bw.pad(16)
    bw.fill('NodeOffset', bw.position)
    const nodes: Node[] = []
    const root = game === Game.DarkSouls3 && this.root instanceof RootNode ?
      this.root.clone().scaleRateOfTime(rateOfTime) :
      this.root
    writeNode(root, bw, game, nodes)
    writeNodeChildren(root, bw, game, nodes)
    bw.fill('NodeCount', nodes.length)
    bw.pad(16)
    bw.fill('ConfigOffset', bw.position)
    let counter = { value: 0 }
    for (let i = 0; i < nodes.length; ++i) {
      writeNodeConfigs(nodes[i], bw, game, i, counter)
    }
    bw.fill('ConfigCount', counter.value)
    bw.pad(16)
    bw.fill('ActionOffset', bw.position)
    counter.value = 0
    const actions: Action[] = []
    for (let i = 0; i < nodes.length; ++i) {
      writeNodeActions(nodes[i], bw, game, i, counter, actions)
    }
    bw.fill('ActionCount', actions.length)
    bw.pad(16)
    bw.fill('PropertyOffset', bw.position)
    const properties: IModifiableProperty<any, any>[] = []
    for (let i = 0; i < actions.length; ++i) {
      writeAnyActionProperties(actions[i], bw, game, i, properties)
    }
    bw.fill('PropertyCount', properties.length)
    bw.pad(16)
    bw.fill('Section8Offset', bw.position)
    const modifiers: IModifier<ValueType>[] = []
    for (let i = 0; i < properties.length; ++i) {
      // The property has already gone through .for(game) here, so don't use it again
      writePropertyModifiers(properties[i], bw, game, i, modifiers)
    }
    bw.fill('Section8Count', modifiers.length)
    bw.pad(16)
    bw.fill('Section9Offset', bw.position)
    const modProps: Property<any, any>[] = []
    for (let i = 0; i < modifiers.length; ++i) {
      writeModifierProperties(modifiers[i], bw, game, i, modProps)
    }
    bw.fill('Section9Count', modProps.length)
    bw.pad(16)
    bw.fill('Section10Offset', bw.position)
    const section10s: number[][] = []
    for (let i = 0; i < actions.length; ++i) {
      writeAnyActionSection10s(actions[i], bw, game, i, section10s)
    }
    bw.fill('Section10Count', section10s.length)
    bw.pad(16)
    bw.fill('FieldOffset', bw.position)
    let fieldCount = 0
    for (let i = 0; i < conditions.length; ++i) {
      fieldCount += writeStateConditionFields(conditions[i], bw, i)
    }
    for (let i = 0; i < actions.length; ++i) {
      fieldCount += writeAnyActionFields(actions[i], bw, game, i)
    }
    for (let i = 0; i < properties.length; ++i) {
      fieldCount += writePropertyFields(properties[i], bw, i, false)
    }
    for (let i = 0; i < modifiers.length; ++i) {
      fieldCount += writeModifierFields(modifiers[i], bw, i)
    }
    for (let i = 0; i < modProps.length; ++i) {
      fieldCount += writePropertyFields(modProps[i], bw, i, true)
    }
    for (let i = 0; i < section10s.length; ++i) {
      fieldCount += writeSection10Fields(section10s[i], bw, i)
    }
    bw.fill('FieldCount', fieldCount)
    bw.pad(16)

    if (version !== FXRVersion.Sekiro) {
      return bw.getArrayBuffer()
    }

    bw.fill('SFXReferencesOffset', bw.position)
    bw.writeInt32s(refs.sfx)
    bw.pad(16)

    bw.fill('ExternalValues1Offset', bw.position)
    bw.writeInt32s(refs.externalValues1)
    bw.pad(16)

    bw.fill('ExternalValues2Offset', bw.position)
    bw.writeInt32s(refs.externalValues2)
    bw.pad(16)

    // if (this.unkEmpty.length > 0) {
    //   bw.fill('UnkEmptyOffset', bw.position)
    //   bw.writeInt32s(this.unkEmpty)
    //   bw.pad(16)
    // } else {
    //   bw.fill('UnkEmptyOffset', 0)
    // }

    return bw.getArrayBuffer()
  }

  /**
   * Saves the FXR to a file using the fs module from Node.js.
   * @param path The path to the file.
   * @param game The game to write this FXR for.
   */
  async saveAs(path: string, game?: Game) {
    const fs = await import('node:fs/promises')
    await fs.writeFile(path, new Uint8Array(this.toArrayBuffer(game)))
  }

  static fromJSON<T extends typeof FXR>(this: T, obj: {
    id: number
    states?: (string | string[])[]
    root?: any
  } | {
    version: string
    fxr: any
  }): InstanceType<T> {
    if (obj instanceof this) {
      return obj as InstanceType<T>
    }
    if ('fxr' in obj) {
      return new this(
        obj.fxr.id,
        'states' in obj.fxr ? obj.fxr.states.map(state => State.from(state)) : undefined,
        'root' in obj.fxr ? Node.fromJSON(obj.fxr.root) as RootNode | GenericNode : undefined,
      ) as InstanceType<T>
    }
    return new this(
      obj.id,
      'states' in obj ? obj.states.map(state => State.from(state)) : undefined,
      'root' in obj ? Node.fromJSON(obj.root) as RootNode | GenericNode : undefined,
    ) as InstanceType<T>
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions) {
    return {
      id: this.id,
      states: this.states.map(state => state.serialize(options)),
      root: this.root.serialize(options),
    }
  }

  /**
   * Creates a minified version of this FXR.
   * 
   * The minified FXR might result in a smaller file size, but should be
   * functionally identical to the FXR it was made from.
   */
  minify() {
    return new FXR(
      this.id,
      this.states,
      this.root.minify() as RootNode | GenericNode,
    )
  }

  /**
   * Gets lists of various types of references in the FXR.
   */
  getReferences(): {
    sfx: number[]
    externalValues1: number[]
    externalValues2: number[]
  } {
    const sfx: number[] = []
    const externalValues1: number[] = []
    const externalValues2: number[] = []
    for (const node of this.root.walk()) {
      if (node instanceof ProxyNode) {
        sfx.push(node.sfx)
      } else if (node instanceof GenericNode && node.type === NodeType.Proxy) {
        if (node.actions.length === 0) {
          throw new Error('Missing action 132 in Proxy node!')
        }
        if (node.actions[0] instanceof Action) {
          sfx.push(node.actions[0].fields1[0].value as number)
        } else if (node.actions[0] instanceof SFXReference) {
          sfx.push(node.actions[0].sfx)
        }
      }
    }
    for (const prop of this.root.walkProperties()) {
      for (const mod of prop.modifiers) {
        if (mod instanceof ExternalValue1Modifier) {
          externalValues1.push(mod.externalValue)
        } else if (mod instanceof ExternalValue2Modifier) {
          if (mod.externalValue !== ExternalValue.EldenRing.BloodVisibility) {
            externalValues1.push(mod.externalValue)
          }
          externalValues2.push(mod.externalValue)
        }
      }
    }
    for (const state of this.states) {
      for (const condition of state.conditions) {
        if (condition.leftOperandType === OperandType.External) {
          externalValues1.push(condition.leftOperandValue as number)
        }
        if (condition.rightOperandType === OperandType.External) {
          externalValues1.push(condition.rightOperandValue as number)
        }
      }
    }
    return {
      sfx: uniqueArray(sfx).sort((a, b) => a - b),
      externalValues1: uniqueArray(externalValues1).sort((a, b) => a - b),
      externalValues2: uniqueArray(externalValues2).sort((a, b) => a - b),
    }
  }

  /**
   * Lists all resources (textures, models, animations, sounds) used in the
   * FXR. Useful for finding out what resources must exist for the effect to
   * work correctly, which is often needed when converting from one game to
   * another.
   */
  getResources() {
    return this.root.getResources()
  }

  clone(): FXR {
    return new FXR(
      this.id,
      this.states.map(e => State.from(e.toJSON())),
      this.root.clone(),
    )
  }

  /**
   * File name for this FXR.
   * 
   * Note that this is not necessarily the name of the file that was parsed. It
   * generates a new name based on the ID of the FXR. This follows the naming
   * convention used by the games (`f<0-padded ID>.fxr`), so an FXR with 1 as
   * the ID would be `f000000001.fxr`, for example.
   */
  get name() {
    assertValidFXRID(this.id)
    return `f${this.id.toString().padStart(9, '0')}.fxr`
  }

  /**
   * Finds and returns a value at a given path. If the path does not match
   * anything, this returns `null`.
   * 
   * For example, to get the appearance action in the second config in the
   * first child node of the root node, you would use this path:
   * ```js
   * fxr.find(['root', 'nodes', 0, 'configs', 1, 'appearance'])
   * // Or in string form:
   * fxr.find('root/nodes/0/configs/1/appearance')
   * // Both are equivalent to this:
   * fxr.root.nodes[0].configs[1].appearance
   * ```
   * @param path The path to the value to look for.
   */
  find(path: (string | number)[] | string): any {
    if (typeof path === 'string') {
      path = path.replace(/^[\/\s]+|[\/\s]+$/g, '').split('/')
    }
    let current: any = this
    for (const key of path) {
      if (current && current[key] !== undefined) {
        current = current[key]
      } else {
        return null
      }
    }
    return current
  }

  /**
   * The game hint is set by {@link FXR.read} to keep track of what game the
   * FXR file it read was for. It is used by {@link FXR.toArrayBuffer} and
   * {@link FXR.saveAs} when they are called with {@link Game.Heuristic}.
   * 
   * For FXR objects created in any other way, the game hint will always be
   * {@link Game.Generic}.
   * 
   * This value can be checked to find out what game the {@link FXR.read}
   * function read it as, which might be useful if it was called with
   * {@link Game.Heuristic}.
   */
  get gameHint() { return this.#gameHint }

  /**
   * True only if the effect contains an appearance action, and false
   * otherwise. This may be useful for filtering FXR files that are "empty".
   * 
   * Note that this does not check if any referenced FXR files have appearance
   * actions, so an effect that only contains a proxy will return false.
   */
  get hasAppearance() {
    for (const config of this.root.walkConfigs()) {
      if (config instanceof BasicConfig && config.appearance.type !== 0) {
        return true
      }
    }
    return false
  }

  /**
   * Scale the rate of time for the entire effect, including states.
   * @param factor The factor to scale the rate of time by. Setting this to 2
   * will make the node play twice as fast. Setting it to 0.5 will make it
   * play half as fast.
   * @param [options={}] Extra options for changing how the scaling is applied
   * to different properties and descendant nodes.
   */
  scaleRateOfTime(factor: number, options: { scaleTracerDuration?: boolean } = {}) {
    for (const state of this.states) {
      for (const con of state.conditions) {
        if (con.leftOperandType === OperandType.StateTime && con.rightOperandType === OperandType.Literal) {
          con.rightOperandValue /= factor
        } else if (con.rightOperandType === OperandType.StateTime && con.leftOperandType === OperandType.Literal) {
          con.leftOperandValue /= factor
        }
      }
    }
    this.root.scaleRateOfTime(factor, options)
    return this
  }

}

//#region State
class State {

  conditions: StateCondition[]

  constructor(conditions: StateCondition[] = []) {
    this.conditions = conditions
  }

  /**
   * @param obj A {@link StateCondition.from state condition expression}, an
   * array of state condition expressions, or a state.
   */
  static from(obj: string | string[] | State) {
    if (obj instanceof State) {
      return obj
    }
    if (Array.isArray(obj)) {
      return new State(obj.map(e => StateCondition.from(e)))
    }
    if (obj.trim().length > 0) {
      return new State([ StateCondition.from(obj) ])
    }
    return new State
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions) {
    if (this.conditions.length === 0) {
      return ''
    }
    if (this.conditions.length === 1) {
      return this.conditions[0].toString()
    }
    return this.conditions.map(c => c.toString())
  }

}

//#region StateCondition
class StateCondition {

  /**
   * A condition for a state. The state remains active if all of its conditions
   * are true or if it has no conditions. If the condition is false, the state
   * is deactivated and the next state (`nextState`) is activated.
   * @param operator Controls what operation should be used for the condition.
   * @param unk1 Unknown. Seems to always be 2 in vanilla Elden Ring. 3 seems
   * to make the condition always true.
   * @param nextState If the condition is false, the state at this index will
   * be checked next. Set it to -1 to disable the sfx if the condition is
   * false.
   * @param leftOperandType Controls what type of value the operand to the left
   * of the operator should be.
   * @param leftOperandValue This does different things depending on the
   * `leftOperandType`:
   * - {@link OperandType.Literal}: This value is the operand's value.
   * - {@link OperandType.External}: This value refers to an external value to
   * use as the operand's value.
   * - {@link OperandType.UnkMinus2}: This value is ignored and should be null.
   * - {@link OperandType.StateTime}: This value is ignored and should be null.
   * @param rightOperandType Controls what type of value the operand to the
   * right of the operator should be.
   * @param rightOperandValue This does different things depending on the
   * `rightOperandType`:
   * - {@link OperandType.Literal}: This value is the operand's value.
   * - {@link OperandType.External}: This value refers to an external value to
   * use as the operand's value.
   * - {@link OperandType.UnkMinus2}: This value is ignored and should be null.
   * - {@link OperandType.StateTime}: This value is ignored and should be null.
   */
  constructor(
    public operator: Operator,
    public unk1: number,
    public nextState: number,
    public leftOperandType: OperandType,
    public leftOperandValue: number | null,
    public rightOperandType: OperandType,
    public rightOperandValue: number | null,
  ) {}

  static #reExpression = /^\s*(?<left>(?:state)?time|(?:unk)?minus2|ext(?:ernal)?\(\d+\)|-?\d+(?:\.\d+)?|-?\.\d+)\s*(?<op>==?|<=?|>=?|!=)\s*(?<right>(?:state)?time|(?:unk)?minus2|ext(?:ernal)?\(\d+\)|-?\d+(?:\.\d+)?|-?\.\d+)\s*(?:else(?:\sgoto)?\s+(?<else>-?\d+|none))?\s*$/i
  static #reLiteralOperand = /^-?\d+(?:\.\d+)?|-?\.\d+$/
  static #reExternalOperand = /^[Ee]xt(?:ernal)?\((\d+)\)$/

  static #parseOperand(op: string) {
    switch (op.toLowerCase()) {
      case 'time':
      case 'statetime':
        return {
          type: OperandType.StateTime,
          value: null
        }
      case 'minus2':
      case 'unkminus2':
        return {
          type: OperandType.UnkMinus2,
          value: null
        }
      default: if (this.#reLiteralOperand.test(op)) {
        return {
          type: OperandType.Literal,
          value: parseFloat(op)
        }
      } else {
        return {
          type: OperandType.External,
          value: parseInt(op.match(this.#reExternalOperand)[1])
        }
      }
    }
  }

  /**
   * Parses a logical expression in a string and creates a
   * {@link StateCondition} from it.
   * @param expression A string with a logical expression and optionally an
   * `else` statement with a state index.
   * 
   * ## Syntax:
   * ```text
   * expression = <operand> <operator> <operand>[ else[ goto] <stateIndex>]
   * operand = <number> | External(<integer>) | StateTime | UnkMinus2
   * operator = != | == | > | >= | < | <=
   * stateIndex = <integer> | none
   * ```
   * 
   * `External`, `StateTime`, and `UnkMinus2` are all case-insensitive and have
   * shorter variations available. Here are some examples:
   * ```text
   * ext(0)
   * stateTime
   * time
   * minus2
   * ```
   * 
   * ## Examples:
   * ```text
   * ext(0) > 1
   * time < 5 else goto 2
   * 1 != External(10000) else 1
   * ```
   * 
   * @returns A new {@link StateCondition} based on the expression.
   */
  static from(expression: string | StateCondition) {
    if (expression instanceof StateCondition) {
      return expression
    }
    const m = expression.match(this.#reExpression)
    if (m === null) {
      throw new Error('Syntax error in condition expression: ' + expression)
    }
    let op: Operator
    switch (m.groups.op) {
      case '!=': op = Operator.NotEqual; break;
      case '=':
      case '==': op = Operator.Equal; break;
      case '<': op = Operator.LessThan; break;
      case '>': op = Operator.GreaterThan; break;
      case '<=': op = Operator.LessThanOrEqual; break;
      case '>=': op = Operator.GreaterThanOrEqual; break;
    }
    const left = this.#parseOperand(m.groups.left)
    const right = this.#parseOperand(m.groups.right)
    let nextState = -1
    if ('else' in m.groups) {
      switch (m.groups.else) {
        case '-1':
        case 'none':
        case undefined:
          break
        default:
          nextState = parseInt(m.groups.else)
          break
      }
    }
    return new StateCondition(op, 2, nextState, left.type, left.value, right.type, right.value)
  }

  /**
   * Swaps the operands and changes the operator to match if the left operand
   * is a literal value and the right operand is a non-literal value. This
   * makes it a bit easier to read the expression, but doesn't affect
   * functionality.
   */
  sortOperands() {
    if (this.leftOperandType !== OperandType.Literal || this.rightOperandType === OperandType.Literal) {
      return this
    }
    ;[
      this.leftOperandType,
      this.leftOperandValue,
      this.rightOperandType,
      this.rightOperandValue,
    ] = [
      this.rightOperandType,
      this.rightOperandValue,
      this.leftOperandType,
      this.leftOperandValue,
    ]
    switch (this.operator) {
      case Operator.GreaterThan: this.operator = Operator.LessThan; break;
      case Operator.GreaterThanOrEqual: this.operator = Operator.LessThanOrEqual; break;
      case Operator.LessThan: this.operator = Operator.GreaterThan; break;
      case Operator.LessThanOrEqual: this.operator = Operator.GreaterThanOrEqual; break;
    }
    return this
  }

  /**
   * The {@link Operator.LessThanOrEqual LessThanOrEqual} and
   * {@link Operator.LessThan LessThan} operators are not valid operators in
   * the FXR format. This method returns an equivalent condition that *is*
   * valid.
   */
  formatCondition() {
    if (this.operator !== Operator.LessThan && this.operator !== Operator.LessThanOrEqual) {
      return this
    }
    return new StateCondition(
      this.operator - 2, this.unk1, this.nextState,
      this.rightOperandType, this.rightOperandValue,
      this.leftOperandType, this.leftOperandValue
    )
  }

  clone() {
    return new StateCondition(
      this.operator, this.unk1, this.nextState,
      this.leftOperandType, this.leftOperandValue,
      this.rightOperandType, this.rightOperandValue
    )
  }

  #toString() {
    let left: string | number, right: string | number
    switch (this.leftOperandType) {
      case OperandType.External:
        left = `External(${this.leftOperandValue})`
        break
      case OperandType.UnkMinus2:
      case OperandType.StateTime:
        left = OperandType[this.leftOperandType]
        break
      case OperandType.Literal:
        left = this.leftOperandValue
        break
    }
    switch (this.rightOperandType) {
      case OperandType.External:
        right = `External(${this.rightOperandValue})`
        break
      case OperandType.UnkMinus2:
      case OperandType.StateTime:
        right = OperandType[this.rightOperandType]
        break
      case OperandType.Literal:
        right = this.rightOperandValue
        break
    }
    return `${left} ${['!=','==','>=','>','<=','<'][this.operator]} ${right} else ${this.nextState}`
  }

  toString() {
    return this.clone().sortOperands().#toString()
  }

}

//#region Node
/**
 * The base class for all nodes.
 * 
 * A node is a container with actions, configs, and other nodes, and they form
 * the tree structure of the FXR.
 */
abstract class Node {

  constructor(public readonly type: NodeType) {}

  abstract getActions(game: Game): AnyAction[]
  getConfigs(game: Game): IConfig[] { return [] }
  getNodes(game: Game): Node[] { return [] }
  abstract toJSON(): any
  abstract serialize(options?: FXRSerializeOptions): any
  minify(): Node { return this }
  abstract clone(depth?: number): Node

  static fromJSON(obj: any): Node {
    if (obj instanceof Node) {
      return obj
    }
    if (obj.$generic === true) {
      return GenericNode.fromJSON(obj)
    }
    switch (obj.type) {
      case NodeType.Root:
        return RootNode.fromJSON(obj)
      case NodeType.Proxy:
        return ProxyNode.fromJSON(obj)
      case NodeType.LevelsOfDetail:
        return LevelsOfDetailNode.fromJSON(obj)
      case NodeType.Basic:
        return BasicNode.fromJSON(obj)
      case NodeType.NodeEmitter:
        return NodeEmitterNode.fromJSON(obj)
      default:
        throw new Error(`Unrecognized non-generic node type: ${obj.type}`)
    }
  }

  /**
   * Yields all nodes in this branch, including this node.
   */
  *walk(): Generator<Node> {
    yield this
    if (
      this instanceof GenericNode ||
      this instanceof RootNode ||
      this instanceof NodeWithConfigs
    ) {
      for (const node of this.nodes) {
        yield* node.walk()
      }
    }
  }

  /**
   * Yields all configs in this branch.
   * @param recurse Controls whether or not to yield configs in descendant
   * nodes. Defaults to true.
   */
  *walkConfigs(recurse: boolean = true) {
    for (const node of recurse ? this.walk() : [this]) {
      if (node instanceof NodeWithConfigs || node instanceof GenericNode) {
        yield* node.configs
      }
    }
  }

  /**
   * Yields all actions in this branch, excluding node actions from
   * {@link NodeWithConfigs nodes with configs}, as those are not stored as
   * actions internally.
   * @param recurse Controls whether or not to yield actions in descendant
   * nodes. Defaults to true.
   */
  *walkActions(recurse: boolean = true) {
    for (const node of recurse ? this.walk() : [this]) {
      if (node instanceof GenericNode) {
        yield* node.actions
      } else if (node instanceof RootNode) {
        yield node.termination
        yield node.unk10100
        yield node.unk10400
        yield node.unk10500
      }
      if (node instanceof GenericNode || node instanceof NodeWithConfigs) {
        for (const config of node.configs) {
          yield* config.walkActions()
        }
      }
    }
  }

  /**
   * Yields all properties in this branch, excluding properties inside
   * modifiers and properties in the form of {@link PropertyValue}s in
   * {@link DataAction}s.
   * @param recurse Controls whether or not to yield properties in descendant
   * nodes. Defaults to true.
   */
  *walkProperties(recurse: boolean = true): Generator<AnyProperty, void, undefined> {
    for (const action of this.walkActions(recurse)) {
      if (action instanceof Action) {
        yield* action.properties1
        yield* action.properties2
      } else {
        if ('props' in action.$data) {
          for (const prop of Object.keys(action.$data.props)) {
            if (action[prop] instanceof Property) {
              yield action[prop]
            }
          }
        }
      }
    }
  }

  /**
   * Yields all unique color values in the branch, or optionally only ones in
   * the node.
   * @param [recurse=true] Controls whether or not to yield colors in
   * descendant nodes. Defaults to true.
   */
  *colors(recurse: boolean = true) {
    const colors = new Set<string>()
    for (const action of this.walkActions(recurse)) if (action instanceof DataAction) {
      for (const color of action.colors()) {
        const cs = color.join(',')
        if (!colors.has(cs)) {
          colors.add(cs)
          yield color
        }
      }
    }
  }

  /**
   * Scales the entire branch by a factor. This updates all sizes, offsets,
   * lengths, and radii of the actions in the branch, except certain
   * multiplicative fields and properties.
   * @param factor The factor to scale the branch with.
   * @param options.recurse Controls whether or not the scaling should be applied to
   * all descendant nodes. Defaults to true.
   */
  scale(factor: number, options: ScaleOptions & { recurse?: boolean } = defaultScaleOptions) {
    if (this instanceof NodeWithConfigs || this instanceof GenericNode) {
      for (const config of this.configs) {
        config.scale(factor, options)
      }
      if (this instanceof GenericNode) {
        for (const action of this.actions) if (action instanceof DataAction) {
          action.scale(factor, options)
        }
      }
    } else {
      for (const action of this.walkActions(false)) if (action instanceof DataAction) {
        action.scale(factor, options)
      }
    }
    if ((options.recurse ?? true) && (
      this instanceof GenericNode ||
      this instanceof RootNode ||
      this instanceof LevelsOfDetailNode ||
      this instanceof BasicNode ||
      this instanceof NodeEmitterNode
    )) {
      for (const node of this.nodes) {
        node.scale(factor, options)
      }
    }
    return this
  }

  /**
   * Recolors the entire branch, or optionally just this node, by modifying
   * color properties and fields using a given function.
   * @param func A function used to remap color values. For some easy pre-made
   * recolor functions, see the {@link Recolor} namespace.
   * @param recurse Controls whether or not the recoloring should be applied to
   * all descendant nodes. Defaults to true.
   */
  recolor(func: Recolor.RecolorFunction, recurse?: boolean): this

  /**
   * Recolors the entire branch, or optionally just this node, to fit a given
   * color palette.
   * @param palette The color palette to apply. This can be generated from
   * existing FXR branches using the {@link generateColorPalette} method.
   * @param recurse Controls whether or not the recoloring should be applied to
   * all descendant nodes. Defaults to true.
   */
  recolor(palette: Recolor.ColorPalette, recurse?: boolean): this

  recolor(funcOrPalette: Recolor.RecolorFunction | Recolor.ColorPalette, recurse: boolean = true) {
    if (typeof funcOrPalette === 'function') {
      for (const config of this.walkConfigs(recurse)) if (config instanceof BasicConfig) {
        config.recolor(funcOrPalette)
      }
    } else {
      const { palette, durationFallback, proc } = genFilledPaletteAndFunctions(funcOrPalette)

      for (const config of this.walkConfigs(recurse)) if (config instanceof BasicConfig) {
        config.recolor(palette, durationFallback, proc)
      }
    }
    return this
  }

  /**
   * Returns true if the node has a color in the given active state, and
   * otherwise returns false. This can be used as a fast way to check if
   * {@link getColor} will return a color or not.
   * @param activeState The index of a {@link State} to check.
   */
  abstract hasColor(activeState?: number): boolean

  /**
   * Gets a {@link Vector4Property color property} for the node based on the
   * given options. The returned color should equal the color of the visual
   * effect of the node in-game, if it has a visual effect, except property
   * modifiers and other forms of randomization are not applied. Nodes without
   * a visual effect will return `null` instead.
   * 
   * This may be useful for generating accurate color previews for nodes.
   */
  abstract getColor(opts?: NodeColorOptions): Vector4Property | null

  /**
   * Remaps all resource IDs in the entire branch.
   * @param func The function that is used to map the old resource IDs to the
   * new ones.
   * @param recurse Controls whether or not the remapping should be applied to
   * all descendant nodes. Defaults to true.
   */
  remapResources(func: (type: ResourceType, resource: number, textureType?: string) => number, recurse: boolean = true) {
    for (const action of this.walkActions(recurse)) {
      if (action instanceof DataAction) {
        for (const res of action.getResourceProperties()) {
          switch (res.type) {
            case ResourceType.Texture:
              action[res.property] = func(
                res.type,
                action[res.property] instanceof Property ? action[res.property].valueAt(0) : action[res.property],
                res.textureType
              )
              break
            case ResourceType.Model:
            case ResourceType.Anibnd:
            case ResourceType.Sound:
              action[res.property] = func(
                res.type,
                action[res.property] instanceof Property ? action[res.property].valueAt(0) : action[res.property]
              )
              break
          }
        }
      }
    }
  }

  /**
   * Generates a color palette that can be used to recolor other nodes based on
   * the colors in this branch.
   * @param mode Controls the behavior of the color sampler. See
   * {@link PaletteMode} for more information.
   */
  generateColorPalette(mode: PaletteMode = PaletteMode.Average): Recolor.ColorPalette {
    return Recolor.generatePalette([this], mode)
  }

  /**
   * Scale the rate of time for the branch, or optionally just the node.
   * 
   * This method's main purpose is to serve as a fallback for changing the rate
   * of time for Dark Souls 3 effects, which doesn't support the rateOfTime
   * property. The rate of time is automatically scaled when writing effects
   * for DS3, you do not need to do this yourself. As such, this method is only
   * useful if you want to scale the rate of time for individual parts of an
   * effect, or if you need the extra options available for this method.
   * @param factor The factor to scale the rate of time by. Setting this to 2
   * will make the node play twice as fast. Setting it to 0.5 will make it
   * play half as fast.
   * @param [options={}] Extra options for changing how the scaling is applied
   * to different properties and descendant nodes.
   */
  scaleRateOfTime(factor: number, options: { scaleTracerDuration?: boolean, recurse?: boolean } = {}) {
    for (const action of this.walkActions(options.recurse ?? true)) if (action instanceof DataAction) {
      action.scaleRateOfTime(factor, options)
    }
    return this
  }

  /**
   * Lists all resources (textures, models, animations, sounds) used in the
   * node. Useful for finding out what resources must exist for the effect to
   * work correctly, which is often needed when converting from one game to
   * another.
   * @param recurse Controls whether resources from descendant
   * nodes should be listed or not. Defaults to `true`.
   */
  getResources(recurse: boolean = true) {
    const reslist: {
      textures: { resource: ScalarValue, type: string }[],
      models: { resource: ScalarValue }[],
      anibnds: { resource: ScalarValue }[],
      sounds: { resource: ScalarValue }[]
    } = {
      textures: [],
      models: [],
      anibnds: [],
      sounds: []
    }
    for (const action of this.walkActions(recurse)) {
      if (action instanceof DataAction) {
        for (const res of action.getResourceProperties()) {
          switch (res.type) {
            case ResourceType.Texture:
              reslist.textures.push({ resource: action[res.property], type: res.textureType })
              break
            case ResourceType.Model:
              reslist.models.push({ resource: action[res.property] })
              break
            case ResourceType.Anibnd:
              reslist.anibnds.push({ resource: action[res.property] })
              break
            case ResourceType.Sound:
              reslist.sounds.push({ resource: action[res.property] })
              break
          }
        }
      }
    }
    const cleanList = (list: { resource: ScalarValue, type?: string }[]) => list.map(e => {
      if (e.resource instanceof Property) {
        e.resource = e.resource.valueAt(0)
      }
      return e
    }).filter((e, i, a) => e.resource !== 0 && a.findIndex(f =>
      f.resource === e.resource &&
      f.type === e.type
    ) === i).sort((a, b) => {
      if (a.resource instanceof Property) {
        if (b.resource instanceof Property) {
          return a.resource.valueAt(0) - b.resource.valueAt(0)
        } else {
          return a.resource.valueAt(0) - b.resource
        }
      } else {
        if (b.resource instanceof Property) {
          return a.resource - b.resource.valueAt(0)
        } else {
          return a.resource - b.resource
        }
      }
    }) as { resource: number }[]

    return {
      textures: cleanList(reslist.textures),
      models: cleanList(reslist.models).map(e => e.resource),
      anibnds: cleanList(reslist.anibnds).map(e => e.resource),
      sounds: cleanList(reslist.sounds).map(e => e.resource)
    } as {
      textures: { resource: number, type: string }[],
      models: number[],
      anibnds: number[],
      sounds: number[]
    }
  }

}

/**
 * This class has the same structure as a node in the FXR file format, meaning
 * it can be used to hold any information that a node from the format can. It
 * is meant to only be used as a fallback if none of the more specific node
 * classes can be used for something.
 */
class GenericNode extends Node {

  readonly $generic = true

  constructor(
    type: NodeType,
    public actions: AnyAction[],
    public configs: IConfig[],
    public nodes: Node[]
  ) {
    super(type)
  }

  hasColor(activeState?: number) { return false }
  getColor(opts?: NodeColorOptions): Vector4Property | null { return null }

  getActions(game: Game): AnyAction[] { return this.actions }
  getConfigs(game: Game): IConfig[] { return this.configs }
  getNodes(game: Game): Node[] { return this.nodes }

  static fromJSON({
    type,
    $generic,
    actions,
    configs,
    nodes
  }: {
    type: number
    $generic?: boolean
    actions: any[]
    configs?: any[]
    nodes?: any[]
  }) {
    if ($generic !== true) {
      throw new Error('Untagged generic node JSON. Generic nodes must have a `$generic` property with the value `true` in JSON form.')
    }
    return new GenericNode(
      type,
      actions.map(action => Action.fromJSON(action)),
      (configs ?? []).map(config => NodeConfig.fromJSON(config)),
      (nodes ?? []).map(node => Node.fromJSON(node))
    )
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions): any {
    const actionOptions: FXRSerializeOptions = Object.assign({}, options ?? {}, {
      requireActionDefinition: true
    })
    const obj = {
      type: this.type,
      $generic: true,
      actions: this.actions.map(action => action.serialize(actionOptions)),
      configs: this.configs.map(config => config.serialize(options)),
      nodes: this.nodes.map(node => node.serialize(options)),
    }
    if (serializeFilter('nodeList', options?.filter) && obj.nodes.length === 1) {
      delete obj.nodes
    }
    return obj
  }

  minify() {
    return new GenericNode(
      this.type,
      this.actions.map(action => action.minify()),
      this.configs.map(config => config.minify()),
      this.nodes.map(node => node.minify())
    )
  }

  clone(depth: number = Infinity): GenericNode {
    return new GenericNode(
      this.type,
      this.actions.map(e => e.clone()),
      this.configs.map(e => e.clone()),
      depth > 0 ? this.nodes.map(e => e.clone(depth - 1)) : [],
    )
  }

}

/**
 * The root of the FXR tree structure.
 */
class RootNode extends Node {

  termination: ActionSlots.TerminationAction = new SimulateTermination

  constructor(
    public nodes: Node[] = [],
    termination?: ActionSlots.TerminationAction,
    public unk10100: ActionSlots.Unknown10100Action = new Unk10100,
    public unk10400: ActionSlots.Unknown10400Action = new Unk10400,
    public unk10500: ActionSlots.Unknown10500Action = new Unk10500
  ) {
    super(NodeType.Root)
    if (termination !== undefined && termination !== null) {
      this.termination = termination
    }
  }

  hasColor(activeState?: number) { return false }
  getColor(opts?: NodeColorOptions): Vector4Property | null { return null }

  getActions(game: Game): AnyAction[] {
    switch (game) {
      case Game.DarkSouls3:
      case Game.Sekiro:
        return [
          this.unk10100,
          this.unk10400,
          this.unk10500
        ]
      case Game.EldenRing:
      case Game.ArmoredCore6:
      case Game.Nightreign:
        return [
          this.termination,
          this.unk10100,
          this.unk10400,
          this.unk10500
        ]
    }
  }

  getConfigs(game: Game): IConfig[] { return [] }
  getNodes(game: Game): Node[] { return this.nodes }

  minify(): Node {
    return new RootNode(
      this.nodes.map(node => node.minify()),
      this.termination.minify(),
      this.unk10100.minify(),
      this.unk10400.minify(),
      this.unk10500.minify()
    )
  }

  static fromJSON(obj: any): Node {
    if ('actions' in obj) {
      return GenericNode.fromJSON(obj)
    }
    return new RootNode(
      (obj.nodes ?? []).map(node => Node.fromJSON(node)),
      'termination' in obj ? Action.fromJSON(obj.termination) : undefined,
      'unk10100' in obj ? Action.fromJSON(obj.unk10100) : undefined,
      'unk10400' in obj ? Action.fromJSON(obj.unk10400) : undefined,
      'unk10500' in obj ? Action.fromJSON(obj.unk10500) : undefined
    )
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions): any {
    const obj = {
      type: this.type,
      termination: this.termination.serialize(options),
      unk10100: this.unk10100.serialize(options),
      unk10400: this.unk10400.serialize(options),
      unk10500: this.unk10500.serialize(options),
      nodes: this.nodes.map(node => node.serialize(options))
    }
    if (serializeFilter('nodeList', options?.filter) && obj.nodes.length === 0) {
      delete obj.nodes
    }
    if (serializeFilter('action', options?.filter)) {
      return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v !== undefined))
    }
    return obj
  }

  clone(depth: number = Infinity): RootNode {
    return new RootNode(
      depth > 0 ? this.nodes.map(e => e.clone(depth - 1)) : [],
      this.termination.clone() as ActionSlots.TerminationAction,
      this.unk10100.clone() as ActionSlots.Unknown10100Action,
      this.unk10400.clone() as ActionSlots.Unknown10400Action,
      this.unk10500.clone() as ActionSlots.Unknown10500Action,
    )
  }

  /**
   * Controls how fast time passes for the entire effect.
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  get rateOfTime() {
    if (this.unk10500 instanceof Unk10500) {
      return this.unk10500.rateOfTime
    } else {
      return 1
    }
  }
  set rateOfTime(value: ScalarValue) {
    if (this.unk10500 instanceof Unk10500) {
      this.unk10500.rateOfTime = value
    }
  }

}

/**
 * Acts as a node containing another SFX.
 * 
 * This node cannot contain other nodes.
 */
class ProxyNode extends Node {

  /**
   * @param sfx The ID of the SFX that this node should act as a proxy for.
   */
  constructor(public sfx: number) { super(NodeType.Proxy) }

  hasColor(activeState?: number) { return false }
  getColor(opts?: NodeColorOptions): Vector4Property | null { return null }

  getActions(game: Game): AnyAction[] {
    return [ new SFXReference(this.sfx) ]
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions) {
    return {
      type: this.type,
      sfx: this.sfx
    }
  }

  static fromJSON(obj: any) {
    if ('sfx' in obj) {
      return new ProxyNode(obj.sfx)
    } else {
      return GenericNode.fromJSON(obj)
    }
  }

  clone(depth?: number): ProxyNode {
    return new ProxyNode(this.sfx)
  }

}

/**
 * Super class for all types of nodes that contain {@link ConfigType configs}.
 */
abstract class NodeWithConfigs extends Node {

  /**
   * Maps FXR {@link State states} to node configs. The node will be disabled
   * if the current state maps to `-1`.
   */
  stateConfigMap: number[] = [0]

  constructor(type: NodeType, public configs: IConfig[], public nodes: Node[]) {
    super(type)
  }

  getActions(game: Game): AnyAction[] {
    return [ new StateConfigMap(this.stateConfigMap) ]
  }

  getConfigs(game: Game): IConfig[] {
    return this.configs
  }

  getNodes(game: Game): Node[] {
    return this.nodes
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions): any {
    const obj = {
      type: this.type,
      stateConfigMap: this.stateConfigMap,
      configs: this.configs.map(e => e.serialize(options)),
      nodes: this.nodes.map(e => e.serialize(options))
    }
    if (serializeFilter('nodeList', options?.filter) && obj.nodes.length === 0) {
      delete obj.nodes
    }
    return obj
  }

  mapStates(...configIndices: number[]) {
    this.stateConfigMap = configIndices
    return this
  }

  /**
   * Returns the config that is active when a given {@link State state} index
   * is active. If no configs are active for the state, this returns `null`
   * instead.
   * @param stateIndex The index of a {@link FXR.states state in the FXR}.
   */
  getActiveConfig(stateIndex: number): IConfig | null {
    return this.configs[this.stateConfigMap[stateIndex] ?? this.stateConfigMap[0]] ?? null
  }

}

/**
 * A node that only displays one of its child nodes at a time based on
 * distance thresholds for each.
 * 
 * This node can only manage up to five levels of detail. If you need more
 * levels, you can put another LOD node as the fifth child of this node and set
 * higher thresholds in that.
 */
class LevelsOfDetailNode extends NodeWithConfigs {

  declare configs: LevelsOfDetailConfig[]

  /**
   * @param thresholds An array of LOD thresholds.
   * @param nodes An array of child nodes.
   */
  constructor(thresholds: number[], nodes?: Node[])

  /**
   * @param configs An array of
   * {@link ConfigType.LevelsOfDetail LOD configs}.
   * @param nodes An array of child nodes.
   */
  constructor(configs: LevelsOfDetailConfig[], nodes?: Node[])

  constructor(configsOrThresholds: LevelsOfDetailConfig[] | number[], nodes: Node[] = []) {
    if (configsOrThresholds.every(e => typeof e === 'number')) {
      super(NodeType.LevelsOfDetail, [
        new LevelsOfDetailConfig(-1, configsOrThresholds)
      ], nodes)
    } else {
      super(NodeType.LevelsOfDetail, configsOrThresholds, nodes)
    }
  }

  hasColor(activeState?: number) { return false }
  getColor(opts?: NodeColorOptions): Vector4Property | null { return null }

  static fromJSON(obj: any): Node {
    if ('actions' in obj) {
      return GenericNode.fromJSON(obj)
    }
    const node = new LevelsOfDetailNode(
      (obj.configs ?? []).map((e: any) => NodeConfig.fromJSON(e)),
      (obj.nodes ?? []).map((e: any) => Node.fromJSON(e))
    )
    if ('stateConfigMap' in obj) {
      node.mapStates(...obj.stateConfigMap)
    }
    return node
  }

  minify(): Node {
    return new LevelsOfDetailNode(
      this.configs.map(e => e.minify()),
      this.nodes.map(e => e.minify())
    ).mapStates(...this.stateConfigMap)
  }

  clone(depth: number = Infinity): LevelsOfDetailNode {
    return new LevelsOfDetailNode(
      this.configs.map(e => e.clone()),
      depth > 0 ? this.nodes.map(e => e.clone(depth - 1)) : [],
    ).mapStates(...this.stateConfigMap)
  }

}

/**
 * A basic node that can have transforms and child nodes, and emit particles.
 */
class BasicNode extends NodeWithConfigs {

  declare configs: BasicConfig[]

  /**
   * @param list A list of configs, or a list of actions to construct a
   * {@link BasicConfig} with.
   * @param nodes A list of child nodes.
   */
  constructor(list: BasicConfig[] | AnyAction[] = [], nodes: Node[] = []) {
    if (!Array.isArray(nodes) || nodes.some(e => !(e instanceof Node))) {
      throw new Error('Non-node passed as node to BasicNode.')
    }
    if (list.every(e => e instanceof Action || e instanceof DataAction)) {
      super(NodeType.Basic, [
        new BasicConfig(list)
      ], nodes)
    } else {
      super(
        NodeType.Basic,
        list,
        nodes
      )
    }
  }

  hasColor(activeState: number = 0) {
    const config = this.getActiveConfig(activeState)
    if (config) {
      return config instanceof BasicConfig && (
        config.appearance instanceof PointLight ||
        config.appearance instanceof GPUStandardParticle ||
        config.appearance instanceof GPUStandardCorrectParticle ||
        config.appearance instanceof LightShaft ||
        config.appearance instanceof GPUSparkParticle ||
        config.appearance instanceof GPUSparkCorrectParticle ||
        config.appearance instanceof LensFlare ||
        config.appearance instanceof SpotLight ||
        config.particleModifier instanceof ParticleModifier && (
          config.appearance instanceof PointSprite ||
          config.appearance instanceof Line ||
          config.appearance instanceof QuadLine ||
          config.appearance instanceof BillboardEx ||
          config.appearance instanceof MultiTextureBillboardEx ||
          config.appearance instanceof Model ||
          config.appearance instanceof LegacyTracer ||
          config.appearance instanceof Distortion ||
          config.appearance instanceof RadialBlur ||
          config.appearance instanceof Tracer ||
          config.appearance instanceof RichModel
        )
      )
    }
    return false
  }

  getColor(opts: NodeColorOptions = {}): Vector4Property | null {
    let colorProp: Property<ValueType.Vector4, PropertyFunction> = new ConstantProperty([1, 1, 1, 1])
    let modified = false
    const config = this.getActiveConfig(opts.activeState ?? 0)
    if (config instanceof BasicConfig) {
      const a = config.appearance
      if (
        config.particleModifier instanceof ParticleModifier && (
          a instanceof PointSprite ||
          a instanceof BillboardEx ||
          a instanceof Model ||
          a instanceof LegacyTracer ||
          a instanceof Tracer ||
          a instanceof RichModel
        )
      ) {
        colorProp = anyValueMult(
          anyValueMult(
            clampVec4Value(a.color2),
            clampVec4Value(a.color1),
          ),
          anyValueMult(
            clampVec4Value(config.particleModifier.color),
            a.color3,
          ),
        )
        const loop = getLoop(colorProp) || getLoop(a.rgbMultiplier) || getLoop(a.alphaMultiplier)
        colorProp = setLoop(anyValueMult(
          combineComponents(
            a.rgbMultiplier,
            a.rgbMultiplier,
            a.rgbMultiplier,
            a.alphaMultiplier,
          ),
          setLoop(colorProp, true)
        ), loop) as any
        modified = true
      } else if (
        config.particleModifier instanceof ParticleModifier && (
          a instanceof Line ||
          a instanceof QuadLine
        )
      ) {
        colorProp = anyValueMult(
          anyValueMult(
            anyValueMult(
              clampVec4Value(a.color1),
              clampVec4Value(a.color2),
            ),
            anyValueMult(
              clampVec4Value(config.particleModifier.color),
              clampVec4Value(a.color3),
            ),
          ),
          opts.side === 'start' ? clampVec4Value(a.startColor) :
          opts.side === 'end' ? clampVec4Value(a.endColor) :
          anyValueMult(
            0.5,
            anyValueSum(
              clampVec4Value(a.startColor),
              clampVec4Value(a.endColor),
            ),
          ),
        )
        const loop = getLoop(colorProp) || getLoop(a.rgbMultiplier) || getLoop(a.alphaMultiplier)
        colorProp = setLoop(anyValueMult(
          combineComponents(
            a.rgbMultiplier,
            a.rgbMultiplier,
            a.rgbMultiplier,
            a.alphaMultiplier,
          ),
          setLoop(colorProp, true)
        ), loop) as any
        modified = true
      } else if (
        config.particleModifier instanceof ParticleModifier &&
        a instanceof MultiTextureBillboardEx
      ) {
        colorProp = anyValueMult(
          clampVec4Value(opts.layer === 2 ? a.layer2Color : opts.layer === 3 ? a.layer3Color : a.layer1Color),
          anyValueMult(
            anyValueMult(
              clampVec4Value(a.color2),
              clampVec4Value(a.color1),
            ),
            anyValueMult(
              clampVec4Value(config.particleModifier.color),
              a.color3,
            ),
          )
        )
        const loop = getLoop(colorProp) || getLoop(a.rgbMultiplier) || getLoop(a.alphaMultiplier)
        colorProp = setLoop(anyValueMult(
          combineComponents(
            a.rgbMultiplier,
            a.rgbMultiplier,
            a.rgbMultiplier,
            a.alphaMultiplier,
          ),
          setLoop(colorProp, true)
        ), loop) as any
        modified = true
      } else if (
        config.particleModifier instanceof ParticleModifier && (
          a instanceof Distortion ||
          a instanceof RadialBlur
        )
      ) {
        colorProp = anyValueMult(
          clampVec4Value(config.particleModifier.color),
          clampVec4Value(a.color),
        )
        const loop = getLoop(colorProp) || getLoop(a.rgbMultiplier) || getLoop(a.alphaMultiplier)
        colorProp = setLoop(anyValueMult(
          combineComponents(
            a.rgbMultiplier,
            a.rgbMultiplier,
            a.rgbMultiplier,
            a.alphaMultiplier,
          ),
          setLoop(colorProp, true)
        ), loop) as any
        modified = true
      } else if (
        a instanceof GPUStandardParticle ||
        a instanceof GPUStandardCorrectParticle ||
        a instanceof GPUSparkParticle ||
        a instanceof GPUSparkCorrectParticle
      ) {
        colorProp = anyValueSum(
          LinearProperty.basic(
            false,
            a.particleDuration * a.particleDurationMultiplier,
            anyValueMult(0.5, anyValueSum(a.colorMin, a.colorMax)),
            [0, 0, 0, 0]
          ),
          a.color
        )
        const loop = getLoop(colorProp)
        colorProp = setLoop(anyValueMult(
          combineComponents(
            a.rgbMultiplier,
            a.rgbMultiplier,
            a.rgbMultiplier,
            a.alphaMultiplier,
          ),
          setLoop(colorProp, true)
        ), loop) as any
        modified = true
      } else if (
        a instanceof PointLight ||
        a instanceof SpotLight
      ) {
        colorProp = a.diffuseColor as any
        modified = true
      } else if (a instanceof LensFlare) {
        switch (opts.layer ?? 1) {
          case 1: colorProp = anyValueMult(clampVec4Value(a.layer1Color), a.layer1ColorMultiplier) as any; break
          case 2: colorProp = anyValueMult(clampVec4Value(a.layer2Color), a.layer2ColorMultiplier) as any; break
          case 3: colorProp = anyValueMult(clampVec4Value(a.layer3Color), a.layer3ColorMultiplier) as any; break
          case 4: colorProp = anyValueMult(clampVec4Value(a.layer4Color), a.layer4ColorMultiplier) as any; break
        }
        modified = true
      } else if (a instanceof LightShaft) {
        colorProp = anyValueMult(
          anyValueMult(
            a.color2,
            a.color1,
          ),
          a.color3,
        )
        modified = true
      }
      if (!(colorProp instanceof Property)) {
        colorProp = new ConstantProperty(colorProp as Vector4)
      }
    }
    if (modified) {
      return colorProp
    }
    return null
  }

  static fromJSON(obj: any): Node {
    if ('actions' in obj) {
      return GenericNode.fromJSON(obj)
    }
    const node = new BasicNode(
      (obj.configs ?? []).map((e: any) => NodeConfig.fromJSON(e)),
      (obj.nodes ?? []).map((e: any) => Node.fromJSON(e))
    )
    if ('stateConfigMap' in obj) {
      node.mapStates(...obj.stateConfigMap)
    }
    return node
  }

  minify(): Node {
    return new BasicNode(
      this.configs.map(e => e.minify()),
      this.nodes.map(e => e.minify())
    ).mapStates(...this.stateConfigMap)
  }

  clone(depth: number = Infinity): BasicNode {
    return new BasicNode(
      this.configs.map(e => e.clone()),
      depth > 0 ? this.nodes.map(e => e.clone(depth - 1)) : [],
    ).mapStates(...this.stateConfigMap)
  }

  static chain(...links: OptionalTail<BasicConfig[] | AnyAction[], Node[]>) {
    const start = new BasicNode(links[0])
    let node = start
    for (let i = 1; i < links.length; i++) {
      const link = links[i]
      if (link.length === 0) {
        throw new Error('Each chain link must contain at least one config, action, or node.')
      }
      if (i < links.length - 1 && isNodeArray(link)) {
        throw new Error('Only the last link in a chain can contain nodes.')
      }
      if (!isNodeArray(link)) {
        node.nodes = [ node = new BasicNode(link) ]
      } else {
        node.nodes = links[i] as Node[]
      }
    }
    return start
  }

}

/**
 * A node that emits its child nodes.
 */
class NodeEmitterNode extends NodeWithConfigs {

  declare configs: NodeEmitterConfig[]

  /**
   * @param actions A list of actions to construct a {@link NodeEmitterConfig} with.
   * @param nodes A list of child nodes.
   */
  constructor(actions?: AnyAction[], nodes?: Node[])

  /**
   * @param configs A list of configs.
   * @param nodes A list of child nodes.
   */
  constructor(configs?: NodeEmitterConfig[], nodes?: Node[])

  constructor(configsOrConfigActions: NodeEmitterConfig[] | AnyAction[] = [], nodes: Node[] = []) {
    if (!Array.isArray(nodes) || nodes.some(e => !(e instanceof Node))) {
      throw new Error('Non-node passed as node to NodeEmitterNode.')
    }
    if (configsOrConfigActions.every(e => e instanceof Action || e instanceof DataAction)) {
      super(NodeType.NodeEmitter, [
        new NodeEmitterConfig(configsOrConfigActions)
      ], nodes)
    } else {
      super(
        NodeType.NodeEmitter,
        configsOrConfigActions,
        nodes
      )
    }
  }

  hasColor(activeState?: number) { return false }
  getColor(opts?: NodeColorOptions): Vector4Property | null { return null }

  static fromJSON(obj: any): Node {
    if ('actions' in obj) {
      return GenericNode.fromJSON(obj)
    }
    const node = new NodeEmitterNode(
      (obj.configs ?? []).map((e: any) => NodeConfig.fromJSON(e)),
      (obj.nodes ?? []).map((e: any) => Node.fromJSON(e))
    )
    if ('stateConfigMap' in obj) {
      node.mapStates(...obj.stateConfigMap)
    }
    return node
  }

  minify(): NodeEmitterNode {
    return new NodeEmitterNode(
      this.configs.map(e => e.minify()),
      this.nodes.map(e => e.minify())
    ).mapStates(...this.stateConfigMap)
  }

  clone(depth: number = Infinity): NodeEmitterNode {
    return new NodeEmitterNode(
      this.configs.map(e => e.clone()),
      depth > 0 ? this.nodes.map(e => e.clone(depth - 1)) : [],
    ).mapStates(...this.stateConfigMap)
  }

}

const Nodes = {
  [NodeType.Root]: RootNode, RootNode,
  [NodeType.Proxy]: ProxyNode, ProxyNode,
  [NodeType.LevelsOfDetail]: LevelsOfDetailNode, LevelsOfDetailNode,
  [NodeType.Basic]: BasicNode, BasicNode,
}

//#region Config
/**
 * Generic config class that uses the same structure as the file format. Only
 * for use with undocumented config types. Use one of the other config
 * classes for configs that are known:
 * - {@link LevelsOfDetailConfig}
 * - {@link BasicConfig}
 * - {@link NodeEmitterConfig}
 */
class NodeConfig implements IConfig {

  readonly $generic = true

  constructor(public type: ConfigType, public actions: AnyAction[]) {}

  getActionCount(game: Game): number {
    return this.actions.length
  }

  getActions(game: Game): AnyAction[] {
    return this.actions
  }

  toJSON = this.serialize

  serialize(options?: FXRSerializeOptions): any {
    const actionOptions: FXRSerializeOptions = Object.assign({}, options ?? {}, {
      requireActionDefinition: true
    })
    return {
      type: this.type,
      $generic: true,
      actions: this.actions.map(action => action.serialize(actionOptions))
    }
  }

  minify() {
    this.actions = this.actions.map(action => action.minify())
    return this
  }

  *walkActions() {
    yield* this.actions
  }

  static fromJSON(obj: any): IConfig {
    if (
      obj instanceof NodeConfig ||
      obj instanceof LevelsOfDetailConfig ||
      obj instanceof BasicConfig ||
      obj instanceof NodeEmitterConfig
    ) {
      return obj
    }
    if (obj.$generic === true) {
      return new NodeConfig(obj.type, obj.actions.map((e: any) => Action.fromJSON(e)))
    } else switch (obj.type) {
      case ConfigType.LevelsOfDetail:
        return new LevelsOfDetailConfig(Property.fromJSON<ValueType.Scalar>(obj.duration), obj.thresholds, obj.unk_ac6_f1_5)
      case ConfigType.Basic: {
        const actions: Partial<Props<BasicConfig>> = {}
        if ('nodeAttributes' in obj) actions.nodeAttributes = Action.fromJSON(obj.nodeAttributes)
        if ('nodeTransform' in obj) actions.nodeTransform = Action.fromJSON(obj.nodeTransform)
        if ('nodeMovement' in obj) actions.nodeMovement = Action.fromJSON(obj.nodeMovement)
        if ('nodeAudio' in obj) actions.nodeAudio = Action.fromJSON(obj.nodeAudio)
        if ('emitter' in obj) actions.emitter = Action.fromJSON(obj.emitter)
        if ('emitterShape' in obj) actions.emitterShape = Action.fromJSON(obj.emitterShape)
        if ('directionSpread' in obj) actions.directionSpread = Action.fromJSON(obj.directionSpread)
        if ('particleModifier' in obj) actions.particleModifier = Action.fromJSON(obj.particleModifier)
        if ('particleAttributes' in obj) actions.particleAttributes = Action.fromJSON(obj.particleAttributes)
        if ('appearance' in obj) actions.appearance = Action.fromJSON(obj.appearance)
        if ('particleMovement' in obj) actions.particleMovement = Action.fromJSON(obj.particleMovement)
        if ('emissionAudio' in obj) actions.emissionAudio = Action.fromJSON(obj.emissionAudio)
        if ('slot12' in obj) actions.slot12 = Action.fromJSON(obj.slot12)
        if ('nodeForceMovement' in obj) actions.nodeForceMovement = Action.fromJSON(obj.nodeForceMovement)
        if ('particleForceMovement' in obj) actions.particleForceMovement = Action.fromJSON(obj.particleForceMovement)
        return new BasicConfig(actions)
      }
      case ConfigType.NodeEmitter: {
        const actions: Partial<Props<NodeEmitterConfig>> = {}
        if ('nodeAttributes' in obj) actions.nodeAttributes = Action.fromJSON(obj.nodeAttributes)
        if ('nodeTransform' in obj) actions.nodeTransform = Action.fromJSON(obj.nodeTransform)
        if ('nodeMovement' in obj) actions.nodeMovement = Action.fromJSON(obj.nodeMovement)
        if ('nodeAudio' in obj) actions.nodeAudio = Action.fromJSON(obj.nodeAudio)
        if ('emitter' in obj) actions.emitter = Action.fromJSON(obj.emitter)
        if ('emitterShape' in obj) actions.emitterShape = Action.fromJSON(obj.emitterShape)
        if ('directionSpread' in obj) actions.directionSpread = Action.fromJSON(obj.directionSpread)
        if ('nodeSelector' in obj) actions.nodeSelector = Action.fromJSON(obj.nodeSelector)
        if ('emissionAudio' in obj) actions.emissionAudio = Action.fromJSON(obj.emissionAudio)
        if ('nodeForceMovement' in obj) actions.nodeForceMovement = Action.fromJSON(obj.nodeForceMovement)
        return new NodeEmitterConfig(actions)
      }
    }
    throw new Error('Invalid config JSON: ' + JSON.stringify(obj))
  }

  clone(): NodeConfig {
    return new NodeConfig(
      this.type,
      this.actions.map(e => e.clone()),
    )
  }

  scale(factor: number, options: ScaleOptions = defaultScaleOptions) {
    for (const action of this.walkActions()) if (action instanceof DataAction) {
      action.scale(factor, options)
    }
    return this
  }

}

/**
 * Manages the duration and thresholds for the
 * {@link NodeType.LevelsOfDetail levels of detail node}.
 */
class LevelsOfDetailConfig implements IConfig {
  readonly type = ConfigType.LevelsOfDetail

  /**
   * @param duration The duration for the node to stay active. Once its time is
   * up, it will deactivate and none of the child nodes will be visible/audible
   * anymore. Can be set to -1 to make the node last forever.
   * @param thresholds An array of distance thresholds. Each threshold is used
   * for the child node of the same index.
   * @param unk_ac6_f1_5 An unknown integer field from AC6 that is always 0 or
   * 1 in vanilla. Defaults to 0.
   */
  constructor(public duration: ScalarValue, public thresholds: number[], public unk_ac6_f1_5: number = 0) {}

  getActionCount(game: Game): number {
    return 1
  }

  getActions(game: Game): AnyAction[] {
    return [
      new LevelsOfDetailThresholds({
        duration: this.duration,
        threshold0: this.thresholds[0],
        threshold1: this.thresholds[1],
        threshold2: this.thresholds[2],
        threshold3: this.thresholds[3],
        threshold4: this.thresholds[4],
        unk_ac6_f1_5: this.unk_ac6_f1_5
      })
    ]
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions): any {
    return {
      type: this.type,
      duration: this.duration instanceof Property ? this.duration.serialize(options) : this.duration,
      thresholds: this.thresholds.slice(0, 5),
      ...!serializeFilter('unknownProperty', options?.filter) && this.unk_ac6_f1_5 !== 0 && { unk_ac6_f1_5: this.unk_ac6_f1_5 }
    }
  }

  minify() {
    return this
  }

  *walkActions() {}

  clone(): LevelsOfDetailConfig {
    return new LevelsOfDetailConfig(
      this.duration,
      this.thresholds.slice(),
      this.unk_ac6_f1_5,
    )
  }

  scale(factor: number, options: ScaleOptions = defaultScaleOptions) {
    if (options.scaleStructural && options.scaleViewDistance) {
      this.thresholds = this.thresholds.slice(0, 5).map(t => t * factor)
    }
    return this
  }

}

/**
 * Config used in {@link NodeType.Basic basic nodes} to apply transforms and
 * emit particles of many different types.
 * 
 * Default actions:
 * Index | Slot | Action
 * :-----|:-----|:------
 * 0     | {@link ActionSlots.NodeAttributesAction NodeAttributes} | {@link ActionType.NodeAttributes NodeAttributes}
 * 1     | {@link ActionSlots.NodeTransformAction NodeTransform} | {@link ActionType.None None}
 * 2     | {@link ActionSlots.NodeMovementAction NodeMovement} | {@link ActionType.None None}
 * 3     | {@link ActionSlots.NodeAudioAction NodeAudio} | {@link ActionType.None None}
 * 4     | {@link ActionSlots.EmitterAction Emitter} | {@link ActionType.OneTimeEmitter OneTimeEmitter}
 * 5     | {@link ActionSlots.EmitterShapeAction EmitterShape} | {@link ActionType.PointEmitterShape PointEmitterShape}
 * 6     | {@link ActionSlots.DirectionSpreadAction DirectionSpread} | {@link ActionType.NoSpread NoSpread}
 * 7     | {@link ActionSlots.ParticleModifierAction ParticleModifier} | {@link ActionType.ParticleModifier ParticleModifier}
 * 8     | {@link ActionSlots.ParticleAttributesAction ParticleAttributes} | {@link ActionType.ParticleAttributes ParticleAttributes}
 * 9     | {@link ActionSlots.AppearanceAction Appearance} | {@link ActionType.None None}
 * 10    | {@link ActionSlots.ParticleMovementAction ParticleMovement} | {@link ActionType.None None}
 * 11    | {@link ActionSlots.EmissionAudioAction EmissionAudio} | {@link ActionType.None None}
 * 12    | {@link ActionSlots.Unknown130Action Unknown130} | {@link ActionType.Unk130 Unk130}
 * 13    | {@link ActionSlots.NodeForceMovementAction NodeForceMovement} | {@link ActionType.None None}
 * 14    | {@link ActionSlots.ParticleForceMovementAction ParticleForceMovement} | {@link ActionType.None None}
 */
class BasicConfig implements IConfig {
  readonly type = ConfigType.Basic

  nodeAttributes: ActionSlots.NodeAttributesAction = new NodeAttributes
  nodeTransform: ActionSlots.NodeTransformAction = new Action
  nodeMovement: ActionSlots.NodeMovementAction = new Action
  nodeAudio: ActionSlots.NodeAudioAction = new Action
  emitter: ActionSlots.EmitterAction = new OneTimeEmitter
  emitterShape: ActionSlots.EmitterShapeAction = new PointEmitterShape
  directionSpread: ActionSlots.DirectionSpreadAction = new NoSpread
  particleModifier: ActionSlots.ParticleModifierAction = new ParticleModifier
  particleAttributes: ActionSlots.ParticleAttributesAction = new ParticleAttributes
  appearance: ActionSlots.AppearanceAction = new Action
  particleMovement: ActionSlots.ParticleMovementAction = new Action
  emissionAudio: ActionSlots.EmissionAudioAction = new Action
  slot12: ActionSlots.Unknown130Action = new Unk130
  nodeForceMovement: ActionSlots.NodeForceMovementAction = new Action
  particleForceMovement: ActionSlots.ParticleForceMovementAction = new Action

  constructor(actions: Partial<Props<BasicConfig>> | AnyAction[] = []) {
    if (Array.isArray(actions)) {
      for (const action of actions) {
        const index = ConfigActionSlots[ConfigType.Basic].findIndex(a => a.includes(action.type))
        switch (index) {
          case 0:  this.nodeAttributes        = action as Action; break;
          case 1:  this.nodeTransform         = action as Action; break;
          case 2:  this.nodeMovement          = action as Action; break;
          case 3:  this.nodeAudio             = action as Action; break;
          case 4:  this.emitter               = action as Action; break;
          case 5:  this.emitterShape          = action as Action; break;
          case 6:  this.directionSpread       = action as Action; break;
          case 7:  this.particleModifier      = action as Action; break;
          case 8:  this.particleAttributes    = action as Action; break;
          case 9:  this.appearance            = action as Action; break;
          case 10: this.particleMovement      = action as Action; break;
          case 11: this.emissionAudio         = action as Action; break;
          case 12: this.slot12                = action as Action; break;
          case 13: this.nodeForceMovement     = action as Action; break;
          case 14: this.particleForceMovement = action as Action; break;
        }
      }
    } else {
      if ('nodeAttributes' in actions) this.nodeAttributes = actions.nodeAttributes
      if ('nodeTransform' in actions) this.nodeTransform = actions.nodeTransform
      if ('nodeMovement' in actions) this.nodeMovement = actions.nodeMovement
      if ('nodeAudio' in actions) this.nodeAudio = actions.nodeAudio
      if ('emitter' in actions) this.emitter = actions.emitter
      if ('emitterShape' in actions) this.emitterShape = actions.emitterShape
      if ('directionSpread' in actions) this.directionSpread = actions.directionSpread
      if ('particleModifier' in actions) this.particleModifier = actions.particleModifier
      if ('particleAttributes' in actions) this.particleAttributes = actions.particleAttributes
      if ('appearance' in actions) this.appearance = actions.appearance
      if ('particleMovement' in actions) this.particleMovement = actions.particleMovement
      if ('emissionAudio' in actions) this.emissionAudio = actions.emissionAudio
      if ('slot12' in actions) this.slot12 = actions.slot12
      if ('nodeForceMovement' in actions) this.nodeForceMovement = actions.nodeForceMovement
      if ('particleForceMovement' in actions) this.particleForceMovement = actions.particleForceMovement
    }
  }

  getActionCount(game: Game): number {
    return game === Game.DarkSouls3 ? 13 : 15
  }

  getActions(game: Game): AnyAction[] {
    return [
      this.nodeAttributes,
      this.nodeTransform,
      this.nodeMovement,
      this.nodeAudio,
      this.emitter,
      this.emitterShape,
      this.directionSpread,
      this.particleModifier,
      this.particleAttributes,
      this.appearance,
      this.particleMovement,
      this.emissionAudio,
      this.slot12,
      game === Game.DarkSouls3 ? [] : [
        this.nodeForceMovement,
        this.particleForceMovement,
      ]
    ].flat()
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions): any {
    const obj = {
      type: this.type,
      nodeAttributes: this.nodeAttributes.serialize(options),
      nodeTransform: this.nodeTransform.serialize(options),
      nodeMovement: this.nodeMovement.serialize(options),
      nodeAudio: this.nodeAudio.serialize(options),
      emitter: this.emitter.serialize(options),
      emitterShape: this.emitterShape.serialize(options),
      directionSpread: this.directionSpread.serialize(options),
      particleModifier: this.particleModifier.serialize(options),
      particleAttributes: this.particleAttributes.serialize(options),
      appearance: this.appearance.serialize(options),
      particleMovement: this.particleMovement.serialize(options),
      emissionAudio: this.emissionAudio.serialize(options),
      slot12: this.slot12.serialize(options),
      nodeForceMovement: this.nodeForceMovement.serialize(options),
      particleForceMovement: this.particleForceMovement.serialize(options),
    }
    if (serializeFilter('action', options?.filter)) {
      return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v !== undefined))
    }
    return obj
  }

  minify() {
    this.nodeAttributes = this.nodeAttributes.minify()
    this.nodeTransform = this.nodeTransform.minify()
    this.nodeMovement = this.nodeMovement.minify()
    this.nodeAudio = this.nodeAudio.minify()
    this.emitter = this.emitter.minify()
    this.emitterShape = this.emitterShape.minify()
    this.directionSpread = this.directionSpread.minify()
    this.particleModifier = this.particleModifier.minify()
    this.particleAttributes = this.particleAttributes.minify()
    this.appearance = this.appearance.minify()
    this.particleMovement = this.particleMovement.minify()
    this.emissionAudio = this.emissionAudio.minify()
    this.slot12 = this.slot12.minify()
    this.nodeForceMovement = this.nodeForceMovement.minify()
    this.particleForceMovement = this.particleForceMovement.minify()
    return this
  }

  *walkActions() {
    yield this.nodeAttributes
    yield this.nodeTransform
    yield this.nodeMovement
    yield this.nodeAudio
    yield this.emitter
    yield this.emitterShape
    yield this.directionSpread
    yield this.particleModifier
    yield this.particleAttributes
    yield this.appearance
    yield this.particleMovement
    yield this.emissionAudio
    yield this.slot12
    yield this.nodeForceMovement
    yield this.particleForceMovement
  }

  clone(): BasicConfig {
    return new BasicConfig({
      nodeAttributes: this.nodeAttributes.clone() as ActionSlots.NodeAttributesAction,
      nodeTransform: this.nodeTransform.clone() as ActionSlots.NodeTransformAction,
      nodeMovement: this.nodeMovement.clone() as ActionSlots.NodeMovementAction,
      nodeAudio: this.nodeAudio.clone() as ActionSlots.NodeAudioAction,
      emitter: this.emitter.clone() as ActionSlots.EmitterAction,
      emitterShape: this.emitterShape.clone() as ActionSlots.EmitterShapeAction,
      directionSpread: this.directionSpread.clone() as ActionSlots.DirectionSpreadAction,
      particleModifier: this.particleModifier.clone() as ActionSlots.ParticleModifierAction,
      particleAttributes: this.particleAttributes.clone() as ActionSlots.ParticleAttributesAction,
      appearance: this.appearance.clone() as ActionSlots.AppearanceAction,
      particleMovement: this.particleMovement.clone() as ActionSlots.ParticleMovementAction,
      emissionAudio: this.emissionAudio.clone() as ActionSlots.EmissionAudioAction,
      slot12: this.slot12.clone() as ActionSlots.Unknown130Action,
      nodeForceMovement: this.nodeForceMovement.clone() as ActionSlots.NodeForceMovementAction,
      particleForceMovement: this.particleForceMovement.clone() as ActionSlots.ParticleForceMovementAction,
    })
  }

  scale(factor: number, options: ScaleOptions = defaultScaleOptions) {
    for (const action of this.walkActions()) if (action instanceof DataAction) {
      action.scale(factor, options)
    }
    return this
  }

  /**
   * Recolors the config by modifying color properties and fields using a given
   * function.
   * @param func A function used to remap color values. For some easy pre-made
   * recolor functions, see the {@link Recolor} namespace.
   */
  recolor(func: Recolor.RecolorFunction): this

  /**
   * Recolors the config to fit a given color palette.
   * @param palette The color palette to apply. This can be generated from
   * existing FXR branches using the {@link Node.generateColorPalette} method.
   */
  recolor(palette: Recolor.ColorPalette): this

  /**
   * @internal
   */
  recolor(
    funcOrPalette: Recolor.RecolorFunction | Recolor.ColorPalette,
    __durationFallback?: (action: any, secondary?: any) => () => any,
    __proc?: <T>(paletteProp: AnyValue, c: T, k: keyof T, durationFallback?: () => number) => void
  ): this

  recolor(
    funcOrPalette: Recolor.RecolorFunction | Recolor.ColorPalette,
    __durationFallback?: (action: any, secondary?: any) => () => any,
    __proc?: <T>(paletteProp: AnyValue, c: T, k: keyof T, durationFallback?: () => number) => void
  ): this {
    if (typeof funcOrPalette === 'function') {
      for (const action of this.walkActions()) if (action instanceof DataAction) {
        action.recolor(funcOrPalette, this)
      }
    } else {
      const { palette, durationFallback, proc } = typeof __durationFallback === 'function' ? {
        palette: funcOrPalette,
        durationFallback: __durationFallback,
        proc: __proc,
      } : genFilledPaletteAndFunctions(funcOrPalette)

      const a = this.appearance
      if (
        a instanceof PointSprite ||
        a instanceof Line ||
        a instanceof QuadLine ||
        a instanceof BillboardEx ||
        a instanceof MultiTextureBillboardEx ||
        a instanceof Model ||
        a instanceof RichModel ||
        a instanceof LegacyTracer ||
        a instanceof Tracer
      ) {
        if (!(this.particleModifier instanceof ParticleModifier)) return this
        if (a instanceof MultiTextureBillboardEx) {
          a.recolorProperty('layer1Color', Recolor.grayscale)
          a.recolorProperty('layer2Color', Recolor.grayscale)
          a.recolorProperty('layer3Color', Recolor.grayscale)
        } else if (a instanceof Line || a instanceof QuadLine) {
          a.recolorProperty('startColor', Recolor.grayscale)
          a.recolorProperty('endColor', Recolor.grayscale)
        }
        let blendMode = 'blendMode' in a ? a.blendMode : BlendMode.Normal
        if (blendMode instanceof Property) {
          blendMode = blendMode.valueAt(0)
        }
        if (blendMode === BlendMode.Source || blendMode === BlendMode.Unk6) {
          blendMode = BlendMode.Normal
        } else if (blendMode === BlendMode.Unk0 || blendMode === BlendMode.Unk7) {
          blendMode = BlendMode.Add
        }
        const key = `commonParticle${BlendMode[blendMode]}` as KeysOfType<
          Recolor.ColorPalette,
          Recolor.PaletteSlots['CommonParticle'][]
        >
        const pc = randomItem(palette[key])
        const ndf = durationFallback(this.nodeAttributes)
        const pdf = durationFallback(this.particleAttributes, this.nodeAttributes)
        proc(pc.modifier, this.particleModifier, 'color', ndf)
        proc(pc.color1, a, 'color1', pdf)
        proc(pc.color2, a, 'color2', ndf)
        proc(pc.color3, a, 'color3', pdf)
        proc(pc.rgbMultiplier, a, 'rgbMultiplier', ndf)
        proc(pc.bloomColor, a, 'bloomColor')
      } else if (a instanceof Distortion) {
        if (!(this.particleModifier instanceof ParticleModifier)) return this
        const pc = randomItem(palette.distortionParticle)
        const ndf = durationFallback(this.nodeAttributes)
        const pdf = durationFallback(this.particleAttributes, this.nodeAttributes)
        proc(pc.modifier, this.particleModifier, 'color', ndf)
        proc(pc.color, a, 'color', pdf)
        proc(pc.rgbMultiplier, a, 'rgbMultiplier', ndf)
        proc(pc.bloomColor, a, 'bloomColor')
      } else if (a instanceof RadialBlur) {
        if (!(this.particleModifier instanceof ParticleModifier)) return this
        const pc = randomItem(palette.blurParticle)
        const ndf = durationFallback(this.nodeAttributes)
        const pdf = durationFallback(this.particleAttributes, this.nodeAttributes)
        proc(pc.modifier, this.particleModifier, 'color', ndf)
        proc(pc.color, a, 'color', pdf)
        proc(pc.rgbMultiplier, a, 'rgbMultiplier', ndf)
        proc(pc.bloomColor, a, 'bloomColor')
      } else if (a instanceof PointLight || a instanceof SpotLight) {
        const pc = randomItem(palette.light)
        const df = durationFallback(this.nodeAttributes)
        proc(pc.diffuseColor, a, 'diffuseColor', df)
        proc(pc.diffuseMultiplier, a, 'diffuseMultiplier', df)
        a.separateSpecular = 'specularColor' in pc
        if ('specularColor' in pc) {
          proc(pc.specularColor, a, 'specularColor', df)
          proc(pc.specularMultiplier, a, 'specularMultiplier', df)
        }
      } else if (
        a instanceof GPUStandardParticle ||
        a instanceof GPUStandardCorrectParticle ||
        a instanceof GPUSparkParticle ||
        a instanceof GPUSparkCorrectParticle
      ) {
        const pc = randomItem(palette.gpuParticle)
        proc(pc.color, a, 'color', durationFallback(this.nodeAttributes))
        proc(pc.rgbMultiplier, a, 'rgbMultiplier')
        proc(pc.colorMin, a, 'colorMin')
        proc(pc.colorMax, a, 'colorMax')
        a.bloom = 'bloomColor' in pc
        if ('bloomColor' in pc) {
          proc(pc.bloomColor, a, 'bloomColor')
        }
      } else if ('lensFlare' in palette && a instanceof LensFlare) {
        const pc = randomItem(palette.lensFlare)
        const df = durationFallback(this.nodeAttributes)
        proc(pc.color, a, 'layer1Color', df)
        proc(pc.colorMultiplier, a, 'layer1ColorMultiplier', df)
        proc(pc.bloomColor, a, 'layer1BloomColor', df)
        proc(pc.color, a, 'layer2Color', df)
        proc(pc.colorMultiplier, a, 'layer2ColorMultiplier', df)
        proc(pc.bloomColor, a, 'layer2BloomColor', df)
        proc(pc.color, a, 'layer3Color', df)
        proc(pc.colorMultiplier, a, 'layer3ColorMultiplier', df)
        proc(pc.bloomColor, a, 'layer3BloomColor', df)
        proc(pc.color, a, 'layer4Color', df)
        proc(pc.colorMultiplier, a, 'layer4ColorMultiplier', df)
        proc(pc.bloomColor, a, 'layer4BloomColor', df)
      }
    }
    return this
  }

}

/**
 * Config used in {@link NodeType.NodeEmitter node emitter nodes} to control
 * the emission of child nodes.
 * 
 * Default actions:
 * Index | Slot | Action
 * :-----|:-----|:------
 * 0     | {@link ActionSlots.NodeAttributesAction NodeAttributes} | {@link ActionType.NodeAttributes NodeAttributes}
 * 1     | {@link ActionSlots.NodeTransformAction NodeTransform} | {@link ActionType.None None}
 * 2     | {@link ActionSlots.NodeMovementAction NodeMovement} | {@link ActionType.None None}
 * 3     | {@link ActionSlots.NodeAudioAction NodeAudio} | {@link ActionType.None None}
 * 4     | {@link ActionSlots.EmitterAction Emitter} | {@link ActionType.OneTimeEmitter OneTimeEmitter}
 * 5     | {@link ActionSlots.EmitterShapeAction EmitterShape} | {@link ActionType.PointEmitterShape PointEmitterShape}
 * 6     | {@link ActionSlots.DirectionSpreadAction DirectionSpread} | {@link ActionType.NoSpread NoSpread}
 * 7     | {@link ActionSlots.NodeSelectorAction NodeSelector} | {@link ActionType.SelectAllNodes SelectAllNodes}
 * 8     | {@link ActionSlots.EmissionAudioAction EmissionAudio} | {@link ActionType.None None}
 * 9     | {@link ActionSlots.NodeForceMovementAction NodeForceMovement} | {@link ActionType.None None}
 */
class NodeEmitterConfig implements IConfig {
  readonly type = ConfigType.NodeEmitter

  nodeAttributes: ActionSlots.NodeAttributesAction = new NodeAttributes
  nodeTransform: ActionSlots.NodeTransformAction = new Action
  nodeMovement: ActionSlots.NodeMovementAction = new Action
  nodeAudio: ActionSlots.NodeAudioAction = new Action
  emitter: ActionSlots.EmitterAction = new OneTimeEmitter
  emitterShape: ActionSlots.EmitterShapeAction = new PointEmitterShape
  directionSpread: ActionSlots.DirectionSpreadAction = new NoSpread
  nodeSelector: ActionSlots.NodeSelectorAction = new SelectAllNodes
  emissionAudio: ActionSlots.EmissionAudioAction = new Action
  nodeForceMovement: ActionSlots.NodeForceMovementAction = new Action

  constructor(params: Partial<Props<NodeEmitterConfig>> | AnyAction[] = []) {
    if (Array.isArray(params)) {
      for (const action of params) {
        const index = ConfigActionSlots[ConfigType.NodeEmitter].findIndex(a => a.includes(action.type))
        switch (index) {
          case 0: this.nodeAttributes    = action as Action; break;
          case 1: this.nodeTransform     = action as Action; break;
          case 2: this.nodeMovement      = action as Action; break;
          case 3: this.nodeAudio         = action as Action; break;
          case 4: this.emitter           = action as Action; break;
          case 5: this.emitterShape      = action as Action; break;
          case 6: this.directionSpread   = action as Action; break;
          case 7: this.nodeSelector      = action as Action; break;
          case 8: this.emissionAudio     = action as Action; break;
          case 9: this.nodeForceMovement = action as Action; break;
        }
      }
    } else {
      if ('nodeAttributes' in params) this.nodeAttributes = params.nodeAttributes
      if ('nodeTransform' in params) this.nodeTransform = params.nodeTransform
      if ('nodeMovement' in params) this.nodeMovement = params.nodeMovement
      if ('nodeAudio' in params) this.nodeAudio = params.nodeAudio
      if ('emitter' in params) this.emitter = params.emitter
      if ('emitterShape' in params) this.emitterShape = params.emitterShape
      if ('directionSpread' in params) this.directionSpread = params.directionSpread
      if ('nodeSelector' in params) this.nodeSelector = params.nodeSelector
      if ('emissionAudio' in params) this.emissionAudio = params.emissionAudio
      if ('nodeForceMovement' in params) this.nodeForceMovement = params.nodeForceMovement
    }
  }

  getActionCount(game: Game): number {
    return game === Game.DarkSouls3 ? 9 : 10
  }

  getActions(game: Game): AnyAction[] {
    return [
      this.nodeAttributes,
      this.nodeTransform,
      this.nodeMovement,
      this.nodeAudio,
      this.emitter,
      this.emitterShape,
      this.directionSpread,
      this.nodeSelector,
      this.emissionAudio,
      game === Game.DarkSouls3 ? [] : [
        this.nodeForceMovement,
      ]
    ].flat()
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions): any {
    const obj = {
      type: this.type,
      nodeAttributes: this.nodeAttributes.serialize(options),
      nodeTransform: this.nodeTransform.serialize(options),
      nodeMovement: this.nodeMovement.serialize(options),
      nodeAudio: this.nodeAudio.serialize(options),
      emitter: this.emitter.serialize(options),
      emitterShape: this.emitterShape.serialize(options),
      directionSpread: this.directionSpread.serialize(options),
      nodeSelector: this.nodeSelector.serialize(options),
      emissionAudio: this.emissionAudio.serialize(options),
      nodeForceMovement: this.nodeForceMovement.serialize(options),
    }
    if (serializeFilter('action', options?.filter)) {
      return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v !== undefined))
    }
    return obj
  }

  minify() {
    this.nodeAttributes = this.nodeAttributes.minify()
    this.nodeTransform = this.nodeTransform.minify()
    this.nodeMovement = this.nodeMovement.minify()
    this.nodeAudio = this.nodeAudio.minify()
    this.emitter = this.emitter.minify()
    this.emitterShape = this.emitterShape.minify()
    this.directionSpread = this.directionSpread.minify()
    this.nodeSelector = this.nodeSelector.minify()
    this.emissionAudio = this.emissionAudio.minify()
    this.nodeForceMovement = this.nodeForceMovement.minify()
    return this
  }

  *walkActions() {
    yield this.nodeAttributes
    yield this.nodeTransform
    yield this.nodeMovement
    yield this.nodeAudio
    yield this.emitter
    yield this.emitterShape
    yield this.directionSpread
    yield this.nodeSelector
    yield this.emissionAudio
    yield this.nodeForceMovement
  }

  clone(): NodeEmitterConfig {
    return new NodeEmitterConfig({
      nodeAttributes: this.nodeAttributes.clone() as ActionSlots.NodeAttributesAction,
      nodeTransform: this.nodeTransform.clone() as ActionSlots.NodeTransformAction,
      nodeMovement: this.nodeMovement.clone() as ActionSlots.NodeMovementAction,
      nodeAudio: this.nodeAudio.clone() as ActionSlots.NodeAudioAction,
      emitter: this.emitter.clone() as ActionSlots.EmitterAction,
      emitterShape: this.emitterShape.clone() as ActionSlots.EmitterShapeAction,
      directionSpread: this.directionSpread.clone() as ActionSlots.DirectionSpreadAction,
      nodeSelector: this.nodeSelector.clone() as ActionSlots.NodeSelectorAction,
      emissionAudio: this.emissionAudio.clone() as ActionSlots.EmissionAudioAction,
      nodeForceMovement: this.nodeForceMovement.clone() as ActionSlots.NodeForceMovementAction,
    })
  }

  scale(factor: number, options: ScaleOptions = defaultScaleOptions) {
    for (const action of this.walkActions()) if (action instanceof DataAction) {
      action.scale(factor, options)
    }
    return this
  }

}

//#region Action
class Action implements IAction {

  readonly $data = { isAppearance: false, isParticle: false, slotDefault: false }

  constructor(
    public type: ActionType = ActionType.None,
    public fields1: Field<FieldType>[] = [],
    public fields2: Field<FieldType>[] = [],
    public properties1: AnyProperty[] = [],
    public properties2: AnyProperty[] = [],
    public section10s: number[][] = [],
  ) {}

  withFields1(...fields: { index: number, field: Field<FieldType> | PropertyValue | boolean }[]) {
    for (const { index, field } of fields) {
      if (field instanceof Field) {
        this.fields1[index] = field
      } else {
        this.fields1[index].value = field
      }
    }
    return this
  }

  withFields2(...fields: { index: number, field: Field<FieldType> | PropertyValue | boolean }[]) {
    for (const { index, field } of fields) {
      if (field instanceof Field) {
        this.fields2[index] = field
      } else {
        this.fields2[index].value = field
      }
    }
    return this
  }

  withProperties1(...props: { index: number, property: PropertyValue | AnyProperty }[]) {
    for (const { index, property } of props) {
      if (property instanceof Property) {
        this.properties1[index] = property
      } else {
        this.properties1[index] = new ConstantProperty(property)
      }
    }
    return this
  }

  withProperties2(...props: { index: number, property: PropertyValue | AnyProperty }[]) {
    for (const { index, property } of props) {
      if (property instanceof Property) {
        this.properties2[index] = property
      } else {
        this.properties2[index] = new ConstantProperty(property)
      }
    }
    return this
  }

  static fromJSON(obj: any) {
    if (obj === null) {
      return new Action
    }
    if (obj instanceof Action || obj instanceof DataAction) {
      return obj
    }
    if (obj.$generic === true) {
      return new Action(
        obj.type,
        (obj.fields1 ?? []).map((e: any) => Field.fromJSON(e)),
        (obj.fields2 ?? []).map((e: any) => Field.fromJSON(e)),
        (obj.properties1 ?? []).map((e: any) => Property.fromJSON(e)),
        (obj.properties2 ?? []).map((e: any) => Property.fromJSON(e)),
        obj.section10s
      )
    } else {
      if ('props' in ActionData[obj.type]) {
        const propKeys = Object.keys(ActionData[obj.type].props)
        if (propKeys.length === 1) {
          return new DataActions[obj.type](obj[propKeys[0]])
        }
        return new DataActions[obj.type](Object.fromEntries(Object.entries(obj).map(([k, v]) => {
          return [k, typeof v === 'object' && !Array.isArray(v) ? Property.fromJSON(v) : v]
        }).filter(e => e[0] !== 'type')))
      } else {
        return new DataActions[obj.type]
      }
    }
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions) {
    if (this.type === 0) {
      return serializeFilter('action', options?.filter) && !options?.requireActionDefinition ? undefined : null
    }
    const o: {
      type: ActionType
      $generic: true
      fields1?: any[]
      fields2?: any[]
      properties1?: any[]
      properties2?: any[]
      section10s?: any[]
    } = { type: this.type, $generic: true }
    if (this.fields1.length > 0) o.fields1 = this.fields1.map(field => field.serialize(options))
    if (this.fields2.length > 0) o.fields2 = this.fields2.map(field => field.serialize(options))
    if (this.properties1.length > 0) o.properties1 = this.properties1.map(prop => prop.serialize(options))
    if (this.properties2.length > 0) o.properties2 = this.properties2.map(prop => prop.serialize(options))
    if (this.section10s.length > 0) o.section10s = this.section10s
    return o
  }

  minify(): Action {
    return new Action(
      this.type,
      this.fields1,
      this.fields2,
      this.properties1.map(e => e.minify()),
      this.properties2.map(e => e.minify()),
      this.section10s,
    )
  }

  clone(): Action {
    return new Action(
      this.type,
      this.fields1.map(e => e.clone()),
      this.fields2.map(e => e.clone()),
      this.properties1.map(e => e.clone()),
      this.properties2.map(e => e.clone()),
      this.section10s.map(e => e.slice()),
    )
  }

}

/**
 * Base class for all actions that are defined in {@link ActionData}. These
 * actions have a very different structure compared to regular {@link Action}s
 * that you see in FXR files. They only have named properties. There is very
 * little difference between a property and a field, and they can often be
 * represented as single numbers both of them.
 * 
 * This different structure is used to allow a single DataAction to represent
 * an action from any of the supported games at the same time, and also makes
 * it possible to perform certain actions that are difficult to do with regular
 * actions, like recoloring or resizing.
 * 
 * This class is not meant to be used directly. Instead, use the classes that
 * extend it. There is one for every known action in all of the supported
 * games, and also most of the unknown actions.
 */
class DataAction implements IAction {

  /**
   * @param type The {@link ActionType numeric ID for the type of action} this represents.
   */
  constructor(public readonly type: ActionType) {}

  /**
   * An object containing most of the information that is stored in the library
   * about the action type.
   */
  get $data() { return ActionData[this.type] }

  /**
   * An object containing various functions related to conversion between games
   * and different formats, or undefined if the action does not have any of
   * these functions.
   */
  get $convert(): ActionDataConversionEntry<this> { return ActionDataConversion[this.type] }

  assign(props: any = {}) {
    for (const [k, v] of Object.entries(this.$data.props)) {
      if ('omit' in v) {
        continue
      }
      this[k] = props[k] ?? v.default
    }
    return this
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions): any {
    const obj: any = {
      type: this.type,
      ...Object.fromEntries(
        Object.entries(this.$data.props ?? {})
          .filter(([propName, prop]) => {
            return !('omit' in prop) && !(
              serializeFilter('property', options?.filter) && JSON.stringify(prop.default) === JSON.stringify(this[propName]) ||
              serializeFilter('unknownProperty', options?.filter) && propName.startsWith('unk_')
                && JSON.stringify(prop.default) === JSON.stringify(this[propName])
            )
          })
          .map(([propName]) => {
            const v = this[propName]
            if (v instanceof Property) {
              return [propName, v.serialize(options)]
            }
            return [propName, v]
          })
      )
    }
    if (
      serializeFilter('action', options?.filter) &&
      !options.requireActionDefinition &&
      ActionData[this.type].slotDefault && Object.keys(obj).length === 1
    ) {
      return undefined
    }
    return obj
  }

  minify() {
    let minified: DataAction = this
    if (this.type in ActionDataConversion && 'minify' in this.$convert) {
      minified = this.$convert.minify.call(this)
    }
    if (minified instanceof DataAction && 'props' in minified.$data) {
      const propNames = Object.keys(minified.$data.props)
      if (propNames.length === 1) {
        return new (minified.constructor as any)(
          minified[propNames[0]] instanceof Property ? minified[propNames[0]].minify() : minified[propNames[0]]
        )
      }
      return new (minified.constructor as any)(Object.fromEntries(
        propNames.map(prop => [
          prop,
          minified[prop] instanceof Property ? minified[prop].minify() : minified[prop]
        ])
      ))
    }
    return minified
  }

  getFields(game: Game, list: 'fields1' | 'fields2', props: Props<this> = this): Field<FieldType>[] {
    const data = getActionGameData(this.type, game)
    const ade = this.$data
    return data[list].map((name: string) => {
      const prop = ade.props[name]
      validateDataActionProp(props, name, prop)
      return Field.from(
        typeof prop.field === 'number' ? prop.field : prop.field[game],
        props[name] instanceof Property ? props[name].valueAt(0) : props[name]
      )
    })
  }

  getProperties(game: Game, list: 'properties1' | 'properties2', props: Props<this> = this): AnyProperty[] {
    const data = getActionGameData(this.type, game)
    const ade = this.$data
    return (data[list] ?? []).map((name: string) => {
      const prop = ade.props[name]
      validateDataActionProp(props, name, prop)
      return props[name] instanceof Property ? props[name].for(game) : new ConstantProperty(props[name]).for(game)
    })
  }

  getSection10s(game: Game, props: Props<this> = this): number[][] {
    const data = getActionGameData(this.type, game)
    return (data.section10s ?? []).map((name: string) => props[name])
  }

  toAction(game: Game) {
    const convertedProps = this.type in ActionDataConversion && 'write' in this.$convert ?
      this.$convert.write(Object.assign(Object.create(null), this), game) :
      this
    return new Action(
      this.type,
      this.getFields(game, 'fields1', convertedProps),
      this.getFields(game, 'fields2', convertedProps),
      this.getProperties(game, 'properties1', convertedProps),
      this.getProperties(game, 'properties2', convertedProps),
      this.getSection10s(game, convertedProps)
    )
  }

  getResourceProperties(): {
    property: string
    type: ResourceType
    textureType?: string
  }[] {
    if (!('props' in this.$data)) {
      return []
    }

    const resourceProps = []
    for (const [k, v] of Object.entries(this.$data.props)) {
      if ('resource' in v) {
        if (v.resource === ResourceType.Texture) {
          resourceProps.push({
            property: k,
            type: v.resource,
            textureType: v.textureType
          })
        } else {
          resourceProps.push({
            property: k,
            type: v.resource
          })
        }
      }
    }
    return resourceProps
  }

  /**
   * Scale the size of the action by a factor. This only does something when
   * used with actions that have scaling properties.
   * @param factor The factor to scale by.
   */
  scale(factor: number, options: ScaleOptions = defaultScaleOptions) {
    if ('props' in this.$data) {
      for (const [k, v] of Object.entries(this.$data.props)) {
        if ('scale' in v) {
          switch (true) {
            case v.scale === ScaleCondition.RawInstanceSize:

            case v.scale === ScaleCondition.True
              && options.scaleStructural:

            case v.scale === ScaleCondition.InstanceSize
              && !options.scaleParticleModifier:

            case v.scale === ScaleCondition.Distance
              && options.scaleStructural
              && options.scaleViewDistance:

            case v.scale === ScaleCondition.ParticleModifier
              && options.scaleParticleModifier:

              {
                this[k] = anyValueMult(factor, this[k])
                break
              }


            case v.scale === ScaleCondition.DistanceIfNotMinusOne
              && options.scaleStructural
              && options.scaleViewDistance
              && this[k] !== -1:

              {
                this[k] *= factor
                break
              }
          }
        }
      }
    }
    return this
  }

  /**
   * Modifies a single color property of the action using a recolor function.
   * For some easy pre-made recolor functions, see the {@link Recolor}
   * namespace.
   * @param key The name of the property.
   * @param func The function used to recolor the property.
   */
  recolorProperty(key: string, func: Recolor.RecolorFunction, context?: BasicConfig) {
    let prop: Vector4Value = this[key]
    if (
      prop instanceof Property && prop.valueType !== ValueType.Vector4 ||
      Array.isArray(prop) && prop.length !== 4
    ) {
      throw new Error('Cannot recolor non-color property: ' + key)
    }
    if (Array.isArray(prop)) {
      this[key] = func(prop, context, this, key as any)
      return this
    }
    if (prop instanceof ComponentSequenceProperty) {
      prop = this[key] = prop.combineComponents()
    }
    if (prop instanceof ValueProperty) {
      prop.value = func(prop.value, context, this, key as any)
    } else if (prop instanceof SequenceProperty) {
      for (const keyframe of prop.keyframes) {
        keyframe.value = func(keyframe.value as Vector4, context, this, key as any)
      }
    }
    prop.modifiers = prop.modifiers.filter(mod => !(
      mod instanceof RandomDeltaModifier ||
      mod instanceof RandomRangeModifier ||
      mod instanceof RandomFractionModifier
    ))
    for (const mod of prop.modifiers) {
      if (mod instanceof ExternalValue1Modifier || mod instanceof ExternalValue2Modifier) {
        if (mod.factor instanceof ComponentSequenceProperty) {
          mod.factor = mod.factor.combineComponents()
        }
        if (mod.factor instanceof ValueProperty) {
          mod.factor.value = func(mod.factor.value, context, this, key as any)
        } else if (mod.factor instanceof SequenceProperty) {
          for (const keyframe of mod.factor.keyframes) {
            keyframe.value = func(keyframe.value as Vector4, context, this, key as any)
          }
        } else {
          mod.factor = func(mod.factor, context, this, key as any)
        }
      }
    }
    return this
  }

  /**
   * Modifies all color properties using a recolor function. For some easy
   * pre-made recolor functions, see the {@link Recolor} namespace.
   * @param func A function used to remap color values.
   */
  recolor(func: Recolor.RecolorFunction, context?: BasicConfig) {
    if ('props' in this.$data) {
      for (const [k, v] of Object.entries(this.$data.props)) {
        if ('color' in v) {
          this.recolorProperty(k, func, context)
        }
      }
    }
    return this
  }

  *#colors(): Generator<Vector4> {
    if ('props' in this.$data) {
      for (const [k, v] of Object.entries(this.$data.props)) {
        if ('color' in v) {
          let prop: Vector4Value = this[k]
          if (Array.isArray(prop)) {
            yield prop
            continue
          }
          if (prop instanceof ComponentSequenceProperty) {
            prop = prop.combineComponents()
          }
          if (prop instanceof ValueProperty) {
            yield prop.value
          } else if (prop instanceof SequenceProperty) {
            for (const keyframe of prop.keyframes) {
              yield keyframe.value
            }
          }
          for (const mod of prop.modifiers) {
            if (mod instanceof RandomDeltaModifier || mod instanceof RandomFractionModifier) {
              yield mod.max
            } else if (mod instanceof RandomRangeModifier) {
              yield mod.min
              yield mod.max
            } else if (mod instanceof ExternalValue1Modifier || mod instanceof ExternalValue2Modifier) {
              let factor = mod.factor
              if (factor instanceof ComponentSequenceProperty) {
                factor.combineComponents()
              }
              if (factor instanceof ValueProperty) {
                yield factor.value
              } else if (factor instanceof SequenceProperty) {
                for (const keyframe of factor.keyframes) {
                  yield keyframe.value
                }
              } else {
                yield factor
              }
            }
          }
        }
      }
    }
  }

  /**
   * Yields all unique color values in the action.
   */
  *colors() {
    const colors = new Set<string>()
    for (const color of this.#colors()) {
      const cs = color.join(',')
      if (!colors.has(cs)) {
        colors.add(cs)
        yield color
      }
    }
  }

  /**
   * Scale the rate of time for the action.
   * 
   * This method's main purpose is to serve as a fallback for changing the rate
   * of time for Dark Souls 3 effects, which doesn't support the rateOfTime
   * property. The rate of time is automatically scaled when writing effects
   * for DS3, you do not need to do this yourself. As such, this method is only
   * useful if you want to scale the rate of time for individual parts of an
   * effect, or if you need the extra options available for this method.
   * @param factor The factor to scale the rate of time by. Setting this to 2
   * will make the action play twice as fast. Setting it to 0.5 will make it
   * play half as fast.
   * @param [options={}] Extra options for changing how the scaling is applied
   * to different properties.
   */
  scaleRateOfTime(factor: number, options: { scaleTracerDuration?: boolean } = {}) {
    const inv = 1 / factor
    const sq = factor * factor
    if ('props' in this.$data) {
      for (const [name, prop] of Object.entries(this.$data.props)) {
        if (
          this[name] instanceof SequenceProperty ||
          this[name] instanceof ComponentSequenceProperty
        ) {
          this[name].duration = this[name].duration * inv
        }
        switch (prop.time) {
          case TimeOperation.Multiply:
            this[name] = anyValueMult(factor, this[name])
            break
          case TimeOperation.TracerDuration:
            if (options.scaleTracerDuration !== true) {
              break
            }
          case TimeOperation.Divide:
            this[name] = anyValueMult(inv, this[name])
            break
          case TimeOperation.DivideIfPositive:
            if (this[name] instanceof Property) {
              if (this[name].valueAt(0) > 0) {
                this[name] = anyValueMult(inv, this[name])
              }
            } else {
              if (this[name] > 0) {
                this[name] *= inv
              }
            }
            break
          case TimeOperation.Square:
            this[name] = anyValueMult(sq, this[name])
            break
        }
      }
    }
    return this
  }

  clone(): DataAction {
    if ('props' in this.$data) {
      const props = Object.keys(this.$data.props).map(k => [
        k,
        this[k] instanceof Property ? this[k].clone() :
          Array.isArray(this[k]) ? this[k].slice() : this[k]
      ])
      return new (this.constructor as any)(props.length === 1 ? props[0][1] : Object.fromEntries(props))
    } else {
      return new (this.constructor as any)()
    }
  }

}

/**
 * Constructs one of the following {@link ActionSlots.NodeMovementAction Node Movement} classes:
 * - {@link ActionType.NodeSpin NodeSpin}
 * - {@link ActionType.NodeAcceleration NodeAcceleration}
 * - {@link ActionType.NodeAccelerationRandomTurns NodeAccelerationRandomTurns}
 * - {@link ActionType.NodeAccelerationPartialFollow NodeAccelerationPartialFollow}
 * - {@link ActionType.NodeAccelerationSpin NodeAccelerationSpin}
 * - {@link ActionType.NodeSpeed NodeSpeed}
 * - {@link ActionType.NodeSpeedRandomTurns NodeSpeedRandomTurns}
 * - {@link ActionType.NodeSpeedPartialFollow NodeSpeedPartialFollow}
 * - {@link ActionType.NodeSpeedSpin NodeSpeedSpin}
 * 
 * Which one is produced depends on what arguments are set.
 * 
 * If you are trying to figure out what some of the unknown fields in these
 * actions do, use the actual classes themselves instead of relying on this
 * shortcut. It only exists to make things easier, not to control exactly what
 * happens.
 */
function NodeMovement(params: NodeMovementProps = {}) {
  const acceleration = 'accelerationZ' in params || 'accelerationMultiplierZ' in params,
        speed = 'speedMultiplierZ' in params,
        randomTurns = 'maxTurnAngle' in params || 'turnInterval' in params,
        partialFollow = 'followFactor' in params || 'followRotation' in params,
        spin = (
          'angularSpeedX' in params ||
          'angularSpeedMultiplierX' in params ||
          'angularSpeedY' in params ||
          'angularSpeedMultiplierY' in params ||
          'angularSpeedZ' in params ||
          'angularSpeedMultiplierZ' in params
        ),
        speedOrAccel = (
          'accelerationZ' in params ||
          'accelerationMultiplierZ' in params ||
          'speedZ' in params ||
          'speedMultiplierZ' in params ||
          'accelerationY' in params ||
          'alignWithMotion' in params
        )
  if ((randomTurns || partialFollow) && spin) {
    throw new Error('Angular speed is not compatible with random turns properties or partial follow properties in Node Movement actions.')
  }
  if (acceleration && speed) {
    throw new Error('Speed and acceleration properties are not compatible in Node Movement actions.')
  }
  if (spin && !speedOrAccel) {
    return new NodeSpin(params)
  }
  if (speed) {
    if (spin) {
      return new NodeSpeedSpin(params)
    }
    if (partialFollow) {
      return new NodeSpeedPartialFollow(params)
    }
    if (randomTurns) {
      return new NodeSpeedRandomTurns(params)
    }
    return new NodeSpeed(params)
  }
  if (spin) {
    return new NodeAccelerationSpin(params)
  }
  if (partialFollow) {
    return new NodeAccelerationPartialFollow(params)
  }
  if (randomTurns) {
    return new NodeAccelerationRandomTurns(params)
  }
  if (speedOrAccel) {
    return new NodeAcceleration(params)
  }
  return new Action
}

/**
 * Constructs one of the
 * {@link ActionSlots.NodeTransformAction Node Transform} classes. Which one
 * depends on the arguments given, which means that if any of the randomization
 * arguments are used, it will produce a {@link RandomNodeTransform}.
 */
function NodeTransform(params: NodeTransformProps = {}) {
  if (
    'offsetVariance' in params ||
    'rotationVariance' in params
  ) {
    return new RandomNodeTransform(params)
  } else if (
    'offset' in params ||
    'rotation' in params
  ) {
    return new StaticNodeTransform(params)
  }
  return new Action
}

/**
 * Constructs one of the following {@link ActionSlots.ParticleMovementAction Particle Movement} classes:
 * - {@link ActionType.ParticleAcceleration ParticleAcceleration}
 * - {@link ActionType.ParticleAccelerationRandomTurns ParticleAccelerationRandomTurns}
 * - {@link ActionType.ParticleAccelerationPartialFollow ParticleAccelerationPartialFollow}
 * - {@link ActionType.ParticleSpeed ParticleSpeed}
 * - {@link ActionType.ParticleSpeedRandomTurns ParticleSpeedRandomTurns}
 * - {@link ActionType.ParticleSpeedPartialFollow ParticleSpeedPartialFollow}
 * 
 * Which one is produced depends on what arguments are set.
 * 
 * If you are trying to figure out what some of the unknown fields in these
 * actions do, use the actual classes themselves instead of relying on this
 * shortcut. It only exists to make things easier, not to control exactly what
 * happens.
 */
function ParticleMovement(params: ParticleMovementProps = {}) {
  if (
    'speed' in params ||
    'speedMultiplier' in params
  ) {
    if (
      'acceleration' in params ||
      'accelerationMultiplier' in params
    ) {
      throw new Error('The speed properties are not compatible with the acceleration properties in Particle Movement actions.')
    }
    if (
      'followFactor' in params ||
      'followRotation' in params
    ) {
      return new ParticleSpeedPartialFollow(params)
    }
    if (
      'maxTurnAngle' in params ||
      'turnInterval' in params
    ) {
      return new ParticleSpeedRandomTurns(params)
    }
    return new ParticleSpeed(params)
  }
  if (
    'followFactor' in params ||
    'followRotation' in params
  ) {
    return new ParticleAccelerationPartialFollow(params)
  }
  if (
    'maxTurnAngle' in params ||
    'turnInterval' in params
  ) {
    return new ParticleAccelerationRandomTurns(params)
  }
  return new ParticleAcceleration(params)
}

/*#ActionClasses start*/
/**
 * ### {@link ActionType.NodeAcceleration Action 1 - NodeAcceleration}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Controls the movement of the node. This is the most basic action for controlling the acceleration of nodes.
 */
class NodeAcceleration extends DataAction {
  declare readonly type: ActionType.NodeAcceleration
  /**
   * Controls the speed of the node along its Z-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  speedZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Z-axis. This value cannot be negative.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationZ: ScalarValue
  /**
   * Multiplier for {@link accelerationZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationMultiplierZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Y-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationY: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * When set to 1, this makes the node align with the direction it's moving. Setting it to higher values seems to do the same as setting it to 0, which means it's probably not a boolean, but what those values do exactly is unknown.
   * 
   * **Default**: `0`
   */
  alignWithMotion: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_2: number
  constructor(props: Partial<Props<NodeAcceleration>> = {}) {
    super(ActionType.NodeAcceleration)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeTranslation Action 15 - NodeTranslation}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Translates the node using a property, meaning it can be animated. This can be useful if you need the node to follow a specific path.
 */
class NodeTranslation extends DataAction {
  declare readonly type: ActionType.NodeTranslation
  /**
   * An offset for the position of the node.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  translation: Vector3Value
  /**
   * When set to 1, this makes the node align with the direction it's moving. There are cases of this being set to 2 in vanilla, and it seems to behave similarly to when it is set to 0, so this is not a boolean. The actual differences between 0 and 2 are unknown.
   * 
   * **Default**: `0`
   */
  alignWithMotion: number
  constructor(props: Partial<Props<NodeTranslation>> = {}) {
    super(ActionType.NodeTranslation)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeSpin Action 34 - NodeSpin}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Controls the angular speed of the node.
 */
class NodeSpin extends DataAction {
  declare readonly type: ActionType.NodeSpin
  /**
   * The node's angular speed around its local X-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angularSpeedMultiplierX}
   */
  angularSpeedX: ScalarValue
  /**
   * Multiplier for {@link angularSpeedX}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  angularSpeedMultiplierX: ScalarValue
  /**
   * The node's angular speed around its local Y-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angularSpeedMultiplierY}
   */
  angularSpeedY: ScalarValue
  /**
   * Multiplier for {@link angularSpeedY}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  angularSpeedMultiplierY: ScalarValue
  /**
   * The node's angular speed around its local Z-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angularSpeedMultiplierZ}
   */
  angularSpeedZ: ScalarValue
  /**
   * Multiplier for {@link angularSpeedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  angularSpeedMultiplierZ: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  constructor(props: Partial<Props<NodeSpin>> = {}) {
    super(ActionType.NodeSpin)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.StaticNodeTransform Action 35 - StaticNodeTransform}
 * **Slot**: {@link ActionSlots.NodeTransformAction NodeTransform}
 * 
 * Controls the translation and rotation of a node.
 */
class StaticNodeTransform extends DataAction {
  declare readonly type: ActionType.StaticNodeTransform
  /**
   * Translation of the node.
   * 
   * This translation happens after all {@link rotation rotations}, meaning the rotations will not affect the translation.
   * 
   * **Default**: `[0, 0, 0]`
   */
  offset: Vector3
  /**
   * The rotation of the node.
   * 
   * The order the rotations happen in is Z -> X -> Y, and the translation from {@link offset} happens after all rotations.
   * 
   * **Default**: `[0, 0, 0]`
   */
  rotation: Vector3
  constructor(props: Partial<Props<StaticNodeTransform>> = {}) {
    super(ActionType.StaticNodeTransform)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.RandomNodeTransform Action 36 - RandomNodeTransform}
 * **Slot**: {@link ActionSlots.NodeTransformAction NodeTransform}
 * 
 * Controls the translation and rotation of a node, and can also randomize them.
 */
class RandomNodeTransform extends DataAction {
  declare readonly type: ActionType.RandomNodeTransform
  /**
   * Translation of the node.
   * 
   * This translation happens after all {@link rotation rotations}, meaning the rotations will not affect the translation.
   * 
   * **Default**: `[0, 0, 0]`
   */
  offset: Vector3
  /**
   * The rotation of the node.
   * 
   * The order the rotations happen in is Z -> X -> Y, and the translation from {@link offset} happens after all rotations.
   * 
   * **Default**: `[0, 0, 0]`
   */
  rotation: Vector3
  /**
   * The maximum random change in translation of the node. A random value between the {@link offset base value} minus this and the base value plus this will be the final offset used.
   * 
   * **Default**: `[0, 0, 0]`
   */
  offsetVariance: Vector3
  /**
   * The maximum random change in rotation of the node. A random value between the {@link rotation base value} minus this and the base value plus this will be the final rotation used.
   * 
   * **Default**: `[0, 0, 0]`
   */
  rotationVariance: Vector3
  constructor(props: Partial<Props<RandomNodeTransform>> = {}) {
    super(ActionType.RandomNodeTransform)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeAttachToCamera Action 46 - NodeAttachToCamera}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Attaches the node to the camera.
 */
class NodeAttachToCamera extends DataAction {
  declare readonly type: ActionType.NodeAttachToCamera
  /**
   * Disable this to stop the node from following the rotation of the camera.
   * 
   * **Default**: `true`
   */
  followRotation: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_1: number
  constructor(props: Partial<Props<NodeAttachToCamera>> = {}) {
    super(ActionType.NodeAttachToCamera)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleAcceleration Action 55 - ParticleAcceleration}
 * **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
 * 
 * Controls the movement of particles. This is the most basic action for controlling the acceleration of particles.
 */
class ParticleAcceleration extends DataAction {
  declare readonly type: ActionType.ParticleAcceleration
  /**
   * Controls the acceleration of the particle along the global Y-axis. Positive values will make the particles go down, and negative values will go up.
   * 
   * Unless it's left at 0, this changes the current direction of the particles, which can affect various other things, for example the rotation of {@link ActionType.Line Line} and {@link ActionType.QuadLine QuadLine} particles, and the direction of this action's {@link acceleration}. It does not affect the particles' {@link InitialDirection initial direction}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  gravity: ScalarValue
  /**
   * The particles' acceleration in their current direction, which is usually their {@link InitialDirection initial direction}, but can be changed over time by other things, for example this action's {@link gravity}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  acceleration: ScalarValue
  /**
   * Multiplier for {@link acceleration}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  accelerationMultiplier: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_1: number
  constructor(props: Partial<Props<ParticleAcceleration>> = {}) {
    super(ActionType.ParticleAcceleration)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleSpeed Action 60 - ParticleSpeed}
 * **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
 * 
 * Controls the movement of particles. This is the most basic action for controlling the speed of particles.
 */
class ParticleSpeed extends DataAction {
  declare readonly type: ActionType.ParticleSpeed
  /**
   * Controls the acceleration of the particle along the global Y-axis. Positive values will make the particles go down, and negative values will go up.
   * 
   * Unless it's left at 0, this changes the current direction of the particles, which can affect various other things, for example the rotation of {@link ActionType.Line Line} and {@link ActionType.QuadLine QuadLine} particles, and the direction of this action's {@link speed}. It does not affect the particles' {@link InitialDirection initial direction}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  gravity: ScalarValue
  /**
   * The particles' speed in their current direction, which is usually their {@link InitialDirection initial direction}, but can be changed over time by other things, for example this action's {@link gravity}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speed: ScalarValue
  /**
   * Multiplier for {@link speed}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speedMultiplier: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_1: number
  constructor(props: Partial<Props<ParticleSpeed>> = {}) {
    super(ActionType.ParticleSpeed)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleSpeedRandomTurns Action 64 - ParticleSpeedRandomTurns}
 * **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
 * 
 * Controls the movement of particles. This extends {@link ActionType.ParticleSpeed ParticleSpeed} with the ability to make particles make random turns at a fixed interval.
 */
class ParticleSpeedRandomTurns extends DataAction {
  declare readonly type: ActionType.ParticleSpeedRandomTurns
  /**
   * Controls the acceleration of the particle along the global Y-axis. Positive values will make the particles go down, and negative values will go up.
   * 
   * Unless it's left at 0, this changes the current direction of the particles, which can affect various other things, for example the rotation of {@link ActionType.Line Line} and {@link ActionType.QuadLine QuadLine} particles, and the direction of this action's {@link speed}. It does not affect the particles' {@link InitialDirection initial direction}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  gravity: ScalarValue
  /**
   * The particles' speed in their current direction, which is usually their {@link InitialDirection initial direction}, but can be changed over time by other things, for example this action's {@link gravity}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speed: ScalarValue
  /**
   * Multiplier for {@link speed}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speedMultiplier: ScalarValue
  /**
   * The particles will turn a random amount based on this value at intervals defined by {@link turnInterval}.
   * 
   * This turning affects the particles' current direction, which can affect various other things, for example this action's {@link speed}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  maxTurnAngle: ScalarValue
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * The particles will turn a random amount based on {@link maxTurnAngle} at this interval. The units are seconds, but due to how the field that stores this value works, the value will be rounded to the nearest 0.02 seconds.
   * 
   * This turning affects the particles' current direction, which can affect various other things, for example this action's {@link speed}.
   * 
   * **Default**: `0`
   */
  turnInterval: number
  constructor(props: Partial<Props<ParticleSpeedRandomTurns>> = {}) {
    super(ActionType.ParticleSpeedRandomTurns)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleSpeedPartialFollow Action 65 - ParticleSpeedPartialFollow}
 * **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
 * 
 * Controls the movement of particles. This extends {@link ActionType.ParticleSpeedRandomTurns ParticleSpeedRandomTurns} with the ability to make particles partially follow the parent node.
 */
class ParticleSpeedPartialFollow extends DataAction {
  declare readonly type: ActionType.ParticleSpeedPartialFollow
  /**
   * Controls the acceleration of the particle along the global Y-axis. Positive values will make the particles go down, and negative values will go up.
   * 
   * Unless it's left at 0, this changes the current direction of the particles, which can affect various other things, for example the rotation of {@link ActionType.Line Line} and {@link ActionType.QuadLine QuadLine} particles, and the direction of this action's {@link speed}. It does not affect the particles' {@link InitialDirection initial direction}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  gravity: ScalarValue
  /**
   * The particles' speed in their current direction, which is usually their {@link InitialDirection initial direction}, but can be changed over time by other things, for example this action's {@link gravity}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speed: ScalarValue
  /**
   * Multiplier for {@link speed}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speedMultiplier: ScalarValue
  /**
   * The particles will turn a random amount based on this value at intervals defined by {@link turnInterval}.
   * 
   * This turning affects the particles' current direction, which can affect various other things, for example this action's {@link speed}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  maxTurnAngle: ScalarValue
  /**
   * Controls how well the particles should follow the parent node if they are not attached. At 0, the particles will not follow at all. At 1, the particles will follow perfectly, as if attached to the parent node. Negative values will make the particles move in the opposite direction compared to the parent node. Values greater than 1 will make the particles exaggerate the parent node's movement.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link followRotation}
   */
  followFactor: ScalarValue
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * The particles will turn a random amount based on {@link maxTurnAngle} at this interval. The units are seconds, but due to how the field that stores this value works, the value will be rounded to the nearest 0.02 seconds.
   * 
   * This turning affects the particles' current direction, which can affect various other things, for example this action's {@link speed}.
   * 
   * **Default**: `0`
   */
  turnInterval: number
  /**
   * Disabling this will make {@link followFactor} only affect translation and not rotation.
   * 
   * **Default**: `true`
   */
  followRotation: boolean
  constructor(props: Partial<Props<ParticleSpeedPartialFollow>> = {}) {
    super(ActionType.ParticleSpeedPartialFollow)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeSound Action 75 - NodeSound}
 * **Slot**: {@link ActionSlots.NodeAudioAction NodeAudio}
 * 
 * Plays a sound effect when the node activates.
 */
class NodeSound extends DataAction {
  declare readonly type: ActionType.NodeSound
  /**
   * The ID of the sound event to play.
   * 
   * **Default**: `0`
   */
  sound: number
  /**
   * Volume multiplier in Dark Souls 3 and possibly Sekiro, and seemingly does nothing in later games.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_1: number
  /**
   * Controls whether the sound will repeat or not in Dark Souls 3 and possibly Sekiro, and seemingly does nothing in later games.
   * 
   * **Default**: `false`
   */
  unk_ds3_f1_2: boolean
  constructor(props: Partial<Props<NodeSound>> = {}) {
    super(ActionType.NodeSound)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.EmissionSound Action 81 - EmissionSound}
 * **Slot**: {@link ActionSlots.EmissionAudioAction EmissionAudio}
 * 
 * Plays a sound effect every time the node emits particles. It only plays the sound once per emission, not once per particle.
 */
class EmissionSound extends DataAction {
  declare readonly type: ActionType.EmissionSound
  /**
   * The ID of the sound event to play.
   * 
   * **Default**: `0`
   */
  sound: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_1: number
  constructor(props: Partial<Props<EmissionSound>> = {}) {
    super(ActionType.EmissionSound)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeAccelerationRandomTurns Action 83 - NodeAccelerationRandomTurns}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Controls the movement of the node. This extends {@link ActionType.NodeAcceleration NodeAcceleration} with the ability to make the node turn a random amount at a given interval.
 */
class NodeAccelerationRandomTurns extends DataAction {
  declare readonly type: ActionType.NodeAccelerationRandomTurns
  /**
   * Controls the speed of the node along its Z-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  speedZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Z-axis. This value cannot be negative.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationZ: ScalarValue
  /**
   * Multiplier for {@link accelerationZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationMultiplierZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Y-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationY: ScalarValue
  /**
   * The node will turn a random amount based on this value at intervals defined by {@link turnInterval}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  maxTurnAngle: ScalarValue
  /**
   * When set to 1, this makes the node align with the direction it's moving. Setting it to higher values seems to do the same as setting it to 0, which means it's probably not a boolean, but what those values do exactly is unknown.
   * 
   * **Default**: `0`
   */
  alignWithMotion: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_1: number
  /**
   * The node will turn a random amount based on {@link maxTurnAngle} at this interval. The units are seconds, but due to how the field that stores this value works, the value will be rounded to the nearest 0.02 seconds.
   * 
   * **Default**: `0`
   */
  turnInterval: number
  constructor(props: Partial<Props<NodeAccelerationRandomTurns>> = {}) {
    super(ActionType.NodeAccelerationRandomTurns)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleAccelerationRandomTurns Action 84 - ParticleAccelerationRandomTurns}
 * **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
 * 
 * Controls the movement of particles. This extends {@link ActionType.ParticleAcceleration ParticleAcceleration} with the ability to make particles make random turns at a fixed interval.
 */
class ParticleAccelerationRandomTurns extends DataAction {
  declare readonly type: ActionType.ParticleAccelerationRandomTurns
  /**
   * Controls the acceleration of the particle along the global Y-axis. Positive values will make the particles go down, and negative values will go up.
   * 
   * Unless it's left at 0, this changes the current direction of the particles, which can affect various other things, for example the rotation of {@link ActionType.Line Line} and {@link ActionType.QuadLine QuadLine} particles, and the direction of this action's {@link acceleration}. It does not affect the particles' {@link InitialDirection initial direction}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  gravity: ScalarValue
  /**
   * The particles' acceleration in their current direction, which is usually their {@link InitialDirection initial direction}, but can be changed over time by other things, for example this action's {@link gravity}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  acceleration: ScalarValue
  /**
   * Multiplier for {@link acceleration}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  accelerationMultiplier: ScalarValue
  /**
   * The particles will turn a random amount based on this value at intervals defined by {@link turnInterval}.
   * 
   * This turning affects the particles' current direction, which can affect various other things, for example this action's {@link acceleration}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  maxTurnAngle: ScalarValue
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * The particles will turn a random amount based on {@link maxTurnAngle} at this interval. The units are seconds, but due to how the field that stores this value works, the value will be rounded to the nearest 0.02 seconds.
   * 
   * This turning affects the particles' current direction, which can affect various other things, for example this action's {@link acceleration}.
   * 
   * **Default**: `0`
   */
  turnInterval: number
  constructor(props: Partial<Props<ParticleAccelerationRandomTurns>> = {}) {
    super(ActionType.ParticleAccelerationRandomTurns)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleAccelerationPartialFollow Action 105 - ParticleAccelerationPartialFollow}
 * **Slot**: {@link ActionSlots.ParticleMovementAction ParticleMovement}
 * 
 * Controls the movement of particles. This extends {@link ActionType.ParticleAccelerationRandomTurns ParticleAccelerationRandomTurns} with the ability to make particles partially follow the parent node.
 */
class ParticleAccelerationPartialFollow extends DataAction {
  declare readonly type: ActionType.ParticleAccelerationPartialFollow
  /**
   * Controls the acceleration of the particle along the global Y-axis. Positive values will make the particles go down, and negative values will go up.
   * 
   * Unless it's left at 0, this changes the current direction of the particles, which can affect various other things, for example the rotation of {@link ActionType.Line Line} and {@link ActionType.QuadLine QuadLine} particles, and the direction of this action's {@link acceleration}. It does not affect the particles' {@link InitialDirection initial direction}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  gravity: ScalarValue
  /**
   * The particles' acceleration in their current direction, which is usually their {@link InitialDirection initial direction}, but can be changed over time by other things, for example this action's {@link gravity}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  acceleration: ScalarValue
  /**
   * Multiplier for {@link acceleration}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  accelerationMultiplier: ScalarValue
  /**
   * The particles will turn a random amount based on this value at intervals defined by {@link turnInterval}.
   * 
   * This turning affects the particles' current direction, which can affect various other things, for example this action's {@link acceleration}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  maxTurnAngle: ScalarValue
  /**
   * Controls how well the particles should follow the parent node if they are not attached. At 0, the particles will not follow at all. At 1, the particles will follow perfectly, as if attached to the parent node. Negative values will make the particles move in the opposite direction compared to the parent node. Values greater than 1 will make the particles exaggerate the parent node's movement.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link followRotation}
   */
  followFactor: ScalarValue
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * The particles will turn a random amount based on {@link maxTurnAngle} at this interval. The units are seconds, but due to how the field that stores this value works, the value will be rounded to the nearest 0.02 seconds.
   * 
   * This turning affects the particles' current direction, which can affect various other things, for example this action's {@link acceleration}.
   * 
   * **Default**: `0`
   */
  turnInterval: number
  /**
   * Disabling this will make {@link followFactor} only affect translation and not rotation.
   * 
   * **Default**: `true`
   */
  followRotation: boolean
  constructor(props: Partial<Props<ParticleAccelerationPartialFollow>> = {}) {
    super(ActionType.ParticleAccelerationPartialFollow)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeAccelerationPartialFollow Action 106 - NodeAccelerationPartialFollow}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Controls the movement of the node. This extends {@link ActionType.NodeAccelerationRandomTurns NodeAccelerationRandomTurns} with the ability to make the node partially follow or exaggerate the parent node's movement.
 */
class NodeAccelerationPartialFollow extends DataAction {
  declare readonly type: ActionType.NodeAccelerationPartialFollow
  /**
   * Controls the speed of the node along its Z-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  speedZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Z-axis. This value cannot be negative.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link accelerationY}
   */
  accelerationZ: ScalarValue
  /**
   * Multiplier for {@link accelerationZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationMultiplierZ: ScalarValue
  /**
   * Controls the acceleration of the node along the global Y-axis. When set to anything that isn't 0, this overrides the direction of {@link accelerationZ}.
   * 
   * Note that this for some reason uses the *global* Y-axis instead of the local one, which is used by the same property in {@link ActionType.NodeAcceleration NodeAcceleration}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationY: ScalarValue
  /**
   * The node will turn a random amount based on this value at intervals defined by {@link turnInterval}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  maxTurnAngle: ScalarValue
  /**
   * Controls how well the node should follow the parent node if it is not attached. At 0, the node will not follow at all. At 1, the node will follow perfectly, as if attached to the parent node. Negative values will make the node move in the opposite direction compared to the parent node. Values greater than 1 will make the node exaggerate the parent node's movement.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link followRotation}
   */
  followFactor: ScalarValue
  /**
   * When set to 1, this makes the node align with the direction it's moving. Setting it to higher values seems to do the same as setting it to 0, which means it's probably not a boolean, but what those values do exactly is unknown.
   * 
   * **Default**: `0`
   */
  alignWithMotion: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_1: number
  /**
   * The node will turn a random amount based on {@link maxTurnAngle} at this interval. The units are seconds, but due to how the field that stores this value works, the value will be rounded to the nearest 0.02 seconds.
   * 
   * **Default**: `0`
   */
  turnInterval: number
  /**
   * Disabling this will make {@link followFactor} only affect translation and not rotation.
   * 
   * **Default**: `true`
   */
  followRotation: boolean
  constructor(props: Partial<Props<NodeAccelerationPartialFollow>> = {}) {
    super(ActionType.NodeAccelerationPartialFollow)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeAccelerationSpin Action 113 - NodeAccelerationSpin}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Controls the movement of the node. This extends {@link ActionType.NodeAcceleration NodeAcceleration} with the ability to control the node's angular speed.
 */
class NodeAccelerationSpin extends DataAction {
  declare readonly type: ActionType.NodeAccelerationSpin
  /**
   * Controls the speed of the node along its Z-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  speedZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Z-axis. This value cannot be negative.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationZ: ScalarValue
  /**
   * Multiplier for {@link accelerationZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationMultiplierZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Y-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationY: ScalarValue
  /**
   * The node's angular speed around its local X-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angularSpeedMultiplierX}
   */
  angularSpeedX: ScalarValue
  /**
   * Multiplier for {@link angularSpeedX}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  angularSpeedMultiplierX: ScalarValue
  /**
   * The node's angular speed around its local Y-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angularSpeedMultiplierY}
   */
  angularSpeedY: ScalarValue
  /**
   * Multiplier for {@link angularSpeedY}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  angularSpeedMultiplierY: ScalarValue
  /**
   * The node's angular speed around its local Z-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angularSpeedMultiplierZ}
   */
  angularSpeedZ: ScalarValue
  /**
   * Multiplier for {@link angularSpeedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  angularSpeedMultiplierZ: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_1: number
  /**
   * When set to 1, this makes the node align with the direction it's moving, which also disables the angular speed from this action. Setting it to higher values seems to do the same as setting it to 0, which means it's probably not a boolean, but what those values do exactly is unknown.
   * 
   * **Default**: `0`
   */
  alignWithMotion: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_3: number
  constructor(props: Partial<Props<NodeAccelerationSpin>> = {}) {
    super(ActionType.NodeAccelerationSpin)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeSpeed Action 120 - NodeSpeed}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Controls the movement of the node. This is the most basic action for controlling the speed of nodes.
 */
class NodeSpeed extends DataAction {
  declare readonly type: ActionType.NodeSpeed
  /**
   * Controls the speed of the node along its Z-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  speedZ: ScalarValue
  /**
   * Multiplier for {@link speedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  speedMultiplierZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Y-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationY: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * When set to 1, this makes the node align with the direction it's moving. Setting it to higher values seems to do the same as setting it to 0, which means it's probably not a boolean, but what those values do exactly is unknown.
   * 
   * **Default**: `0`
   */
  alignWithMotion: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_2: number
  constructor(props: Partial<Props<NodeSpeed>> = {}) {
    super(ActionType.NodeSpeed)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeSpeedRandomTurns Action 121 - NodeSpeedRandomTurns}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Controls the movement of the node. This extends {@link ActionType.NodeSpeed NodeSpeed} with the ability to make the node turn a random amount at a given interval.
 */
class NodeSpeedRandomTurns extends DataAction {
  declare readonly type: ActionType.NodeSpeedRandomTurns
  /**
   * Controls the speed of the node along its Z-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  speedZ: ScalarValue
  /**
   * Multiplier for {@link speedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  speedMultiplierZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Y-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationY: ScalarValue
  /**
   * The node will turn a random amount based on this value at intervals defined by {@link turnInterval}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  maxTurnAngle: ScalarValue
  /**
   * When set to 1, this makes the node align with the direction it's moving. Setting it to higher values seems to do the same as setting it to 0, which means it's probably not a boolean, but what those values do exactly is unknown.
   * 
   * **Default**: `0`
   */
  alignWithMotion: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_1: number
  /**
   * The node will turn a random amount based on {@link maxTurnAngle} at this interval. The units are seconds, but due to how the field that stores this value works, the value will be rounded to the nearest 0.02 seconds.
   * 
   * **Default**: `0`
   */
  turnInterval: number
  constructor(props: Partial<Props<NodeSpeedRandomTurns>> = {}) {
    super(ActionType.NodeSpeedRandomTurns)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeSpeedPartialFollow Action 122 - NodeSpeedPartialFollow}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Controls the movement of the node. This extends {@link ActionType.NodeSpeedRandomTurns NodeSpeedRandomTurns} with the ability to make the node partially follow or exaggerate the parent node's movement.
 */
class NodeSpeedPartialFollow extends DataAction {
  declare readonly type: ActionType.NodeSpeedPartialFollow
  /**
   * Controls the speed of the node along its Z-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  speedZ: ScalarValue
  /**
   * Multiplier for {@link speedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  speedMultiplierZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Y-axis.
   * 
   * Note that this for some reason uses the *global* Y-axis instead of the local one, which is used by the same property in {@link ActionType.NodeSpeed NodeSpeed}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationY: ScalarValue
  /**
   * The node will turn a random amount based on this value at intervals defined by {@link turnInterval}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  maxTurnAngle: ScalarValue
  /**
   * Controls how well the node should follow the parent node if it is not attached. At 0, the node will not follow at all. At 1, the node will follow perfectly, as if attached to the parent node. Negative values will make the node move in the opposite direction compared to the parent node. Values greater than 1 will make the node exaggerate the parent node's movement.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link followRotation}
   */
  followFactor: ScalarValue
  /**
   * When set to 1, this makes the node align with the direction it's moving. Setting it to higher values seems to do the same as setting it to 0, which means it's probably not a boolean, but what those values do exactly is unknown.
   * 
   * **Default**: `0`
   */
  alignWithMotion: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_1: number
  /**
   * The node will turn a random amount based on {@link maxTurnAngle} at this interval. The units are seconds, but due to how the field that stores this value works, the value will be rounded to the nearest 0.02 seconds.
   * 
   * **Default**: `0`
   */
  turnInterval: number
  /**
   * Disabling this will make {@link followFactor} only affect translation and not rotation.
   * 
   * **Default**: `true`
   */
  followRotation: boolean
  constructor(props: Partial<Props<NodeSpeedPartialFollow>> = {}) {
    super(ActionType.NodeSpeedPartialFollow)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeSpeedSpin Action 123 - NodeSpeedSpin}
 * **Slot**: {@link ActionSlots.NodeMovementAction NodeMovement}
 * 
 * Controls the movement of the node. This extends {@link ActionType.NodeSpeed NodeSpeed} with the ability to control the node's angular speed.
 */
class NodeSpeedSpin extends DataAction {
  declare readonly type: ActionType.NodeSpeedSpin
  /**
   * Controls the speed of the node along its Z-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  speedZ: ScalarValue
  /**
   * Multiplier for {@link speedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  speedMultiplierZ: ScalarValue
  /**
   * Controls the acceleration of the node along its Y-axis.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationY: ScalarValue
  /**
   * The node's angular speed around its local X-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angularSpeedMultiplierX}
   */
  angularSpeedX: ScalarValue
  /**
   * Multiplier for {@link angularSpeedX}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  angularSpeedMultiplierX: ScalarValue
  /**
   * The node's angular speed around its local Y-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angularSpeedMultiplierY}
   */
  angularSpeedY: ScalarValue
  /**
   * Multiplier for {@link angularSpeedY}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  angularSpeedMultiplierY: ScalarValue
  /**
   * The node's angular speed around its local Z-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angularSpeedMultiplierZ}
   */
  angularSpeedZ: ScalarValue
  /**
   * Multiplier for {@link angularSpeedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  angularSpeedMultiplierZ: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_1: number
  /**
   * When set to 1, this makes the node align with the direction it's moving, which also disables the angular speed from this action. Setting it to higher values seems to do the same as setting it to 0, which means it's probably not a boolean, but what those values do exactly is unknown.
   * 
   * **Default**: `0`
   */
  alignWithMotion: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_3: number
  constructor(props: Partial<Props<NodeSpeedSpin>> = {}) {
    super(ActionType.NodeSpeedSpin)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeAttributes Action 128 - NodeAttributes}
 * **Slot**: {@link ActionSlots.NodeAttributesAction NodeAttributes}
 * 
 * Controls various things about the node, like its duration, and how it is attached to the parent node.
 */
class NodeAttributes extends DataAction {
  declare readonly type: ActionType.NodeAttributes
  /**
   * The node duration in seconds. Can be set to -1 to make the node last forever.
   * 
   * **Default**: `-1`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  duration: ScalarValue
  /**
   * The delay in seconds before the node becomes active.
   * 
   * **Default**: `0`
   */
  delay: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_1: number
  /**
   * Controls how the node is attached to the parent node.
   * 
   * **Default**: {@link AttachMode.Parent}
   */
  attachment: AttachMode
  /**
   * Controls the rendering order of this node. Lower values will cause the node to be drawn in front of nodes with a higher value. This only affects the node with this action, it is not inherited by descendant nodes.
   * 
   * This does not affect the actual depth of the node in the scene. It will still draw behind other objects even with a big negative bias. It only affects the order it is rendered in relative to other effects.
   * 
   * Model particles and light sources are not affected by this in any way. Most, if not all, other types of appearances are affected by it, even GPU particles and lens flares.
   * 
   * **Default**: `0`
   */
  depthBias: number
  constructor(props: Partial<Props<NodeAttributes>> = {}) {
    super(ActionType.NodeAttributes)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleAttributes Action 129 - ParticleAttributes}
 * **Slot**: {@link ActionSlots.ParticleAttributesAction ParticleAttributes}
 * 
 * Controls the duration of particles emitted by the node, and how the particles are attached to the node.
 */
class ParticleAttributes extends DataAction {
  declare readonly type: ActionType.ParticleAttributes
  /**
   * The particle duration in seconds. Can be set to -1 to make particles last forever.
   * 
   * **Default**: `-1`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  duration: ScalarValue
  /**
   * Controls how the particles are attached to the node.
   * 
   * **Default**: {@link AttachMode.Parent}
   */
  attachment: AttachMode
  constructor(props: Partial<Props<ParticleAttributes>> = {}) {
    super(ActionType.ParticleAttributes)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.Unk130 Action 130 - Unk130}
 * **Slot**: {@link ActionSlots.Unknown130Action Unknown130}
 * 
 * Unknown action that is in every basic config in every game, and still literally nothing is known about it.
 */
class Unk130 extends DataAction {
  declare readonly type: ActionType.Unk130
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_0: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_1: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_2: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_3: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_4: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_5: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_6: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_7: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_4: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_5: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_6: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_7: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_8: number
  constructor(props: Partial<Props<Unk130>> = {}) {
    super(ActionType.Unk130)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleModifier Action 131 - ParticleModifier}
 * **Slot**: {@link ActionSlots.ParticleModifierAction ParticleModifier}
 * 
 * Modifies particles in various ways.
 * 
 * Note: This is **not** a {@link Modifier property modifier}, it is an action that modifies particles emitted from the same node.
 */
class ParticleModifier extends DataAction {
  declare readonly type: ActionType.ParticleModifier
  /**
   * Controls the speed of the particles emitted from this node, but only if the config has an action in the {@link ActionSlots.ParticleMovementAction ParticleMovement slot} that enables acceleration of particles. The direction is the particle's {@link InitialDirection initial direction}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  speed: ScalarValue
  /**
   * Multiplier for the scale along the X-axis for the particles emitted from this node.
   * 
   * If {@link uniformScale} is enabled, this also affects the Y and Z axes.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   */
  scaleX: ScalarValue
  /**
   * Multiplier for the scale along the Y-axis for the particles emitted from this node.
   * 
   * If {@link uniformScale} is enabled, {@link scaleX} also affects the Y-axis, and this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   */
  scaleY: ScalarValue
  /**
   * Multiplier for the scale along the Z-axis for the particles emitted from this node.
   * 
   * If {@link uniformScale} is enabled, {@link scaleX} also affects the Z-axis, and this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   */
  scaleZ: ScalarValue
  /**
   * Color multiplier for the particles emitted from this node.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  color: Vector4Value
  /**
   * Scales the particles emitted from this node uniformly based on {@link scaleX}. The other scale properties in this action have no effect when this is enabled.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link scaleX}
   * - {@link scaleY}
   * - {@link scaleZ}
   */
  uniformScale: boolean
  constructor(props: Partial<Props<ParticleModifier>> = {}) {
    super(ActionType.ParticleModifier)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.SFXReference Action 132 - SFXReference}
 * **Slot**: {@link ActionSlots.SFXReferenceAction SFXReference}
 * 
 * References another SFX by its ID.
 */
class SFXReference extends DataAction {
  declare readonly type: ActionType.SFXReference
  /**
   * The ID of the referenced SFX.
   * 
   * **Default**: `0`
   */
  sfx: number
  /**
   * @param sfx The ID of the referenced SFX.
   *
   * **Default**: `0`
   */
  constructor(sfx: number = 0) {
    super(ActionType.SFXReference)
    this.assign({ sfx })
  }
}

/**
 * ### {@link ActionType.LevelsOfDetailThresholds Action 133 - LevelsOfDetailThresholds}
 * **Slot**: {@link ActionSlots.LevelsOfDetailThresholdsAction LevelsOfDetailThresholds}
 * 
 * Used in the {@link ConfigType.LevelsOfDetail levels of detail config} to manage the duration and thresholds for the {@link NodeType.LevelsOfDetail levels of detail node}.
 */
class LevelsOfDetailThresholds extends DataAction {
  declare readonly type: ActionType.LevelsOfDetailThresholds
  /**
   * The node duration in seconds. Can be set to -1 to make the node last forever.
   * 
   * **Default**: `-1`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  duration: ScalarValue
  /**
   * Distance threshold for child node 0.
   * 
   * **Default**: `10000`
   */
  threshold0: number
  /**
   * Distance threshold for child node 1.
   * 
   * **Default**: `10000`
   */
  threshold1: number
  /**
   * Distance threshold for child node 2.
   * 
   * **Default**: `10000`
   */
  threshold2: number
  /**
   * Distance threshold for child node 3.
   * 
   * **Default**: `10000`
   */
  threshold3: number
  /**
   * Distance threshold for child node 4.
   * 
   * **Default**: `10000`
   */
  threshold4: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_5: number
  constructor(props: Partial<Props<LevelsOfDetailThresholds>> = {}) {
    super(ActionType.LevelsOfDetailThresholds)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.StateConfigMap Action 199 - StateConfigMap}
 * **Slot**: {@link ActionSlots.StateConfigMapAction StateConfigMap}
 * 
 * Maps states to configs in the parent node.
 */
class StateConfigMap extends DataAction {
  declare readonly type: ActionType.StateConfigMap
  /**
   * A list of config indices.
   * 
   * The index of each value represents the index of the state, and the value represents the index of the config that should be active when the state is active.
   * 
   * **Default**: `[0]`
   */
  configIndices: number[]
  /**
   * @param configIndices A list of config indices.
   * 
   * The index of each value represents the index of the state, and the value represents the index of the config that should be active when the state is active.
   *
   * **Default**: `[0]`
   */
  constructor(configIndices: number[] = [0]) {
    super(ActionType.StateConfigMap)
    this.assign({ configIndices })
  }
}

/**
 * ### {@link ActionType.SelectAllNodes Action 200 - SelectAllNodes}
 * **Slot**: {@link ActionSlots.NodeSelectorAction NodeSelector}
 * 
 * Used in {@link ConfigType.NodeEmitter NodeEmitter configs} to emit all child nodes every emission.
 */
class SelectAllNodes extends DataAction {
  declare readonly type: ActionType.SelectAllNodes
  
  constructor() {
    super(ActionType.SelectAllNodes)
  }
}

/**
 * ### {@link ActionType.SelectRandomNode Action 201 - SelectRandomNode}
 * **Slot**: {@link ActionSlots.NodeSelectorAction NodeSelector}
 * 
 * Used in {@link ConfigType.NodeEmitter NodeEmitter configs} to emit a random child node every emission.
 */
class SelectRandomNode extends DataAction {
  declare readonly type: ActionType.SelectRandomNode
  /**
   * Probability weights for each child node to be selected for emission.
   * 
   * The weights are stored as integers, so non-integer values in this list will be truncated.
   * 
   * **Default**: `[1]`
   */
  weights: number[]
  /**
   * @param weights Probability weights for each child node to be selected for emission.
   * 
   * The weights are stored as integers, so non-integer values in this list will be truncated.
   *
   * **Default**: `[1]`
   */
  constructor(weights: number[] = [1]) {
    super(ActionType.SelectRandomNode)
    this.assign({ weights })
  }
}

/**
 * ### {@link ActionType.PeriodicEmitter Action 300 - PeriodicEmitter}
 * **Slot**: {@link ActionSlots.EmitterAction Emitter}
 * 
 * Emits particles periodically.
 */
class PeriodicEmitter extends DataAction {
  declare readonly type: ActionType.PeriodicEmitter
  /**
   * Time between emitting new particles in seconds.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  interval: ScalarValue
  /**
   * The number of particles or nodes to emit per emission.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  perEmission: ScalarValue
  /**
   * The total number of emissions. Once this limit is reached, the branch will be *removed from the effect*. The node and all of its descendants will be destroyed, and there are no ways to re-enable them without respawning the entire effect as they no longer exist.
   * 
   * Can be set to `-1` to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  totalEmissions: ScalarValue
  /**
   * Maximum number of concurrent emitted particles or nodes. Can be set to `-1` to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  maxConcurrent: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_1: number
  constructor(props: Partial<Props<PeriodicEmitter>> = {}) {
    super(ActionType.PeriodicEmitter)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.EqualDistanceEmitter Action 301 - EqualDistanceEmitter}
 * **Slot**: {@link ActionSlots.EmitterAction Emitter}
 * 
 * Emits particles once it has moved a certain distance from where it last emitted particles.
 */
class EqualDistanceEmitter extends DataAction {
  declare readonly type: ActionType.EqualDistanceEmitter
  /**
   * How much the emitter must move to trigger emission.
   * 
   * **Default**: `0.1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  threshold: ScalarValue
  /**
   * The total number of emissions. Once this limit is reached, the branch will be *removed from the effect*. The node and all of its descendants will be destroyed, and there are no ways to re-enable them without respawning the entire effect as they no longer exist.
   * 
   * Can be set to `-1` to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  totalEmissions: ScalarValue
  /**
   * Maximum number of concurrent emitted particles or nodes. Can be set to `-1` to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  maxConcurrent: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p1_1: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_1: number
  constructor(props: Partial<Props<EqualDistanceEmitter>> = {}) {
    super(ActionType.EqualDistanceEmitter)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.OneTimeEmitter Action 399 - OneTimeEmitter}
 * **Slot**: {@link ActionSlots.EmitterAction Emitter}
 * 
 * Emits one particle once.
 */
class OneTimeEmitter extends DataAction {
  declare readonly type: ActionType.OneTimeEmitter
  
  constructor() {
    super(ActionType.OneTimeEmitter)
  }
}

/**
 * ### {@link ActionType.PointEmitterShape Action 400 - PointEmitterShape}
 * **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
 * 
 * Makes the emitter a single point.
 */
class PointEmitterShape extends DataAction {
  declare readonly type: ActionType.PointEmitterShape
  /**
   * Controls the initial direction for particles. See {@link InitialDirection} for more information.
   * 
   * **Default**: {@link InitialDirection.Emitter}
   */
  direction: InitialDirection
  /**
   * @param direction Controls the initial direction for particles. See {@link InitialDirection} for more information.
   *
   * **Default**: {@link InitialDirection.Emitter}
   */
  constructor(direction: InitialDirection = InitialDirection.Emitter) {
    super(ActionType.PointEmitterShape)
    this.assign({ direction })
  }
}

/**
 * ### {@link ActionType.DiskEmitterShape Action 401 - DiskEmitterShape}
 * **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
 * 
 * Makes the emitter disk-shaped.
 */
class DiskEmitterShape extends DataAction {
  declare readonly type: ActionType.DiskEmitterShape
  /**
   * Radius of the disk.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  radius: ScalarValue
  /**
   * Controls how the random emission points are distributed within the disk.
   * - At 0, particles are equally likely to emit from anywhere inside the disk.
   * - At 1, particles have a 100% chance of being emitted from the center point.
   * - At -1, particles have a 100% chance of being emitted from the perimeter circle of the disk.
   * - Values between these smoothly blend between them.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  distribution: ScalarValue
  /**
   * Controls the initial direction for particles. See {@link InitialDirection} for more information.
   * 
   * **Default**: {@link InitialDirection.Emitter}
   */
  direction: InitialDirection
  constructor(props: Partial<Props<DiskEmitterShape>> = {}) {
    super(ActionType.DiskEmitterShape)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.RectangleEmitterShape Action 402 - RectangleEmitterShape}
 * **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
 * 
 * Makes the emitter rectangular.
 */
class RectangleEmitterShape extends DataAction {
  declare readonly type: ActionType.RectangleEmitterShape
  /**
   * Width of the rectangle.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  sizeX: ScalarValue
  /**
   * Height of the rectangle.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  sizeY: ScalarValue
  /**
   * Controls how the random emission points are distributed within the rectangle.
   * - At 0, particles are equally likely to emit from anywhere inside the rectangle.
   * - At 1, particles have a 100% chance of being emitted from the center point.
   * - At -1, particles have a 100% chance of being emitted from the perimeter of the rectangle.
   * - Values between these smoothly blend between them.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  distribution: ScalarValue
  /**
   * Controls the initial direction for particles. See {@link InitialDirection} for more information.
   * 
   * **Default**: {@link InitialDirection.Emitter}
   */
  direction: InitialDirection
  constructor(props: Partial<Props<RectangleEmitterShape>> = {}) {
    super(ActionType.RectangleEmitterShape)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.SphereEmitterShape Action 403 - SphereEmitterShape}
 * **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
 * 
 * Makes the emitter spherical.
 */
class SphereEmitterShape extends DataAction {
  declare readonly type: ActionType.SphereEmitterShape
  /**
   * Radius of the sphere.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  radius: ScalarValue
  /**
   * If true, particles will be emitted from anywhere within the sphere. Otherwise the particles will be emitted only from the surface of the sphere.
   * 
   * **Default**: `true`
   */
  emitInside: boolean
  constructor(props: Partial<Props<SphereEmitterShape>> = {}) {
    super(ActionType.SphereEmitterShape)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.BoxEmitterShape Action 404 - BoxEmitterShape}
 * **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
 * 
 * Makes the emitter cuboidal.
 */
class BoxEmitterShape extends DataAction {
  declare readonly type: ActionType.BoxEmitterShape
  /**
   * Width of the cuboid.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  sizeX: ScalarValue
  /**
   * Height of the cuboid.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  sizeY: ScalarValue
  /**
   * Depth of the cuboid.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  sizeZ: ScalarValue
  /**
   * Controls the initial direction for particles. See {@link InitialDirection} for more information.
   * 
   * **Default**: {@link InitialDirection.Emitter}
   */
  direction: InitialDirection
  /**
   * If true, particles will be emitted from anywhere within the cuboid. Otherwise the particles will be emitted only from the surface of the cuboid.
   * 
   * **Default**: `true`
   */
  emitInside: boolean
  constructor(props: Partial<Props<BoxEmitterShape>> = {}) {
    super(ActionType.BoxEmitterShape)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.CylinderEmitterShape Action 405 - CylinderEmitterShape}
 * **Slot**: {@link ActionSlots.EmitterShapeAction EmitterShape}
 * 
 * Makes the emitter cylindrical.
 */
class CylinderEmitterShape extends DataAction {
  declare readonly type: ActionType.CylinderEmitterShape
  /**
   * The radius of the cylinder.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  radius: ScalarValue
  /**
   * The height of the cylinder.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  height: ScalarValue
  /**
   * Controls the initial direction for particles. See {@link InitialDirection} for more information.
   * 
   * **Default**: {@link InitialDirection.Emitter}
   */
  direction: InitialDirection
  /**
   * If true, particles will be emitted from anywhere within the cylinder. Otherwise the particles will be emitted only from the surface of the cylinder, excluding the ends.
   * 
   * **Default**: `true`
   */
  emitInside: boolean
  /**
   * If true, the cylinder will be aligned with the Y-axis instead of the Z-axis.
   * 
   * **Default**: `true`
   */
  yAxis: boolean
  constructor(props: Partial<Props<CylinderEmitterShape>> = {}) {
    super(ActionType.CylinderEmitterShape)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NoSpread Action 500 - NoSpread}
 * **Slot**: {@link ActionSlots.DirectionSpreadAction DirectionSpread}
 * 
 * Makes all emitted instances have the default initial direction from the emitter. See {@link InitialDirection} for more information.
 */
class NoSpread extends DataAction {
  declare readonly type: ActionType.NoSpread
  
  constructor() {
    super(ActionType.NoSpread)
  }
}

/**
 * ### {@link ActionType.CircularSpread Action 501 - CircularSpread}
 * **Slot**: {@link ActionSlots.DirectionSpreadAction DirectionSpread}
 * 
 * Gives each emitted instance a random initial direction offset within a circular cone. See {@link InitialDirection} for more information.
 */
class CircularSpread extends DataAction {
  declare readonly type: ActionType.CircularSpread
  /**
   * The maximum change in direction in degrees, the angle of the cone.
   * 
   * **Default**: `30`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  angle: ScalarValue
  /**
   * Controls the distribution of the random directions that can be chosen.
   * - At 0, all directions within the cone have an equal chance of being chosen.
   * - At 1, the default direction is guaranteed to be chosen.
   * - At -1, the maximum change in direction is guaranteed, meaning the chosen direction will always be a fixed number of degrees away from the default direction based on {@link angle}.
   * - Values between these values smoothly blend between them.
   * - Values outside of the -1 to 1 range also work, but may do some unexpected things.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  distribution: ScalarValue
  /**
   * No so much unknown, just unnamed. If enabled, this limits the possible directions to only positive values on one axis, effectively cutting the cone of possible directions in half.
   * 
   * **Default**: `false`
   */
  unk_er_f1_0: boolean
  constructor(props: Partial<Props<CircularSpread>> = {}) {
    super(ActionType.CircularSpread)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.EllipticalSpread Action 502 - EllipticalSpread}
 * **Slot**: {@link ActionSlots.DirectionSpreadAction DirectionSpread}
 * 
 * Gives each emitted instance a random initial direction offset within an elliptical cone. See {@link InitialDirection} for more information.
 */
class EllipticalSpread extends DataAction {
  declare readonly type: ActionType.EllipticalSpread
  /**
   * The maximum change in direction in degrees, one of the angles of the elliptical cone.
   * 
   * **Default**: `30`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angleY}
   */
  angleX: ScalarValue
  /**
   * The maximum change in direction in degrees, one of the angles of the elliptical cone.
   * 
   * **Default**: `30`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angleY}
   */
  angleY: ScalarValue
  /**
   * Controls the distribution of the random directions that can be chosen.
   * - At 0, all directions within the cone have an equal chance of being chosen.
   * - At 1, the default direction is guaranteed to be chosen.
   * - At -1, the maximum change in direction is guaranteed, meaning the chosen direction will always be a fixed number of degrees away from the default direction based on {@link angleX} and {@link angleY}.
   * - Values between these values smoothly blend between them.
   * - Values outside of the -1 to 1 range also work, but may do some unexpected things.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  distribution: ScalarValue
  /**
   * No so much unknown, just unnamed. If enabled, this limits the possible directions to only positive values on one axis, effectively cutting the cone of possible directions in half.
   * 
   * **Default**: `false`
   */
  unk_er_f1_0: boolean
  constructor(props: Partial<Props<EllipticalSpread>> = {}) {
    super(ActionType.EllipticalSpread)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.RectangularSpread Action 503 - RectangularSpread}
 * **Slot**: {@link ActionSlots.DirectionSpreadAction DirectionSpread}
 * 
 * Gives each emitted instance a random initial direction offset within a rectangular cone. See {@link InitialDirection} for more information.
 */
class RectangularSpread extends DataAction {
  declare readonly type: ActionType.RectangularSpread
  /**
   * The maximum change in direction in degrees, one of the angles of the elliptical cone.
   * 
   * **Default**: `30`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angleY}
   */
  angleX: ScalarValue
  /**
   * The maximum change in direction in degrees, one of the angles of the elliptical cone.
   * 
   * **Default**: `30`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link angleX}
   */
  angleY: ScalarValue
  /**
   * Controls the distribution of the random directions that can be chosen.
   * - At 0, all directions within the cone have an equal chance of being chosen.
   * - At 1, the default direction is guaranteed to be chosen.
   * - At -1, the maximum change in direction is guaranteed, meaning the chosen direction will always be a fixed number of degrees away from the default direction based on {@link angleX} and {@link angleY}.
   * - Values between these values smoothly blend between them.
   * - Values outside of the -1 to 1 range also work, but may do some unexpected things.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  distribution: ScalarValue
  constructor(props: Partial<Props<RectangularSpread>> = {}) {
    super(ActionType.RectangularSpread)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.PointSprite Action 600 - PointSprite}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Very basic point sprite particle. Similar to {@link ActionType.BillboardEx BillboardEx}, but far simpler.
 */
class PointSprite extends DataAction {
  declare readonly type: ActionType.PointSprite
  /**
   * Texture ID.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  texture: ScalarValue
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  blendMode: BlendMode | ScalarProperty
  /**
   * Particle size.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  size: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link color3}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color2}
   * - {@link color3}
   */
  color1: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. There is no equivalent property with unrestricted values based on the emission time of the particle, but {@link color3} is still multiplicative with this and can be used to scale the values indirectly.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color3}
   */
  color2: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this are unrestricted and can go above 1. If you want values to be clamped to the 0-1 range, see {@link color1}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   */
  color3: Vector4Value
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * This threshold creates a hard cut-off between visible and not visible, which is unlike the alpha *fade* threshold properties in some similar actions.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaThreshold: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_ds3_f1_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_ds3_f1_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_4: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_4: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Controls whether or not the particles have an additional bloom effect controlled by {@link bloomColor}.
   * 
   * When enabled, this also allows bloom from other particles to be seen through this particle.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown float.
   * 
   * This seems to be some sort of distance threshold. When the camera is within this distance, some things will look different in some ways. For example, when within the distance and the {@link blendMode blend mode} is set to {@link BlendMode.Subtract}, the opacity doesn't work the way it normally does. Other effects have been found as well, but what exactly this threshold is for is unknown.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_29: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_30: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_31: number
  /**
   * Unknown boolean.
   * 
   * When enabled, it seems to stop {@link unk_ds3_f2_29} from doing whatever it is doing, and it can also cause some ugly "outline" effects on things seen through particles, but it also fixes an issue where some other particles can be seen through this particle.
   * 
   * **Default**: `false`
   */
  unk_sdt_f2_32: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_33: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_sdt_f2_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_38: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_39: number
  constructor(props: Partial<Props<PointSprite>> = {}) {
    super(ActionType.PointSprite)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.Line Action 601 - Line}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Simple line particle. It automatically rotates to match the direction it's moving.
 */
class Line extends DataAction {
  declare readonly type: ActionType.Line
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  blendMode: BlendMode | ScalarProperty
  /**
   * The length of the line.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   * 
   * See also:
   * - {@link lengthMultiplier}
   */
  length: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. This is seemingly identical to {@link color2}. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color2}
   * - {@link color3}
   * - {@link startColor}
   * - {@link endColor}
   */
  color1: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. This is seemingly identical to {@link color1}. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color1}
   * - {@link color3}
   * - {@link startColor}
   * - {@link endColor}
   */
  color2: Vector4Value
  /**
   * The color for the start of the line.
   * 
   * Values in this will be clamped to the 0-1 range. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   * - {@link color3}
   * - {@link endColor}
   */
  startColor: Vector4Value
  /**
   * The color for the end of the line.
   * 
   * Values in this will be clamped to the 0-1 range. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   * - {@link color3}
   * - {@link startColor}
   */
  endColor: Vector4Value
  /**
   * Multiplier for the line {@link length}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  lengthMultiplier: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   * - {@link startColor}
   * - {@link endColor}
   */
  color3: Vector4Value
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * This threshold creates a hard cut-off between visible and not visible, which is unlike the alpha *fade* threshold properties in some similar actions.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaThreshold: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Controls whether or not the particles have an additional bloom effect controlled by {@link bloomColor}.
   * 
   * When enabled, this also allows bloom from other particles to be seen through this particle.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown float.
   * 
   * This seems to be some sort of distance threshold. When the camera is within this distance, some things will look different in some ways. For example, when within the distance and the {@link blendMode blend mode} is set to {@link BlendMode.Subtract}, the opacity doesn't work the way it normally does. Other effects have been found as well, but what exactly this threshold is for is unknown.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_29: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_30: number
  /**
   * When set to 1, this stops the particles from being shown indoors.
   * 
   * Other values are used in AC6, but what they do is unknown.
   * 
   * **Default**: `0`
   */
  unkHideIndoors: number
  /**
   * Unknown boolean.
   * 
   * When enabled, it seems to stop {@link unk_ds3_f2_29} from doing whatever it is doing, and it can also cause some ugly "outline" effects on things seen through particles, but it also fixes an issue where some other particles can be seen through this particle.
   * 
   * **Default**: `false`
   */
  unk_sdt_f2_32: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_33: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_38: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_39: number
  constructor(props: Partial<Props<Line>> = {}) {
    super(ActionType.Line)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.QuadLine Action 602 - QuadLine}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Simple rectangular particle, very similar to {@link ActionType.Line Line particles}, but has properties that control the width as well as the length. It automatically rotates to match the direction it's moving.
 */
class QuadLine extends DataAction {
  declare readonly type: ActionType.QuadLine
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  blendMode: BlendMode | ScalarProperty
  /**
   * The width of the line.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   * 
   * See also:
   * - {@link widthMultiplier}
   */
  width: ScalarValue
  /**
   * The length of the line.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   * 
   * See also:
   * - {@link lengthMultiplier}
   */
  length: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. This is seemingly identical to {@link color2}. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color2}
   * - {@link color3}
   * - {@link startColor}
   * - {@link endColor}
   */
  color1: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. This is seemingly identical to {@link color1}. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color1}
   * - {@link color3}
   * - {@link startColor}
   * - {@link endColor}
   */
  color2: Vector4Value
  /**
   * The color for the leading edge of the quad.
   * 
   * Values in this will be clamped to the 0-1 range. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   * - {@link color3}
   * - {@link endColor}
   */
  startColor: Vector4Value
  /**
   * The color for the trailing edge of the quad.
   * 
   * Values in this will be clamped to the 0-1 range. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   * - {@link color3}
   * - {@link startColor}
   */
  endColor: Vector4Value
  /**
   * Multiplier for the line {@link width}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  widthMultiplier: ScalarValue
  /**
   * Multiplier for the line {@link length}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  lengthMultiplier: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   * - {@link startColor}
   * - {@link endColor}
   */
  color3: Vector4Value
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * This threshold creates a hard cut-off between visible and not visible, which is unlike the alpha *fade* threshold properties in some similar actions.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaThreshold: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Controls whether or not the particles have an additional bloom effect controlled by {@link bloomColor}.
   * 
   * When enabled, this also allows bloom from other particles to be seen through this particle.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown float.
   * 
   * This seems to be some sort of distance threshold. When the camera is within this distance, some things will look different in some ways. For example, when within the distance and the {@link blendMode blend mode} is set to {@link BlendMode.Subtract}, the opacity doesn't work the way it normally does. Other effects have been found as well, but what exactly this threshold is for is unknown.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_29: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_30: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_31: number
  /**
   * Unknown boolean.
   * 
   * When enabled, it seems to stop {@link unk_ds3_f2_29} from doing whatever it is doing, and it can also cause some ugly "outline" effects on things seen through particles, but it also fixes an issue where some other particles can be seen through this particle.
   * 
   * **Default**: `false`
   */
  unk_sdt_f2_32: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_33: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_38: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_39: number
  constructor(props: Partial<Props<QuadLine>> = {}) {
    super(ActionType.QuadLine)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.BillboardEx Action 603 - BillboardEx}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Particle with a texture that may be animated. This is the most common particle type and it has a lot of useful fields and properties.
 */
class BillboardEx extends DataAction {
  declare readonly type: ActionType.BillboardEx
  /**
   * Texture ID.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  texture: ScalarValue
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  blendMode: BlendMode | ScalarProperty
  /**
   * X position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  offsetX: ScalarValue
  /**
   * Y position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  offsetY: ScalarValue
  /**
   * Z position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  offsetZ: ScalarValue
  /**
   * The width of the particle.
   * 
   * If {@link uniformScale} is enabled, this also controls the height.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationX}
   */
  width: ScalarValue
  /**
   * The height of the particle.
   * 
   * If {@link uniformScale} is enabled, {@link width} also controls the height, and this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationY}
   */
  height: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link color3}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color2}
   * - {@link color3}
   */
  color1: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. There is no equivalent property with unrestricted values based on the emission time of the particle, but {@link color3} is still multiplicative with this and can be used to scale the values indirectly.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color3}
   */
  color2: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this are unrestricted and can go above 1. If you want values to be clamped to the 0-1 range, see {@link color1}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   */
  color3: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * Values above this threshold will be stretched to fill the alpha range, so values near the threshold will be less visible, creating a smooth transition between the parts that have been hidden by the threshold and the ones that are still visible.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  alphaFadeThreshold: ScalarValue
  /**
   * Rotation around the X-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedX}
   * - {@link angularSpeedMultiplierX}
   */
  rotationX: ScalarValue
  /**
   * Rotation around the Y-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedY}
   * - {@link angularSpeedMultiplierY}
   */
  rotationY: ScalarValue
  /**
   * Rotation around the Z-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedZ}
   * - {@link angularSpeedMultiplierZ}
   */
  rotationZ: ScalarValue
  /**
   * Angular speed around the X-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationX}
   * - {@link angularSpeedMultiplierX}
   */
  angularSpeedX: ScalarValue
  /**
   * Multiplier for {@link angularSpeedX}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationX}
   */
  angularSpeedMultiplierX: ScalarValue
  /**
   * Angular speed around the Y-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationY}
   * - {@link angularSpeedMultiplierY}
   */
  angularSpeedY: ScalarValue
  /**
   * Multiplier for {@link angularSpeedY}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationY}
   */
  angularSpeedMultiplierY: ScalarValue
  /**
   * Angular speed around the Z-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationZ}
   * - {@link angularSpeedMultiplierZ}
   */
  angularSpeedZ: ScalarValue
  /**
   * Multiplier for {@link angularSpeedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationZ}
   */
  angularSpeedMultiplierZ: ScalarValue
  /**
   * Positive values will make the particle draw in front of objects closer to the camera, while negative values will make it draw behind objects farther away from the camera.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  depthOffset: ScalarValue
  /**
   * The index of the frame to show from the texture atlas. Can be animated using a {@link PropertyFunction.Linear linear property} or similar.
   * 
   * Seemingly identical to {@link frameIndexOffset}? The sum of these two properties is the actual frame index that gets used.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  frameIndex: ScalarValue
  /**
   * Seemingly identical to {@link frameIndex}? The sum of these two properties is the actual frame index that gets used.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  frameIndexOffset: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_21: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_22: ScalarValue
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * This threshold creates a hard cut-off between visible and not visible, which is unlike the {@link alphaFadeThreshold}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaThreshold: ScalarValue
  /**
   * Controls the orientation mode for the particles. See {@link OrientationMode} for more information.
   * 
   * **Default**: {@link OrientationMode.CameraPlane}
   */
  orientation: OrientationMode
  /**
   * Normal map texture ID.
   * 
   * **Default**: `0`
   */
  normalMap: number
  /**
   * Each particle will pick a random number between this value and 1, and the width of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly thinner, down to half width. Setting it to 2 will make them randomly wider, up to double width.
   * 
   * If {@link uniformScale} is enabled, this also affects the height.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationY}
   */
  scaleVariationX: number
  /**
   * Each particle will pick a random number between this value and 1, and the height of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly shorter, down to half height. Setting it to 2 will make them randomly taller, up to double height.
   * 
   * If {@link uniformScale} is enabled, {@link scaleVariationX} also affects the height, and this field is ignored.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationX}
   */
  scaleVariationY: number
  /**
   * If enabled, the particle width-related properties and fields will control both the width and height of the particles, and the height counterparts will be ignored.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link width}
   * - {@link height}
   * - {@link scaleVariationX}
   * - {@link scaleVariationY}
   */
  uniformScale: boolean
  /**
   * When `true`, scaling is applied before rotation for the particle, which allows non-square particles to maintain their shape when rotated. When `false`, scaling is applied after rotation, which allows particles to be skewed, for example a square rotated 45 degrees and then made thinner will turn into a diamond shape.
   * 
   * **Default**: `true`
   */
  scaleBeforeRotation: boolean
  /**
   * To split the texture into multiple animation frames, this value must be set to the number of columns in the texture. It should equal `textureWidth / frameWidth`.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link totalFrames}
   */
  columns: number
  /**
   * To split the texture into multiple animation frames, this value must be set to the total number of frames in the texture.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link columns}
   */
  totalFrames: number
  /**
   * If enabled, the texture animation will use linear interpolation to mix frames when the frame index is not a whole number. For example, if the frame index is 0.5, enabling this will cause the average of the first two frames to be shown instead of just the first frame.
   * 
   * If disabled, the frame index will be truncated to get a whole number.
   * 
   * **Default**: `true`
   * 
   * See also:
   * - {@link frameIndex}
   * - {@link frameIndexOffset}
   */
  interpolateFrames: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_12: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_13: number
  /**
   * Controls how the particles should render when behind something else. If disabled, the particles will simply be drawn behind anything they are behind in the world. If enabled, they will instead display in front of the object if they are close enough, and will fade out with distance from the object's surface that is blocking the view of the particle.
   * 
   * **Default**: `true`
   */
  depthBlend: boolean
  /**
   * Controls the shape of the particles. If disabled, the particles will be rectangular. If enabled, they will be octagonal.
   * 
   * **Default**: `false`
   */
  octagonal: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer. Possibly boolean?
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Controls whether or not the particles have an additional bloom effect controlled by {@link bloomColor}.
   * 
   * When enabled, this also allows bloom from other particles to be seen through this particle.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown float.
   * 
   * This seems to be some sort of distance threshold. When the camera is within this distance, some things will look different in some ways. For example, when within the distance and the {@link blendMode blend mode} is set to {@link BlendMode.Subtract}, the opacity doesn't work the way it normally does. Other effects have been found as well, but what exactly this threshold is for is unknown.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_29: number
  /**
   * Controls how dark shaded parts of the particle are.
   * 
   * **Default**: `0`
   */
  shadowDarkness: number
  /**
   * When set to 1, this stops the particles from being shown indoors.
   * 
   * Other values are used in AC6, but what they do is unknown.
   * 
   * **Default**: `0`
   */
  unkHideIndoors: number
  /**
   * Unknown boolean.
   * 
   * When enabled, it seems to stop {@link unk_ds3_f2_29} from doing whatever it is doing, and it can also cause some ugly "outline" effects on things seen through particles, but it also fixes an issue where some other particles can be seen through this particle.
   * 
   * **Default**: `false`
   */
  unk_sdt_f2_32: boolean
  /**
   * Specular texture ID.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link lighting}
   * - {@link glossiness}
   * - {@link specularity}
   */
  specular: number
  /**
   * Controls how sharp the specular highlights are.
   * 
   * **Default**: `0.25`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   * - {@link specularity}
   */
  glossiness: number
  /**
   * Controls how the particles are lit. See {@link LightingMode} for more information.
   * 
   * **Default**: `-1`
   */
  lighting: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Controls how bright the specular highlights are.
   * 
   * **Default**: `0.5`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   * - {@link glossiness}
   */
  specularity: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_sdt_f2_39: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_40: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_41: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_42: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_43: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_44: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_45: number
  constructor(props: Partial<Props<BillboardEx>> = {}) {
    super(ActionType.BillboardEx)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.MultiTextureBillboardEx Action 604 - MultiTextureBillboardEx}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Particle with multiple textures that can scroll.
 */
class MultiTextureBillboardEx extends DataAction {
  declare readonly type: ActionType.MultiTextureBillboardEx
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  blendMode: BlendMode | ScalarProperty
  /**
   * X position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  offsetX: ScalarValue
  /**
   * Y position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  offsetY: ScalarValue
  /**
   * Z position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  offsetZ: ScalarValue
  /**
   * The width of the particle.
   * 
   * If {@link uniformScale} is enabled, this also controls the height.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  width: ScalarValue
  /**
   * The height of the particle.
   * 
   * If {@link uniformScale} is enabled, {@link width} also controls the height, and this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  height: ScalarValue
  /**
   * Rotation around the X-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedX}
   * - {@link angularSpeedMultiplierX}
   */
  rotationX: ScalarValue
  /**
   * Rotation around the Y-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedY}
   * - {@link angularSpeedMultiplierY}
   */
  rotationY: ScalarValue
  /**
   * Rotation around the Z-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedZ}
   * - {@link angularSpeedMultiplierZ}
   */
  rotationZ: ScalarValue
  /**
   * Angular speed around the X-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationX}
   * - {@link angularSpeedMultiplierX}
   */
  angularSpeedX: ScalarValue
  /**
   * Multiplier for {@link angularSpeedX}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationX}
   */
  angularSpeedMultiplierX: ScalarValue
  /**
   * Angular speed around the Y-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationY}
   * - {@link angularSpeedMultiplierY}
   */
  angularSpeedY: ScalarValue
  /**
   * Multiplier for {@link angularSpeedY}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationY}
   */
  angularSpeedMultiplierY: ScalarValue
  /**
   * Angular speed around the Z-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationZ}
   * - {@link angularSpeedMultiplierZ}
   */
  angularSpeedZ: ScalarValue
  /**
   * Multiplier for {@link angularSpeedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationZ}
   */
  angularSpeedMultiplierZ: ScalarValue
  /**
   * Color multiplier for the particle.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link color3}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color2}
   * - {@link color3}
   */
  color1: Vector4Value
  /**
   * Color multiplier for the particle.
   * 
   * Values in this will be clamped to the 0-1 range. There is no equivalent property with unrestricted values based on the emission time of the particle, but {@link color3} is still multiplicative with this and can be used to scale the values indirectly.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color3}
   */
  color2: Vector4Value
  /**
   * Color multiplier for the particle.
   * 
   * Values in this are unrestricted and can go above 1. If you want values to be clamped to the 0-1 range, see {@link color1}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   */
  color3: Vector4Value
  /**
   * Color multiplier for Layer 1.
   * 
   * Values in this will be clamped to the 0-1 range.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer1Color: Vector4Value
  /**
   * Color multiplier for Layer 2.
   * 
   * Values in this will be clamped to the 0-1 range.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer2Color: Vector4Value
  /**
   * Color multiplier for Layer 3.
   * 
   * Values in this will be clamped to the 0-1 range.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer3Color: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * Values above this threshold will be stretched to fill the alpha range, so values near the threshold will be less visible, creating a smooth transition between the parts that have been hidden by the threshold and the ones that are still visible.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  alphaFadeThreshold: ScalarValue
  /**
   * The index of the frame to show from the texture atlas. Can be animated using a {@link PropertyFunction.Linear linear property} or similar.
   * 
   * Seemingly identical to {@link frameIndexOffset}? The sum of these two properties is the actual frame index that gets used.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  frameIndex: ScalarValue
  /**
   * Seemingly identical to {@link frameIndex}? The sum of these two properties is the actual frame index that gets used.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  frameIndexOffset: ScalarValue
  /**
   * Horiztonal scroll speed for Layer 1.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer1SpeedU: ScalarValue
  /**
   * Vertical scroll speed for Layer 1.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer1SpeedV: ScalarValue
  /**
   * Horizontal offset for the UV coordinates of Layer 1.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  layer1OffsetU: ScalarValue
  /**
   * Vertical offset for the UV coordinates of Layer 1.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  layer1OffsetV: ScalarValue
  /**
   * Horizontal scale for the UV coordinates of Layer 1.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer1ScaleU: ScalarValue
  /**
   * Vertical scale for the UV coordinates of Layer 1.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer1ScaleV: ScalarValue
  /**
   * Horiztonal scroll speed for Layer 2.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer2SpeedU: ScalarValue
  /**
   * Vertical scroll speed for Layer 2.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer2SpeedV: ScalarValue
  /**
   * Horizontal offset for the UV coordinates of Layer 2.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  layer2OffsetU: ScalarValue
  /**
   * Vertical offset for the UV coordinates of Layer 2.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  layer2OffsetV: ScalarValue
  /**
   * Horizontal scale for the UV coordinates of Layer 2.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer2ScaleU: ScalarValue
  /**
   * Vertical scale for the UV coordinates of Layer 2.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer2ScaleV: ScalarValue
  /**
   * Horiztonal scroll speed for Layer 3.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer3SpeedU: ScalarValue
  /**
   * Vertical scroll speed for Layer 3.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer3SpeedV: ScalarValue
  /**
   * Horizontal offset for the UV coordinates of Layer 3.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  layer3OffsetU: ScalarValue
  /**
   * Vertical offset for the UV coordinates of Layer 3.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  layer3OffsetV: ScalarValue
  /**
   * Horizontal scale for the UV coordinates of Layer 3.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer3ScaleU: ScalarValue
  /**
   * Vertical scale for the UV coordinates of Layer 3.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  layer3ScaleV: ScalarValue
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * This threshold creates a hard cut-off between visible and not visible, which is unlike the {@link alphaFadeThreshold}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaThreshold: ScalarValue
  /**
   * Controls the orientation mode for the particles. See {@link OrientationMode} for more information.
   * 
   * **Default**: {@link OrientationMode.CameraPlane}
   */
  orientation: OrientationMode
  /**
   * Layer 1 texture ID.
   * 
   * **Default**: `1`
   */
  layer1: number
  /**
   * Layer 2 texture ID.
   * 
   * **Default**: `1`
   */
  layer2: number
  /**
   * Layer 3 texture ID.
   * 
   * **Default**: `1`
   */
  layer3: number
  /**
   * If enabled, the particle width-related properties and fields will control both the width and height of the particles, and the height counterparts will be ignored.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link width}
   * - {@link height}
   */
  uniformScale: boolean
  /**
   * When `true`, scaling is applied before rotation for the particle, which allows non-square particles to maintain their shape when rotated. When `false`, scaling is applied after rotation, which allows particles to be skewed, for example a square rotated 45 degrees and then made thinner will turn into a diamond shape.
   * 
   * **Default**: `true`
   */
  scaleBeforeRotation: boolean
  /**
   * To split the texture into multiple animation frames, this value must be set to the number of columns in the texture. It should equal `textureWidth / frameWidth`.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link totalFrames}
   */
  columns: number
  /**
   * To split the texture into multiple animation frames, this value must be set to the total number of frames in the texture.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link columns}
   */
  totalFrames: number
  /**
   * If enabled, the texture animation will use linear interpolation to mix frames when the frame index is not a whole number. For example, if the frame index is 0.5, enabling this will cause the average of the first two frames to be shown instead of just the first frame.
   * 
   * If disabled, the frame index will be truncated to get a whole number.
   * 
   * **Default**: `true`
   * 
   * See also:
   * - {@link frameIndex}
   * - {@link frameIndexOffset}
   */
  interpolateFrames: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_ds3_f1_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_ds3_f1_11: number
  /**
   * Controls how the particles should render when behind something else. If disabled, the particles will simply be drawn behind anything they are behind in the world. If enabled, they will instead display in front of the object if they are close enough, and will fade out with distance from the object's surface that is blocking the view of the particle.
   * 
   * **Default**: `true`
   */
  depthBlend: boolean
  /**
   * Controls the shape of the particles. If disabled, the particles will be rectangular. If enabled, they will be octagonal.
   * 
   * **Default**: `false`
   */
  octagonal: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Controls whether or not the particles have an additional bloom effect controlled by {@link bloomColor}.
   * 
   * When enabled, this also allows bloom from other particles to be seen through this particle.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * | Value | Behavior |
   * |-|-|
   * | 0 | All layers may have colors, and the layer textures are all multiplied when blending. The opacity is based only on the alpha of the {@link layer1} texture. |
   * | 1 | Removes all color from layers {@link layer2 2} and {@link layer3 3}, and makes the brightness of the pixels in the texture of those layers affect the opacity. |
   * | 2 | Removes all color from {@link layer2 layer 2} only, and makes the brightness of the pixels in the texture of that layer affect the opacity. |
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer, however it seems to affect the blending of the layers and color multipliers in some way.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown float.
   * 
   * This seems to be some sort of distance threshold. When the camera is within this distance, some things will look different in some ways. For example, when within the distance and the {@link blendMode blend mode} is set to {@link BlendMode.Subtract}, the opacity doesn't work the way it normally does. Other effects have been found as well, but what exactly this threshold is for is unknown.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_29: number
  /**
   * Controls how dark shaded parts of the particle are.
   * 
   * **Default**: `0`
   */
  shadowDarkness: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_31: number
  /**
   * Unknown boolean.
   * 
   * When enabled, it seems to stop {@link unk_ds3_f2_29} from doing whatever it is doing, and it can also cause some ugly "outline" effects on things seen through particles, but it also fixes an issue where some other particles can be seen through this particle.
   * 
   * **Default**: `false`
   */
  unk_sdt_f2_32: boolean
  /**
   * Specular texture ID.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link lighting}
   * - {@link glossiness}
   */
  specular: number
  /**
   * Controls how sharp the specular highlights are.
   * 
   * **Default**: `0.25`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   */
  glossiness: number
  /**
   * Controls how the particles are lit. See {@link LightingMode} for more information.
   * 
   * **Default**: `-1`
   */
  lighting: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_sdt_f2_38: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_sdt_f2_39: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_40: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_41: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_42: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_43: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_er_f2_44: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_45: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_46: number
  constructor(props: Partial<Props<MultiTextureBillboardEx>> = {}) {
    super(ActionType.MultiTextureBillboardEx)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.Model Action 605 - Model}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Particle with a 3D model.
 * 
 * Some models don't work properly with this action for some reason. For example, the Carian greatsword model in Elden Ring (88300), gets horribly stretched and distorted when used with this action. If you find a model like this that you want to use, try using the {@link ActionType.RichModel RichModel action} instead.
 */
class Model extends DataAction {
  declare readonly type: ActionType.Model
  /**
   * Model ID.
   * 
   * **Default**: `80201`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  model: ScalarValue
  /**
   * The width of the particle.
   * 
   * If {@link uniformScale} is enabled, this also controls the height and depth.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationX}
   * - {@link sizeY}
   * - {@link sizeZ}
   */
  sizeX: ScalarValue
  /**
   * The height of the particle.
   * 
   * If {@link uniformScale} is enabled, {@link sizeX} also controls the height, and this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationY}
   * - {@link sizeX}
   * - {@link sizeZ}
   */
  sizeY: ScalarValue
  /**
   * The depth of the particle.
   * 
   * If {@link uniformScale} is enabled, {@link sizeX} also controls the depth, and this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationZ}
   * - {@link sizeX}
   * - {@link sizeY}
   */
  sizeZ: ScalarValue
  /**
   * Rotation around the X-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedX}
   * - {@link angularSpeedMultiplierX}
   */
  rotationX: ScalarValue
  /**
   * Rotation around the Y-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedY}
   * - {@link angularSpeedMultiplierY}
   */
  rotationY: ScalarValue
  /**
   * Rotation around the Z-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedZ}
   * - {@link angularSpeedMultiplierZ}
   */
  rotationZ: ScalarValue
  /**
   * Angular speed around the X-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationX}
   * - {@link angularSpeedMultiplierX}
   */
  angularSpeedX: ScalarValue
  /**
   * Multiplier for {@link angularSpeedX}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationX}
   */
  angularSpeedMultiplierX: ScalarValue
  /**
   * Angular speed around the Y-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationY}
   * - {@link angularSpeedMultiplierY}
   */
  angularSpeedY: ScalarValue
  /**
   * Multiplier for {@link angularSpeedY}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationY}
   */
  angularSpeedMultiplierY: ScalarValue
  /**
   * Angular speed around the Z-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationZ}
   * - {@link angularSpeedMultiplierZ}
   */
  angularSpeedZ: ScalarValue
  /**
   * Multiplier for {@link angularSpeedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationZ}
   */
  angularSpeedMultiplierZ: ScalarValue
  /**
   * Blend mode.
   * 
   * Note that the materials used by the model may affect how the different blend modes work. Don't expect the blend modes to always work exactly like they do in other types of instances.
   * 
   * **Default**: {@link BlendMode.Normal}
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  blendMode: BlendMode | ScalarProperty
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link color3}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color2}
   * - {@link color3}
   */
  color1: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. There is no equivalent property with unrestricted values based on the emission time of the particle, but {@link color3} is still multiplicative with this and can be used to scale the values indirectly.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color3}
   */
  color2: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this are unrestricted and can go above 1. If you want values to be clamped to the 0-1 range, see {@link color1}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   */
  color3: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_15: ScalarValue
  /**
   * The index of the frame to show from the texture atlas. Can be animated using a {@link PropertyFunction.Linear linear property} or similar.
   * 
   * Seemingly identical to {@link frameIndexOffset}? The sum of these two properties is the actual frame index that gets used.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  frameIndex: ScalarValue
  /**
   * Seemingly identical to {@link frameIndex}? The sum of these two properties is the actual frame index that gets used.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  frameIndexOffset: ScalarValue
  /**
   * Horizontal offset for the UV coordinates of the model.
   * 
   * If the texture is an animation sheet that is split up into multiple frames using {@link columns} and/or {@link totalFrames}, this property has no effect.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link speedU}
   * - {@link offsetV}
   */
  offsetU: ScalarValue
  /**
   * Vertical offset for the UV coordinates of the model.
   * 
   * If the texture is an animation sheet that is split up into multiple frames using {@link columns} and/or {@link totalFrames}, this property has no effect.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  offsetV: ScalarValue
  /**
   * Horiztonal scroll speed for the model's texture.
   * 
   * If the texture is an animation sheet that is split up into multiple frames using {@link columns} and/or {@link totalFrames}, this property has no effect.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link speedMultiplierU}
   * - {@link offsetU}
   */
  speedU: ScalarValue
  /**
   * Multiplier for {@link speedU}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speedMultiplierU: ScalarValue
  /**
   * Vertical scroll speed for the model's texture.
   * 
   * If the texture is an animation sheet that is split up into multiple frames using {@link columns} and/or {@link totalFrames}, this property has no effect.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link speedMultiplierV}
   * - {@link offsetV}
   */
  speedV: ScalarValue
  /**
   * Multiplier for {@link speedV}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speedMultiplierV: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_24: ScalarValue
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_6: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_7: ScalarValue
  /**
   * Model orientation mode. See {@link ModelOrientationMode} for more information.
   * 
   * **Default**: {@link ModelOrientationMode.ParticleDirection}
   */
  orientation: ModelOrientationMode
  /**
   * Each particle will pick a random number between this value and 1, and the width of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly thinner, down to half width. Setting it to 2 will make them randomly wider, up to double width.
   * 
   * If {@link uniformScale} is enabled, this also affects the height.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationY}
   * - {@link scaleVariationZ}
   */
  scaleVariationX: number
  /**
   * Each particle will pick a random number between this value and 1, and the height of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly shorter, down to half height. Setting it to 2 will make them randomly taller, up to double height.
   * 
   * If {@link uniformScale} is enabled, {@link scaleVariationX} also affects the height, and this field is ignored.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationX}
   * - {@link scaleVariationZ}
   */
  scaleVariationY: number
  /**
   * Each particle will pick a random number between this value and 1, and the depth of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly shallower, down to half depth. Setting it to 2 will make them randomly deeper, up to double depth. 
   * 
   * If {@link uniformScale} is enabled, {@link scaleVariationX} also affects the depth, and this field is ignored.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationX}
   * - {@link scaleVariationY}
   */
  scaleVariationZ: number
  /**
   * If enabled, the particle X scale-related properties and fields will control the scale in all axes, and the Y and Z counterparts will be ignored.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link sizeX}
   * - {@link sizeY}
   * - {@link sizeZ}
   * - {@link scaleVariationX}
   * - {@link scaleVariationY}
   * - {@link scaleVariationZ}
   */
  uniformScale: boolean
  /**
   * To split the texture into multiple animation frames, this value must be set to the number of columns in the texture. It should equal `textureWidth / frameWidth`.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link totalFrames}
   */
  columns: number
  /**
   * To split the texture into multiple animation frames, this value must be set to the total number of frames in the texture.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link columns}
   */
  totalFrames: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_ds3_f1_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_ds3_f1_10: number
  /**
   * Unknown boolean.
   * 
   * **Default**: `true`
   */
  unk_ds3_f1_11: boolean
  /**
   * Unknown boolean.
   * 
   * **Default**: `true`
   */
  unk_ds3_f1_12: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_13: number
  /**
   * Anibnd ID.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link animation}
   * - {@link loopAnimation}
   * - {@link animationSpeed}
   */
  anibnd: number
  /**
   * Controls which animation in the {@link anibnd} to play.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link anibnd}
   * - {@link loopAnimation}
   * - {@link animationSpeed}
   */
  animation: number
  /**
   * If disabled, the {@link animation} will only play once and then freeze on the last frame. If enabled, the animation will loop.
   * 
   * **Default**: `true`
   * 
   * See also:
   * - {@link anibnd}
   * - {@link animation}
   * - {@link animationSpeed}
   */
  loopAnimation: boolean
  /**
   * Controls the speed at which the {@link animation} plays.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link anibnd}
   * - {@link animation}
   * - {@link loopAnimation}
   */
  animationSpeed: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_4: number
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_26: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_29: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_30: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_31: number
  /**
   * Unknown boolean.
   * 
   * When enabled, it can cause some ugly "outline" effects on things seen through particles.
   * 
   * **Default**: `false`
   */
  unk_sdt_f2_32: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_33: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_38: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  constructor(props: Partial<Props<Model>> = {}) {
    super(ActionType.Model)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.LegacyTracer Action 606 - LegacyTracer}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Creates a trail behind moving effects.
 * 
 * This is an older version of {@link Tracer} with fewer features.
 */
class LegacyTracer extends DataAction {
  declare readonly type: ActionType.LegacyTracer
  /**
   * Texture ID.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  texture: ScalarValue
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  blendMode: BlendMode | ScalarProperty
  /**
   * The width of the trail.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  width: ScalarValue
  /**
   * Multiplier for {@link width}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   */
  widthMultiplier: ScalarValue
  /**
   * Percentage along the trail from the start of the trail where the trail's opacity will start fading out towards the start. The trail will have 0 opacity at the start, and it will linearly increase towards full opacity at the point represented by this percentage.
   * 
   * The percentage is of the way from the start of the trail to the end of it, so if the trail gets longer or shorter, this point will move with it.
   * 
   * Values greater than 100 will make the trail never reach full opacity. For example, a value of 200 will make the trail fade from 0 opacity at the start to 50% (100% / 200%) at the end of the trail.
   * 
   * If this value and {@link endFadeEndpoint} sum to a value greater than 100, the trail will be "split" at the point controlled by this value and each part will fade separately based on the repsective value. For example, if this is set to 50 and {@link endFadeEndpoint} is 1000, the first half of the trail will fade normally from 0 opacity at the start to full opacity at the mid point, but the other half will fade from 5% opacity ((100% - 50%) / 1000%) at the mid point to 0 at the end. Where the two parts meet, the opacity will fade from one to the other across a single segment of the trail.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  startFadeEndpoint: ScalarValue
  /**
   * Percentage along the trail from the end of the trail where the trail's opacity will start fading out towards the end. The trail will have full opacity at the point represented by this percentage, and it will linearly decrease towards 0 opacity at the end.
   * 
   * The percentage is of the way from the end of the trail to the start of it, so if the trail gets longer or shorter, this point will move with it.
   * 
   * Values greater than 100 will make the trail never reach full opacity. For example, a value of 200 will make the trail fade from 0 opacity at the end to 50% (100% / 200%) at the start of the trail.
   * 
   * If this value and {@link startFadeEndpoint} sum to a value greater than 100, the trail will be "split" at the point controlled by {@link startFadeEndpoint} and each part will fade separately based on the repsective value. For example, if {@link startFadeEndpoint} is set to 50 and this is 1000, the first half of the trail will fade normally from 0 opacity at the start to full opacity at the mid point, but the other half will fade from 5% opacity ((100% - 50%) / 1000%) at the mid point to 0 at the end. Where the two parts meet, the opacity will fade from one to the other across a single segment of the trail.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  endFadeEndpoint: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link color3}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color2}
   * - {@link color3}
   */
  color1: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. There is no equivalent property with unrestricted values based on the emission time of the particle, but {@link color3} is still multiplicative with this and can be used to scale the values indirectly.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color3}
   */
  color2: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this are unrestricted and can go above 1. If you want values to be clamped to the 0-1 range, see {@link color1}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   */
  color3: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * Values above this threshold will be stretched to fill the alpha range, so values near the threshold will be less visible, creating a smooth transition between the parts that have been hidden by the threshold and the ones that are still visible.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  alphaFadeThreshold: ScalarValue
  /**
   * The index of the frame to show from the texture atlas. Can be animated using a {@link PropertyFunction.Linear linear property} or similar.
   * 
   * Seemingly identical to {@link frameIndexOffset}? The sum of these two properties is the actual frame index that gets used.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  frameIndex: ScalarValue
  /**
   * Seemingly identical to {@link frameIndex}? The sum of these two properties is the actual frame index that gets used.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  frameIndexOffset: ScalarValue
  /**
   * Controls how much of the texture's width is used per segment. If {@link attachedUV} is enabled, this instead controls how much of the texture's width to use for the entire trail.
   * 
   * **Default**: `0.1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  textureFraction: ScalarValue
  /**
   * Controls how fast the UV coordinates should move horizontally.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speedU: ScalarValue
  /**
   * Controls how much the UV coordinates should be randomly offset by per segment.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  varianceV: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `-1`
   */
  unk_ds3_p1_13: ScalarValue
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Controls the intensity of the distortion effect. At 0, there is no distortion at all.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link normalMap}
   */
  distortionIntensity: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * This threshold creates a hard cut-off between visible and not visible, which is unlike the {@link alphaFadeThreshold}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaThreshold: ScalarValue
  /**
   * Tracer orientation mode. See {@link TracerOrientationMode} for more information.
   * 
   * **Default**: {@link TracerOrientationMode.LocalZ}
   */
  orientation: TracerOrientationMode
  /**
   * Normal map texture ID.
   * 
   * This is used to control the distortion effect of the trail.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link distortionIntensity}
   */
  normalMap: number
  /**
   * The trail is made up of multiple quads, or *segments*. This controls how many seconds to wait between new segments being created. Lower values produce a smoother trail.
   * 
   * **Default**: `0`
   */
  segmentInterval: number
  /**
   * The trail is made up of multiple quads, or *segments*. This controls how long each segment should last in seconds.
   * 
   * **Default**: `1`
   */
  segmentDuration: number
  /**
   * The trail is made up of multiple quads, or *segments*. This controls how many segments may exist at the same time.
   * 
   * **Default**: `100`
   */
  concurrentSegments: number
  /**
   * The trail is made up of multiple quads, or *segments*. This controls how many times each completed segment should be subdivided. Higher values makes the trail look smoother.
   * 
   * A "completed" segment is any segment that is not the leading one. The leading segment has one side attached to the end of the previous segment and the other attached to the tracer source, and is always a simple quad.
   * 
   * **Default**: `0`
   */
  segmentSubdivision: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_8: number
  /**
   * When the particle is meant to terminate, the trail will linger for this many seconds and its opacity will fade to 0 in that time.
   * 
   * **Default**: `0`
   */
  fadeOutTime: number
  /**
   * To split the texture into multiple animation frames, this value must be set to the number of columns in the texture. It should equal `textureWidth / frameWidth`.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link totalFrames}
   */
  columns: number
  /**
   * To split the texture into multiple animation frames, this value must be set to the total number of frames in the texture.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link columns}
   */
  totalFrames: number
  /**
   * Controls whether or not the UV of the trail should be attached to the node or not. If it is attached, the texture will slide along the segments to follow the source wherever it moves, as if it was a flag attached to a pole. If it is not attached, the texture will stay where it was when the segment was created, like a skid mark on a road where the road is the segments and the mark is the texture, it wouldn't follow the car/node that made it.
   * 
   * **Default**: `true`
   */
  attachedUV: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_13: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer. Possibly boolean?
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Controls whether or not the particles have an additional bloom effect controlled by {@link bloomColor}.
   * 
   * When enabled, this also allows bloom from other particles to be seen through this particle.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown float.
   * 
   * This seems to be some sort of distance threshold. When the camera is within this distance, some things will look different in some ways. For example, when within the distance and the {@link blendMode blend mode} is set to {@link BlendMode.Subtract}, the opacity doesn't work the way it normally does. Other effects have been found as well, but what exactly this threshold is for is unknown.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_29: number
  /**
   * Controls how dark shaded parts of the trail are.
   * 
   * **Default**: `0`
   */
  shadowDarkness: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_31: number
  /**
   * Unknown boolean.
   * 
   * When enabled, it seems to stop {@link unk_ds3_f2_29} from doing whatever it is doing, and it can also cause some ugly "outline" effects on things seen through particles, but it also fixes an issue where some other particles can be seen through this particle.
   * 
   * **Default**: `false`
   */
  unk_sdt_f2_32: boolean
  /**
   * Specular texture ID.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link lighting}
   * - {@link glossiness}
   * - {@link specularity}
   */
  specular: number
  /**
   * Controls how sharp the specular highlights are.
   * 
   * **Default**: `0.25`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   * - {@link specularity}
   */
  glossiness: number
  /**
   * Controls how the trail is lit. See {@link LightingMode} for more information.
   * 
   * **Default**: `-1`
   */
  lighting: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Controls how bright the specular highlights are.
   * 
   * **Default**: `0.5`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   * - {@link glossiness}
   */
  specularity: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_39: number
  constructor(props: Partial<Props<LegacyTracer>> = {}) {
    super(ActionType.LegacyTracer)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.Distortion Action 607 - Distortion}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * A particle that distorts anything seen through it.
 * 
 * Note: This particle is not visible if the "Effects" setting is set to "Low".
 */
class Distortion extends DataAction {
  declare readonly type: ActionType.Distortion
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  blendMode: BlendMode | ScalarProperty
  /**
   * X position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  offsetX: ScalarValue
  /**
   * Y position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  offsetY: ScalarValue
  /**
   * Z position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  offsetZ: ScalarValue
  /**
   * The width of the particle.
   * 
   * If {@link uniformScale} is enabled, this also controls the height and depth.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationX}
   * - {@link sizeY}
   * - {@link sizeZ}
   */
  sizeX: ScalarValue
  /**
   * The height of the particle.
   * 
   * If {@link uniformScale} is enabled, {@link sizeX} also controls the height, and this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationY}
   * - {@link sizeX}
   * - {@link sizeZ}
   */
  sizeY: ScalarValue
  /**
   * The depth of the particle.
   * 
   * If {@link uniformScale} is enabled, {@link sizeX} also controls the depth, and this property is ignored.
   * 
   * If the distortion {@link shape} is set to {@link DistortionShape.Rectangle Rectangle}, this property won't have any effect since the rectangle is 2-dimensional.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationZ}
   * - {@link sizeX}
   * - {@link sizeY}
   */
  sizeZ: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  color: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p1_7: Vector4Value
  /**
   * Controls the intensity of the distortion effect. At 0, there is no distortion at all.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  intensity: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_9: ScalarValue
  /**
   * Controls the speed of the stirring effect in degrees per second. Requires {@link mode} to be set to {@link DistortionMode.Stir}.
   * 
   * **Default**: `60`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  stirSpeed: ScalarValue
  /**
   * The distortion effect is only applied to an ellipse inside the particle. This property controls how large this ellipse is. At 1, it inscribes the particle's rectangle. At values greater than 1, it is the same size as 1, but there might be strange artifacts around the edges of the distortion.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  radius: ScalarValue
  /**
   * Horizontal offset for the {@link normalMap normal map}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  normalMapOffsetU: ScalarValue
  /**
   * Vertical offset for the {@link normalMap normal map}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  normalMapOffsetV: ScalarValue
  /**
   * Horizontal offset speed for the {@link normalMap normal map}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  normalMapSpeedU: ScalarValue
  /**
   * Vertical offset speed for the {@link normalMap normal map}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  normalMapSpeedV: ScalarValue
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * This threshold creates a hard cut-off between visible and not visible, which is unlike the alpha *fade* threshold properties in some similar actions.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaThreshold: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_er_p2_7: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_er_p2_8: ScalarValue
  /**
   * Controls what type of distortion to apply. See {@link DistortionMode} for more details.
   * 
   * **Default**: {@link DistortionMode.NormalMap}
   */
  mode: DistortionMode
  /**
   * Controls the shape of the particle. See {@link DistortionShape} for more information.
   * 
   * **Default**: {@link DistortionShape.Rectangle}
   */
  shape: DistortionShape
  /**
   * Controls the orientation mode for the particles. See {@link OrientationMode} for more information.
   * 
   * **Default**: {@link OrientationMode.CameraPlane}
   */
  orientation: OrientationMode
  /**
   * Texture ID.
   * 
   * This texture seems to completely hide the distortion effect. It's probably best to just leave it at 0 unless you are trying to figure out how to use it properly.
   * 
   * **Default**: `0`
   */
  texture: number
  /**
   * Normal map texture ID.
   * 
   * Only used if the distortion {@link mode} is set to something that uses it.
   * 
   * **Default**: `0`
   */
  normalMap: number
  /**
   * Mask texture ID. This texture is used to control the color and opacity of the particle.
   * 
   * **Default**: `0`
   */
  mask: number
  /**
   * Each particle will pick a random number between this value and 1, and the width of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly thinner, down to half width. Setting it to 2 will make them randomly wider, up to double width.
   * 
   * If {@link uniformScale} is enabled, this also affects the height.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationY}
   * - {@link scaleVariationZ}
   */
  scaleVariationX: number
  /**
   * Each particle will pick a random number between this value and 1, and the height of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly shorter, down to half height. Setting it to 2 will make them randomly taller, up to double height.
   * 
   * If {@link uniformScale} is enabled, {@link scaleVariationX} also affects the height, and this field is ignored.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationX}
   * - {@link scaleVariationZ}
   */
  scaleVariationY: number
  /**
   * Each particle will pick a random number between this value and 1, and the depth of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly shallower, down to half depth. Setting it to 2 will make them randomly deeper, up to double depth. 
   * 
   * If {@link uniformScale} is enabled, {@link scaleVariationX} also affects the depth, and this field is ignored.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationX}
   * - {@link scaleVariationY}
   */
  scaleVariationZ: number
  /**
   * If enabled, the particle X scale-related properties and fields will control the scale in all axes, and the Y and Z counterparts will be ignored.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link sizeX}
   * - {@link sizeY}
   * - {@link sizeZ}
   * - {@link scaleVariationX}
   * - {@link scaleVariationY}
   * - {@link scaleVariationZ}
   */
  uniformScale: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_ds3_f1_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_13: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_4: number
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   */
  bloomColor: Vector4
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_29: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_30: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_31: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_33: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_sdt_f2_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Unknown float.
   * 
   * This seems to be something distance or depth-related. It's using the same length units as everything else (meters), and seems to be some sort of threshold or maybe offset for something. When the camera is within this distance from the node, the distortion will also affect other particles seen through it.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_38: number
  constructor(props: Partial<Props<Distortion>> = {}) {
    super(ActionType.Distortion)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.RadialBlur Action 608 - RadialBlur}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * A particle that applies a radial blur to anything seen through it.
 * 
 * Note: This particle is not visible if the "Effects" setting is set to "Low".
 */
class RadialBlur extends DataAction {
  declare readonly type: ActionType.RadialBlur
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  blendMode: BlendMode | ScalarProperty
  /**
   * Mask texture ID. This texture is used to control the opacity of the particle.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  mask: ScalarValue
  /**
   * X position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link offsetY}
   * - {@link offsetZ}
   */
  offsetX: ScalarValue
  /**
   * Y position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link offsetX}
   * - {@link offsetZ}
   */
  offsetY: ScalarValue
  /**
   * Z position offset.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link offsetX}
   * - {@link offsetY}
   */
  offsetZ: ScalarValue
  /**
   * The width of the particle.
   * 
   * If {@link uniformScale} is enabled, this also controls the height.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link height}
   */
  width: ScalarValue
  /**
   * The height of the particle.
   * 
   * If {@link uniformScale} is enabled, {@link width} also controls the height, and this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link width}
   */
  height: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. There are no unrestricted color properties in this action, but {@link rgbMultiplier} and {@link alphaMultiplier} can be used to scale the colors.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  color: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p1_6: Vector4Value
  /**
   * Controls the amount of blur to apply. Values greater than 1 may appear glitchy.
   * 
   * **Default**: `0.5`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  blurRadius: ScalarValue
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * This threshold creates a hard cut-off between visible and not visible, which is unlike the alpha *fade* threshold properties in some similar actions.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaThreshold: ScalarValue
  /**
   * If enabled, the particle width-related properties and fields will control both the width and height of the particles, and the height counterparts will be ignored.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link width}
   * - {@link height}
   */
  uniformScale: boolean
  /**
   * Controls how many times to apply the effect. Higher values can have a significant impact on performance.
   * 
   * **Default**: `1`
   */
  iterations: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_4: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_4: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_4: number
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   */
  bloomColor: Vector4
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown float.
   * 
   * **Default**: `0.5`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_29: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_30: number
  constructor(props: Partial<Props<RadialBlur>> = {}) {
    super(ActionType.RadialBlur)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.PointLight Action 609 - PointLight}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Point light source.
 */
class PointLight extends DataAction {
  declare readonly type: ActionType.PointLight
  /**
   * Controls the diffuse color of the light.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * If {@link separateSpecular} is disabled, this also controls the specular color of the light.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link specularColor}
   */
  diffuseColor: Vector4Value
  /**
   * Controls the specular color of the light.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * If {@link separateSpecular} is disabled, this property is ignored and {@link diffuseColor} controls both the diffuse as well as the specular color.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  specularColor: Vector4Value
  /**
   * The maximum distance that the light may travel from the source, and the radius of the sphere in which other effects caused by the light source (for example {@link volumeDensity} and its related fields) may act.
   * 
   * **Default**: `10`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  radius: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_3: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_4: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_5: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_6: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `10`
   */
  unk_ds3_p1_7: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `10`
   */
  unk_ds3_p1_8: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `10`
   */
  unk_ds3_p1_9: ScalarValue
  /**
   * Affects the falloff of the light in some way, and how the normal of surfaces affect the intensity of the light.
   * - At 0 or negative values, this completely disables the light.
   * - At 1, the light behaves normally, like you would expect it to.
   * - At values between 0 and 1, it seemingly makes the falloff of the light over distance stronger, so the light will sooner fade to nothing.
   * - At values greater than 1, it will make the falloff weaker until near the {@link radius maximum distance}, and then it will very quickly fade to nothing. It also makes the normal of the surfaces hit by the light matter less. At very high values, anything within the radius basically becomes full bright.
   * 
   * **Default**: `1`
   */
  unk_ds3_p2_0: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p2_1: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_sdt_p2_2: ScalarValue
  /**
   * A scalar multiplier for the {@link diffuseColor diffuse color}. Good for easily adjusting the brightness of the light without changing the color.
   * 
   * If {@link separateSpecular} is disabled, this also affects the specular color of the light.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  diffuseMultiplier: ScalarValue
  /**
   * A scalar multiplier for the {@link specularColor specular color}.
   * 
   * If {@link separateSpecular} is disabled, this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  specularMultiplier: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Toggles the jitter and flicker animations for the light.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link jitterAcceleration}
   * - {@link jitterX}
   * - {@link jitterY}
   * - {@link jitterZ}
   * - {@link flickerIntervalMin}
   * - {@link flickerIntervalMax}
   * - {@link flickerBrightness}
   */
  jitterAndFlicker: boolean
  /**
   * Controls the acceleration of the jittering.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link jitterX}
   * - {@link jitterY}
   * - {@link jitterZ}
   */
  jitterAcceleration: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Controls how much the light should move around randomly on the X-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link jitterAcceleration}
   * - {@link jitterY}
   * - {@link jitterZ}
   */
  jitterX: number
  /**
   * Controls how much the light should move around randomly on the Y-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link jitterAcceleration}
   * - {@link jitterX}
   * - {@link jitterZ}
   */
  jitterY: number
  /**
   * Controls how much the light should move around randomly on the Z-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link jitterAcceleration}
   * - {@link jitterX}
   * - {@link jitterY}
   */
  jitterZ: number
  /**
   * Controls the minimum interval for flickering.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link flickerIntervalMax}
   * - {@link flickerBrightness}
   */
  flickerIntervalMin: number
  /**
   * Controls the maximum interval for flickering.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link flickerIntervalMin}
   * - {@link flickerBrightness}
   */
  flickerIntervalMax: number
  /**
   * Brightness multiplier for the light when it flickers.
   * 
   * **Default**: `0.5`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link flickerIntervalMin}
   * - {@link flickerIntervalMax}
   */
  flickerBrightness: number
  /**
   * Controls if the light should have shadows or not.
   * 
   * Note: Map objects also have a setting for casting shadows, and both must be enabled for an object to cast shadows from the light source.
   * 
   * **Default**: `false`
   */
  shadows: boolean
  /**
   * When enabled, this allows other properties and fields of the action to control the specular color independently of the diffuse color. When disabled, the diffuse counterpart of the properties or fields will affect both the diffuse and specular color.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link diffuseColor}
   * - {@link specularColor}
   * - {@link diffuseMultiplier}
   * - {@link specularMultiplier}
   */
  separateSpecular: boolean
  /**
   * The number of seconds the light takes to fade to nothing after being destroyed.
   * 
   * Due to how the field this represents works, the time will be rounded to the nearest multiple of 1/30s.
   * 
   * **Default**: `0`
   */
  fadeOutTime: number
  /**
   * Controls how dark shadows from this light source are. At 0, the shadows will be entirely invisible.
   * 
   * **Default**: `1`
   */
  shadowDarkness: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `2`
   */
  unk_ds3_f2_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_17: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_18: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_19: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `100`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Controls the maximum distance for the light source to be active. If the camera is farther away from the light source than this distance, it will stop emitting light.
   * 
   * Setting this to `0` will disable the distance limit.
   * 
   * **Default**: `0`
   */
  maxViewDistance: number
  /**
   * Controls the density of some sort of fake fog in the volume hit by the light. The fog does not affect the actual light produced by the source and is not affected by shadows.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link phaseFunction}
   * - {@link asymmetryParam}
   */
  volumeDensity: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_25: number
  /**
   * Controls whether or not {@link asymmetryParam} affects the fake fog from {@link volumeDensity}.
   * 
   * **Default**: `true`
   */
  phaseFunction: boolean
  /**
   * Controls how the fake fog from {@link volumeDensity} scatters the light. This value is ignored if {@link phaseFunction} is disabled, and the fog will scatter the light equally in all directions.
   * 
   * - At 0, the light is scattered equally in every direction.
   * - As the value approaches 1, the light is scattered more and more forward, in the same direction as the light was already traveling. This means that the fake fog will be less visible from the side or behind, and more visible from in front of the light.
   * - At 1, the fog will not scatter the light at all, so it will be entirely invisible.
   * - Values above 1 produce unnatural-looking effects where the light darkens the fog instead.
   * 
   * **Default**: `0.75`
   */
  asymmetryParam: number
  /**
   * When not in a dark enough area, the brightness of the light will be multiplied by 0.1^α, where α is this exponent value. The light will have normal brightness when the area it's in is sufficiently dark.
   * 
   * **Default**: `0`
   */
  adaptationExponent: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f2_29: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_er_f2_30: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f2_31: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f2_33: number
  /**
   * Unknown. Only used in Dark Souls 3.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_12: number
  constructor(props: Partial<Props<PointLight>> = {}) {
    super(ActionType.PointLight)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.SimulateTermination Action 700 - SimulateTermination}
 * **Slot**: {@link ActionSlots.TerminationAction Termination}
 * 
 * Allows the effect to play out once it terminates. Particle emitters will stop emitting new particles, but particles with a finite duration that have already been emitted will stay around for as long as their duration allows them to.
 * 
 * Note: An effect terminates when it reaches {@link State} -1.
 */
class SimulateTermination extends DataAction {
  declare readonly type: ActionType.SimulateTermination
  
  constructor() {
    super(ActionType.SimulateTermination)
  }
}

/**
 * ### {@link ActionType.FadeTermination Action 701 - FadeTermination}
 * **Slot**: {@link ActionSlots.TerminationAction Termination}
 * 
 * Allows the effect to continue playing normally after it terminates, but its opacity will gradually fade out over a given duration.
 * 
 * Note: An effect terminates when it reaches {@link State} -1.
 */
class FadeTermination extends DataAction {
  declare readonly type: ActionType.FadeTermination
  /**
   * The duration of the fade out in seconds.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  duration: ScalarValue
  /**
   * @param duration The duration of the fade out in seconds.
   *
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  constructor(duration: ScalarValue = 1) {
    super(ActionType.FadeTermination)
    this.assign({ duration })
  }
}

/**
 * ### {@link ActionType.InstantTermination Action 702 - InstantTermination}
 * **Slot**: {@link ActionSlots.TerminationAction Termination}
 * 
 * Makes the effect instantly disappear when it terminates.
 * 
 * Note: An effect terminates when it reaches {@link State} -1.
 */
class InstantTermination extends DataAction {
  declare readonly type: ActionType.InstantTermination
  
  constructor() {
    super(ActionType.InstantTermination)
  }
}

/**
 * ### {@link ActionType.NodeForceSpeed Action 731 - NodeForceSpeed}
 * **Slot**: {@link ActionSlots.NodeForceMovementAction NodeForceMovement}
 * 
 * Controls how the node is affected by forces. For more information about forces that can affect nodes and particles, see:
 * - {@link ActionType.CancelForce CancelForce}
 * - {@link ActionType.WindForce WindForce}
 * - {@link ActionType.GravityForce GravityForce}
 * - {@link ActionType.ForceCollision ForceCollision}
 * - {@link ActionType.TurbulenceForce TurbulenceForce}
 */
class NodeForceSpeed extends DataAction {
  declare readonly type: ActionType.NodeForceSpeed
  /**
   * The speed in the direction of the force.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  speed: ScalarValue
  /**
   * A multiplier for {@link speed}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  speedMultiplier: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_0: number
  constructor(props: Partial<Props<NodeForceSpeed>> = {}) {
    super(ActionType.NodeForceSpeed)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleForceSpeed Action 732 - ParticleForceSpeed}
 * **Slot**: {@link ActionSlots.ParticleForceMovementAction ParticleForceMovement}
 * 
 * Controls how the particles emitted by the node is affected by forces. For more information about forces that can affect nodes and particles, see:
 * - {@link ActionType.CancelForce CancelForce}
 * - {@link ActionType.WindForce WindForce}
 * - {@link ActionType.GravityForce GravityForce}
 * - {@link ActionType.ForceCollision ForceCollision}
 * - {@link ActionType.TurbulenceForce TurbulenceForce}
 */
class ParticleForceSpeed extends DataAction {
  declare readonly type: ActionType.ParticleForceSpeed
  /**
   * The speed in the direction of the force.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  speed: ScalarValue
  /**
   * A multiplier for {@link speed}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  speedMultiplier: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_0: number
  /**
   * Unknown. 0 and 1 seems to be valid values, while all other values cause the wind to not affect the particles.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_1: number
  constructor(props: Partial<Props<ParticleForceSpeed>> = {}) {
    super(ActionType.ParticleForceSpeed)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.NodeForceAcceleration Action 733 - NodeForceAcceleration}
 * **Slot**: {@link ActionSlots.NodeForceMovementAction NodeForceMovement}
 * 
 * Controls how the node is affected by forces. For more information about forces that can affect nodes and particles, see:
 * - {@link ActionType.CancelForce CancelForce}
 * - {@link ActionType.WindForce WindForce}
 * - {@link ActionType.GravityForce GravityForce}
 * - {@link ActionType.ForceCollision ForceCollision}
 * - {@link ActionType.TurbulenceForce TurbulenceForce}
 */
class NodeForceAcceleration extends DataAction {
  declare readonly type: ActionType.NodeForceAcceleration
  /**
   * The acceleration in the direction of the force.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  acceleration: ScalarValue
  /**
   * A multiplier for {@link acceleration}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationMultiplier: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_0: number
  constructor(props: Partial<Props<NodeForceAcceleration>> = {}) {
    super(ActionType.NodeForceAcceleration)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleForceAcceleration Action 734 - ParticleForceAcceleration}
 * **Slot**: {@link ActionSlots.ParticleForceMovementAction ParticleForceMovement}
 * 
 * Controls how the particles emitted by the node is affected by forces. For more information about forces that can affect nodes and particles, see:
 * - {@link ActionType.CancelForce CancelForce}
 * - {@link ActionType.WindForce WindForce}
 * - {@link ActionType.GravityForce GravityForce}
 * - {@link ActionType.ForceCollision ForceCollision}
 * - {@link ActionType.TurbulenceForce TurbulenceForce}
 */
class ParticleForceAcceleration extends DataAction {
  declare readonly type: ActionType.ParticleForceAcceleration
  /**
   * The acceleration in the direction of the force.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  acceleration: ScalarValue
  /**
   * A multiplier for {@link acceleration}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  accelerationMultiplier: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_0: number
  /**
   * Unknown. 0 and 1 seems to be valid values, while all other values cause the wind to not affect the particles.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_1: number
  constructor(props: Partial<Props<ParticleForceAcceleration>> = {}) {
    super(ActionType.ParticleForceAcceleration)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ParticleForceCollision Action 800 - ParticleForceCollision}
 * **Slot**: {@link ActionSlots.ParticleForceMovementAction ParticleForceMovement}
 * 
 * Enables particles emitted by the node to collide with surfaces, and controls how those collisions affect the movement of the particles.
 * 
 * Note that this works very differently from the collision-related fields in the GPU particle appearance actions. The collision detection for those are entriely based on the distances between the camera and everything in its view, so if a particle is farther away from the camera than an object, the particle will be able to collide with it. The collision detection used in this action is based on the real 3D geometry of the scene, so particles can collide with anything, even while they are out of view.
 * 
 * Also note that this action seems to cause the game to crash very easily. If a particle affected by this action despawns due to its limited duration, the game will crash no matter what.
 */
class ParticleForceCollision extends DataAction {
  declare readonly type: ActionType.ParticleForceCollision
  /**
   * The collision radius of the particles. This controls the maximum distance between the particles and a surface they can collide with for a collision to be detected.
   * 
   * **Default**: `1`
   */
  radius: number
  /**
   * The friction coefficient of the particles. This controls how quickly particles stop while sliding against a surface.
   * | Values | Behavior |
   * |-|-|
   * | <0 | The particles will accelerate as they slide, going faster and faster over time. |
   * | 0 | The particles will not decelerate at all as they slide. They will just keep sliding forever unless something else stops them. |
   * | 0-1 | The particles will decelerate as they slide, causing them to eventually come to a stop. |
   * | ≥1 | The particles will stop immediately if they contact a surface. They may still {@link bounciness bounce}, but they will never slide along the surface. |
   * 
   * **Default**: `0.5`
   */
  friction: number
  /**
   * The coefficient of restitution of the particles, or how "bouncy" they are.
   * | Values | Behavior |
   * |-|-|
   * | ≤0 | Completely inelastic collision. The particles will not bounce if they hit something. They will just stop or slide.
   * | 0-1 | Partially elastic collision. The particles will bounce, but they will lose some energy from the collision, causing them to bounce back at a reduced speed compared to the speed they had before the collision. |
   * | 1 | Perfectly elastic collision. No energy is lost from any collision, causing the particles to bounce off at the same speed they hit the surface. |
   * | >1 | Hyper-elastic collision. The particles will gain energy from every collision, causing them to speed up every time they collide with something. Hitting something at an angle may in some cases still cause them to lose some energy. |
   * 
   * **Default**: `0.5`
   */
  bounciness: number
  constructor(props: Partial<Props<ParticleForceCollision>> = {}) {
    super(ActionType.ParticleForceCollision)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.GPUStandardParticle Action 10000 - GPUStandardParticle}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * An entire particle system in a single action. This emits GPU particles, which means thousands of particles can be rendered without much impact on performance.
 * 
 * Note that while this emits particles, it is itself not a particle, and the particles emitted by this action are not affected by everything that affects regular particles.
 * 
 * The name of this action is from Elden Ring's RTTI, where it's called "StandardParticle".
 */
class GPUStandardParticle extends DataAction {
  declare readonly type: ActionType.GPUStandardParticle
  /**
   * Controls how well the particles follow the node if it moves.
   * 
   * **Default**: `0`
   */
  particleFollowFactor: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_1: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_2: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_3: ScalarValue
  /**
   * Particle acceleration along the X-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleAccelerationMin}
   * - {@link particleAccelerationMax}
   */
  particleAccelerationX: ScalarValue
  /**
   * Particle acceleration along the Y-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleAccelerationMin}
   * - {@link particleAccelerationMax}
   */
  particleAccelerationY: ScalarValue
  /**
   * Particle acceleration along the Z-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleAccelerationMin}
   * - {@link particleAccelerationMax}
   */
  particleAccelerationZ: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_7: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_8: ScalarValue
  /**
   * Angular acceleration for particles around the Z-axis in degrees per second squared.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleAngularAccelerationMin}
   * - {@link particleAngularAccelerationMax}
   */
  particleAngularAccelerationZ: ScalarValue
  /**
   * The rate of change for the width of the particles.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleGrowthRateXStatic}
   */
  particleGrowthRateX: ScalarValue
  /**
   * The rate of change for the height of the particles.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleGrowthRateYStatic}
   */
  particleGrowthRateY: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_12: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  color: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p1_14: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_15: ScalarValue
  /**
   * Seemingly identical to {@link particleAccelerationZ}?
   * 
   * **Default**: `0`
   */
  unkParticleAcceleration: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_17: ScalarValue
  /**
   * Downwards acceleration for particles.
   * 
   * **Default**: `0`
   */
  particleGravity: ScalarValue
  /**
   * Maximum random turn angle for particles. Requires {@link particleRandomTurns} to be enabled.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleRandomTurns}
   * - {@link particleRandomTurnIntervalMax}
   */
  particleRandomTurnAngle: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_20: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p2_0: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p2_1: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_6: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `1005`
   */
  unk_ds3_f1_0: number
  /**
   * The ID of the texture of the particles.
   * 
   * **Default**: `1`
   */
  texture: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  normalMap: number
  /**
   * Controls the shape of the particle emitter. See {@link EmitterShape} for more details.
   * 
   * **Default**: {@link EmitterShape.Box}
   */
  emitterShape: EmitterShape
  /**
   * Unknown integer.
   * 
   * When set to `1`, this seems to allow the emitter to be rotated, but it also limits the direction particles can move. For example, with a box emitter shape, this makes the particles only able to move along one of the three axes of the box.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_5: number
  /**
   * The size of the emitter.
   * 
   * **Default**: `[1, 1, 1]`
   */
  emitterSize: Vector3
  /**
   * The rotation of the emitter.
   * 
   * **Default**: `[0, 0, 0]`
   */
  emitterRotation: Vector3
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_12: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_13: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_14: number
  /**
   * Controls how the random emission points are distributed within the {@link emitterShape shape of the emitter}. How this works depend on the emitter shape:
   * | Shape | Behavior |
   * |-|-|
   * | {@link EmitterShape.Line Line} | A fraction of the line where particles can not be emitted from.<br>At 0, particles can be emitted from any point on the line.<br>At 1, they can only be emitted from the far end of the line. |
   * | {@link EmitterShape.Box Box} | A fraction of the box's size where the particles can not be emitted from. Basically an inner box that blocks emission. |
   * | {@link EmitterShape.Box2 Box2} | At 1, any point within the box is equally likely to be picked.<br>At 0, particles are more likely to be emitted near the center, but it's not a 100% chance. |
   * | {@link EmitterShape.Unk3 Unk3} | Exactly the same as {@link EmitterShape.Line Line}? |
   * | {@link EmitterShape.Cylinder Cylinder} | A fraction of the radius of the cylinder where the particles can not be emitted from. Basically an inner cylinder that blocks emission. |
   * 
   * **Default**: `0`
   */
  emitterDistribution: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_16: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `100`
   */
  unk_ds3_f1_21: number
  /**
   * The number of particles to emit per emission.
   * 
   * **Default**: `10`
   * 
   * See also:
   * - {@link emissionParticleCountMin}
   * - {@link emissionParticleCountMax}
   */
  emissionParticleCount: number
  /**
   * The minimum number of particles to emit per emission. A new random value is picked for each emission, and the random value is added to the {@link emissionParticleCount base emission particle count}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionParticleCount}
   * - {@link emissionParticleCountMax}
   */
  emissionParticleCountMin: number
  /**
   * The maximum number of particles to emit per emission. A new random value is picked for each emission, and the random value is added to the {@link emissionParticleCount base emission particle count}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionParticleCount}
   * - {@link emissionParticleCountMin}
   */
  emissionParticleCountMax: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_25: number
  /**
   * The minimum time between emissions in seconds. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link emissionIntervalMax}
   */
  emissionIntervalMin: number
  /**
   * The maximum time between emissions in seconds. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link emissionIntervalMin}
   */
  emissionIntervalMax: number
  /**
   * If enabled, the number of emissions will be limited by {@link emissionCountLimit}.
   * 
   * **Default**: `false`
   */
  limitEmissionCount: boolean
  /**
   * The total number of emissions. This limit is only applied if {@link limitEmissionCount} is enabled.
   * 
   * **Default**: `0`
   */
  emissionCountLimit: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_30: number
  /**
   * The duration of each particle in seconds. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `1`
   */
  particleDuration: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_33: number
  /**
   * Particle position offset.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleOffsetMin}
   * - {@link particleOffsetMax}
   */
  particleOffset: Vector3
  /**
   * Minimum particle position offset. A random value between this and {@link particleOffsetMax} will be added to {@link particleOffset} to get the final position offset.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleOffsetMin: Vector3
  /**
   * Maximum particle position offset. A random value between this and {@link particleOffsetMin} will be added to {@link particleOffset} to get the final position offset.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleOffsetMax: Vector3
  /**
   * Particle speed.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleSpeedMin}
   * - {@link particleSpeedMax}
   */
  particleSpeed: Vector3
  /**
   * Minimum particle speed. A random value between this and {@link particleSpeedMax} will be added to {@link particleSpeed} to get the final speed.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleSpeedMin: Vector3
  /**
   * Maximum particle speed. A random value between this and {@link particleSpeedMin} will be added to {@link particleSpeed} to get the final speed.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleSpeedMax: Vector3
  /**
   * Minimum particle acceleration. A random value between this and {@link particleAccelerationMax} will be added to the three acceleration properties to get the final acceleration.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleAccelerationX}
   * - {@link particleAccelerationY}
   * - {@link particleAccelerationZ}
   */
  particleAccelerationMin: Vector3
  /**
   * Maximum particle acceleration. A random value between this and {@link particleAccelerationMin} will be added to the three acceleration properties to get the final acceleration.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleAccelerationX}
   * - {@link particleAccelerationY}
   * - {@link particleAccelerationZ}
   */
  particleAccelerationMax: Vector3
  /**
   * Maximum amount of random rotation for each particle in degrees.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleRotationVariance: Vector3
  /**
   * Maximum amount of random angular speed for each particle in degrees per second.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleAngularSpeedVariance: Vector3
  /**
   * Minimum amount of random angular acceleration for each particle in degrees per second squared.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleAngularAccelerationMax}
   */
  particleAngularAccelerationMin: Vector3
  /**
   * Maximum amount of random angular acceleration for each particle in degrees per second squared.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleAngularAccelerationMin}
   */
  particleAngularAccelerationMax: Vector3
  /**
   * When enabled, the height of the particles will be based on the {@link particleSizeX width} instead of the {@link particleSizeY height field}, and the height field is ignored.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link particleSizeX}
   * - {@link particleSizeY}
   * - {@link particleSizeXMin}
   * - {@link particleSizeYMin}
   * - {@link particleSizeXMax}
   * - {@link particleSizeYMax}
   * - {@link particleGrowthRateX}
   * - {@link particleGrowthRateY}
   * - {@link particleGrowthRateXStatic}
   * - {@link particleGrowthRateYStatic}
   * - {@link particleGrowthAccelerationXMin}
   * - {@link particleGrowthAccelerationYMin}
   * - {@link particleGrowthAccelerationXMax}
   * - {@link particleGrowthAccelerationYMax}
   */
  particleUniformScale: boolean
  /**
   * The width of the particle.
   * 
   * **Default**: `1`
   */
  particleSizeX: number
  /**
   * The height of the particle.
   * 
   * **Default**: `1`
   */
  particleSizeY: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_73: number
  /**
   * The minimum width of the particle. A random value between this and {@link particleSizeXMin} will be added to {@link particleSizeX} to get the final width.
   * 
   * **Default**: `0`
   */
  particleSizeXMin: number
  /**
   * The minimum height of the particle. A random value between this and {@link particleSizeYMin} will be added to {@link particleSizeY} to get the final height.
   * 
   * **Default**: `0`
   */
  particleSizeYMin: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_76: number
  /**
   * The maximum width of the particle. A random value between this and {@link particleSizeXMax} will be added to {@link particleSizeX} to get the final width.
   * 
   * **Default**: `0`
   */
  particleSizeXMax: number
  /**
   * The maximum height of the particle. A random value between this and {@link particleSizeYMax} will be added to {@link particleSizeY} to get the final height.
   * 
   * **Default**: `0`
   */
  particleSizeYMax: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_79: number
  /**
   * The rate of change for the width of the particles.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleGrowthRateX}
   */
  particleGrowthRateXStatic: number
  /**
   * The rate of change for the height of the particles.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleGrowthRateY}
   */
  particleGrowthRateYStatic: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_82: number
  /**
   * Minimum rate of change for the width of the particles. A random value between this and {@link particleGrowthRateXMax} will be added to {@link particleGrowthRateX} and {@link particleGrowthRateXStatic} to get the final growth rate.
   * 
   * **Default**: `0`
   */
  particleGrowthRateXMin: number
  /**
   * Minimum rate of change for the height of the particles. A random value between this and {@link particleGrowthRateYMax} will be added to {@link particleGrowthRateY} and {@link particleGrowthRateYStatic} to get the final growth rate.
   * 
   * **Default**: `0`
   */
  particleGrowthRateYMin: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_85: number
  /**
   * Maximum rate of change for the width of the particles. A random value between this and {@link particleGrowthRateXMax} will be added to {@link particleGrowthRateX} and {@link particleGrowthRateXStatic} to get the final growth rate.
   * 
   * **Default**: `0`
   */
  particleGrowthRateXMax: number
  /**
   * Maximum rate of change for the height of the particles. A random value between this and {@link particleGrowthRateYMax} will be added to {@link particleGrowthRateY} and {@link particleGrowthRateYStatic} to get the final growth rate.
   * 
   * **Default**: `0`
   */
  particleGrowthRateYMax: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_88: number
  /**
   * Minimum acceleration of change for the width of the particles. A random value between this and {@link particleGrowthAccelerationXMax} will be the final growth acceleration.
   * 
   * **Default**: `0`
   */
  particleGrowthAccelerationXMin: number
  /**
   * Minimum acceleration of change for the height of the particles. A random value between this and {@link particleGrowthAccelerationYMax} will be the final growth acceleration.
   * 
   * **Default**: `0`
   */
  particleGrowthAccelerationYMin: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_91: number
  /**
   * Minimum acceleration of change for the width of the particles. A random value between this and {@link particleGrowthAccelerationXMin} will be the final growth acceleration.
   * 
   * **Default**: `0`
   */
  particleGrowthAccelerationXMax: number
  /**
   * Minimum acceleration of change for the height of the particles. A random value between this and {@link particleGrowthAccelerationYMin} will be the final growth acceleration.
   * 
   * **Default**: `0`
   */
  particleGrowthAccelerationYMax: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_94: number
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   */
  rgbMultiplier: number
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   */
  alphaMultiplier: number
  /**
   * Minimum random variation for the particle color. A random value between this and {@link colorMax} will be added to the base {@link color}, but it fades out over the life of the particle.
   * 
   * **Default**: `[0, 0, 0, 0]`
   */
  colorMin: Vector4
  /**
   * Maximum random variation for the particle color. A random value between this and {@link colorMin} will be added to the base {@link color}, but it fades out over the life of the particle.
   * 
   * **Default**: `[0, 0, 0, 0]`
   */
  colorMax: Vector4
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   */
  blendMode: BlendMode
  /**
   * To split the texture into multiple animation frames, this value must be set to the number of columns in the texture. It should equal `textureWidth / frameWidth`.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link totalFrames}
   */
  columns: number
  /**
   * To split the texture into multiple animation frames, this value must be set to the total number of frames in the texture.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link columns}
   */
  totalFrames: number
  /**
   * When enabled, this makes each particle pick a random frame from the animation and only display that one frame.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link columns}
   * - {@link totalFrames}
   * - {@link maxFrameIndex}
   */
  randomTextureFrame: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_109: number
  /**
   * Controls the maximum frame index when {@link randomTextureFrame picking a random frame to display}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link randomTextureFrame}
   */
  maxFrameIndex: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_111: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_112: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_113: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_114: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_115: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_116: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_117: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_118: number
  /**
   * Multiplier for {@link particleDuration}.
   * 
   * **Default**: `1`
   */
  particleDurationMultiplier: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_120: number
  /**
   * Scalar multiplier for the size of the particles.
   * 
   * **Default**: `1`
   */
  particleSizeMultiplier: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_122: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_123: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_124: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_125: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_126: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_127: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_128: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_129: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_130: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_131: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_132: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_133: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_134: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_135: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_136: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_137: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f1_138: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_139: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_140: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_141: number
  /**
   * If enabled, the particle system stops updating if the camera is beyond the distance specified by {@link updateDistance} from the node.
   * 
   * It will not stop updating immediately after the action becomes active. Instead, it will wait for a little while before stopping if the camera is too far away.
   * 
   * **Default**: `false`
   */
  limitUpdateDistance: boolean
  /**
   * Controls how close the camera needs to be to the node for the particle system to update. Requires {@link limitUpdateDistance} to be enabled.
   * 
   * **Default**: `0`
   */
  updateDistance: number
  /**
   * When enabled, this makes the particles bounce off of any surface they hit. This collision detection is just based on the depth buffer, not the full 3D scene, so it is not always perfect.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link particleBounciness}
   */
  particleCollision: boolean
  /**
   * Controls how strong the rebound from hitting a surface is when {@link particleCollision} is enabled.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleCollision}
   */
  particleBounciness: number
  /**
   * If enabled, particles will randomly make sharp turns that affect the direction of various speed and acceleration properties. Both the time between turns and the turn angle are randomized for each turn and for each particle, and they are based on {@link particleRandomTurnIntervalMax} and {@link particleRandomTurnAngle} respectively.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link particleRandomTurnIntervalMax}
   * - {@link particleRandomTurnAngle}
   */
  particleRandomTurns: boolean
  /**
   * The maximum amount of time in seconds to wait between making random turns. Due to the way this field works, the value will be rounded to the nearest 1/30s. Requires {@link particleRandomTurns} to be enabled.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link particleRandomTurns}
   * - {@link particleRandomTurnAngle}
   */
  particleRandomTurnIntervalMax: number
  /**
   * If enabled, this causes the particles to orient themselves and stretch in the direction they are moving on the screen, making them almost resemble {@link ActionType.Tracer Tracer} particles.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link particleTraceLength}
   */
  traceParticles: boolean
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_149: number
  /**
   * Controls how much the particles are stretched when {@link traceParticles} is enabled.
   * 
   * **Default**: `1`
   */
  particleTraceLength: number
  /**
   * A central fraction of the emitter volume where the particles will not be trace particles. In this volume, the particles act as if {@link traceParticles} is disabled.
   * 
   * **Default**: `0`
   */
  traceParticlesThreshold: number
  /**
   * If enabled, this will add a billboarding sprite to the leading end of trace particles.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link traceParticles}
   */
  traceParticleHead: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_153: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_154: number
  /**
   * Controls whether or not the particles have a bloom effect.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_160: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_161: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_162: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_163: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_164: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_165: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_166: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_er_f1_167: number
  /**
   * Desaturates the particles, making them more grayscale. At 0, the particles will have their regular colors. At 1, they will be entirely grayscale.
   * 
   * **Default**: `0`
   */
  desaturate: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_4: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_5: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_6: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_7: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_8: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_29: number
  /**
   * Controls how dark shaded parts of the particle are.
   * 
   * **Default**: `0`
   */
  shadowDarkness: number
  /**
   * When set to 1, this stops the particles from being shown indoors.
   * 
   * Other values are used in AC6, but what they do is unknown.
   * 
   * **Default**: `0`
   */
  unkHideIndoors: number
  /**
   * Unknown boolean.
   * 
   * Like in most other actions with this field, when enabled, it may stop {@link unk_sdt_f2_29} from doing whatever it is doing, but that field may also not work exactly the same in this action, so it's tricky to confirm. It can also cause some ugly "outline" effects on things seen through particles, and it may also fix an issue where some other particles can be seen through particles emitted by this action.
   * 
   * **Default**: `false`
   */
  unk_sdt_f2_32: boolean
  /**
   * Specular texture ID.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link lighting}
   * - {@link glossiness}
   * - {@link specularity}
   */
  specular: number
  /**
   * Controls how sharp the specular highlights are.
   * 
   * **Default**: `0.25`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   * - {@link specularity}
   */
  glossiness: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  lighting: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Controls how bright the specular highlights are.
   * 
   * **Default**: `0.5`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   * - {@link glossiness}
   */
  specularity: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_39: number
  constructor(props: Partial<Props<GPUStandardParticle>> = {}) {
    super(ActionType.GPUStandardParticle)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.GPUStandardCorrectParticle Action 10001 - GPUStandardCorrectParticle}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Very similar to {@link ActionType.GPUStandardParticle GPUStandardParticle}, with no known differences.
 * 
 * The name of this action is from Elden Ring's RTTI, where it's called "StandardCorrectParticle". An action with the same ID had the name "WanderingVision" in Dark Souls 3, and that action could still exist in DS3, but it is not found in the vanilla game, so testing it is difficult.
 * 
 * Note: This action does not exist in Dark Souls 3 or Sekiro, but it still has unknown fields and properties named after those games. This is because it makes the conversion between this action and {@link ActionType.GPUStandardParticle GPUStandardParticle} much simpler. When written for those two games, this action will be converted to the other action automatically.
 */
class GPUStandardCorrectParticle extends DataAction {
  declare readonly type: ActionType.GPUStandardCorrectParticle
  /**
   * Controls how well the particles follow the node if it moves.
   * 
   * **Default**: `0`
   */
  particleFollowFactor: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_1: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_2: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_3: ScalarValue
  /**
   * Particle acceleration along the X-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleAccelerationMin}
   * - {@link particleAccelerationMax}
   */
  particleAccelerationX: ScalarValue
  /**
   * Particle acceleration along the Y-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleAccelerationMin}
   * - {@link particleAccelerationMax}
   */
  particleAccelerationY: ScalarValue
  /**
   * Particle acceleration along the Z-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleAccelerationMin}
   * - {@link particleAccelerationMax}
   */
  particleAccelerationZ: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_7: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_8: ScalarValue
  /**
   * Angular acceleration for particles around the Z-axis in degrees per second squared.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleAngularAccelerationMin}
   * - {@link particleAngularAccelerationMax}
   */
  particleAngularAccelerationZ: ScalarValue
  /**
   * The rate of change for the width of the particles.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleGrowthRateXStatic}
   */
  particleGrowthRateX: ScalarValue
  /**
   * The rate of change for the height of the particles.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleGrowthRateYStatic}
   */
  particleGrowthRateY: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_12: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  color: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p1_14: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_15: ScalarValue
  /**
   * Seemingly identical to {@link particleAccelerationZ}?
   * 
   * **Default**: `0`
   */
  unkParticleAcceleration: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_17: ScalarValue
  /**
   * Downwards acceleration for particles.
   * 
   * **Default**: `0`
   */
  particleGravity: ScalarValue
  /**
   * Maximum random turn angle for particles. Requires {@link particleRandomTurns} to be enabled.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleRandomTurns}
   * - {@link particleRandomTurnIntervalMax}
   */
  particleRandomTurnAngle: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_20: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p2_0: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p2_1: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p2_6: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `1005`
   */
  unk_ds3_f1_0: number
  /**
   * The ID of the texture of the particles.
   * 
   * **Default**: `1`
   */
  texture: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  normalMap: number
  /**
   * Controls the shape of the particle emitter. See {@link EmitterShape} for more details.
   * 
   * **Default**: {@link EmitterShape.Box}
   */
  emitterShape: EmitterShape
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_5: number
  /**
   * The size of the emitter.
   * 
   * **Default**: `[1, 1, 1]`
   */
  emitterSize: Vector3
  /**
   * The rotation of the emitter.
   * 
   * **Default**: `[0, 0, 0]`
   */
  emitterRotation: Vector3
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_12: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_13: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_14: number
  /**
   * Controls how the random emission points are distributed within the {@link emitterShape shape of the emitter}. How this works depend on the emitter shape:
   * | Shape | Behavior |
   * |-|-|
   * | {@link EmitterShape.Line Line} | A fraction of the line where particles can not be emitted from.<br>At 0, particles can be emitted from any point on the line.<br>At 1, they can only be emitted from the far end of the line. |
   * | {@link EmitterShape.Box Box} | A fraction of the box's size where the particles can not be emitted from. Basically an inner box that blocks emission. |
   * | {@link EmitterShape.Box2 Box2} | At 1, any point within the box is equally likely to be picked.<br>At 0, particles are more likely to be emitted near the center, but it's not a 100% chance. |
   * | {@link EmitterShape.Unk3 Unk3} | Exactly the same as {@link EmitterShape.Line Line}? |
   * | {@link EmitterShape.Cylinder Cylinder} | A fraction of the radius of the cylinder where the particles can not be emitted from. Basically an inner cylinder that blocks emission. |
   * 
   * **Default**: `0`
   */
  emitterDistribution: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_16: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `100`
   */
  unk_ds3_f1_21: number
  /**
   * The number of particles to emit per emission.
   * 
   * **Default**: `10`
   * 
   * See also:
   * - {@link emissionParticleCountMin}
   * - {@link emissionParticleCountMax}
   */
  emissionParticleCount: number
  /**
   * The minimum number of particles to emit per emission. A new random value is picked for each emission, and the random value is added to the {@link emissionParticleCount base emission particle count}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionParticleCount}
   * - {@link emissionParticleCountMax}
   */
  emissionParticleCountMin: number
  /**
   * The maximum number of particles to emit per emission. A new random value is picked for each emission, and the random value is added to the {@link emissionParticleCount base emission particle count}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionParticleCount}
   * - {@link emissionParticleCountMin}
   */
  emissionParticleCountMax: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_25: number
  /**
   * The minimum time between emissions in seconds. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link emissionIntervalMax}
   */
  emissionIntervalMin: number
  /**
   * The maximum time between emissions in seconds. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link emissionIntervalMin}
   */
  emissionIntervalMax: number
  /**
   * If enabled, the number of emissions will be limited by {@link emissionCountLimit}.
   * 
   * **Default**: `false`
   */
  limitEmissionCount: boolean
  /**
   * The total number of emissions. This limit is only applied if {@link limitEmissionCount} is enabled.
   * 
   * **Default**: `0`
   */
  emissionCountLimit: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_30: number
  /**
   * The duration of each particle in seconds. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `1`
   */
  particleDuration: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_33: number
  /**
   * Particle position offset.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleOffsetMin}
   * - {@link particleOffsetMax}
   */
  particleOffset: Vector3
  /**
   * Minimum particle position offset. A random value between this and {@link particleOffsetMax} will be added to {@link particleOffset} to get the final position offset.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleOffsetMin: Vector3
  /**
   * Maximum particle position offset. A random value between this and {@link particleOffsetMin} will be added to {@link particleOffset} to get the final position offset.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleOffsetMax: Vector3
  /**
   * Particle speed.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleSpeedMin}
   * - {@link particleSpeedMax}
   */
  particleSpeed: Vector3
  /**
   * Minimum particle speed. A random value between this and {@link particleSpeedMax} will be added to {@link particleSpeed} to get the final speed.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleSpeedMin: Vector3
  /**
   * Maximum particle speed. A random value between this and {@link particleSpeedMin} will be added to {@link particleSpeed} to get the final speed.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleSpeedMax: Vector3
  /**
   * Minimum particle acceleration. A random value between this and {@link particleAccelerationMax} will be added to the three acceleration properties to get the final acceleration.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleAccelerationX}
   * - {@link particleAccelerationY}
   * - {@link particleAccelerationZ}
   */
  particleAccelerationMin: Vector3
  /**
   * Maximum particle acceleration. A random value between this and {@link particleAccelerationMin} will be added to the three acceleration properties to get the final acceleration.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleAccelerationX}
   * - {@link particleAccelerationY}
   * - {@link particleAccelerationZ}
   */
  particleAccelerationMax: Vector3
  /**
   * Maximum amount of random rotation for each particle in degrees.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleRotationVariance: Vector3
  /**
   * Maximum amount of random angular speed for each particle in degrees per second.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleAngularSpeedVariance: Vector3
  /**
   * Minimum amount of random angular acceleration for each particle in degrees per second squared.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleAngularAccelerationMax}
   */
  particleAngularAccelerationMin: Vector3
  /**
   * Maximum amount of random angular acceleration for each particle in degrees per second squared.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleAngularAccelerationMin}
   */
  particleAngularAccelerationMax: Vector3
  /**
   * When enabled, the height of the particles will be based on the {@link particleSizeX width} instead of the {@link particleSizeY height field}, and the height field is ignored.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link particleSizeX}
   * - {@link particleSizeY}
   * - {@link particleSizeXMin}
   * - {@link particleSizeYMin}
   * - {@link particleSizeXMax}
   * - {@link particleSizeYMax}
   * - {@link particleGrowthRateX}
   * - {@link particleGrowthRateY}
   * - {@link particleGrowthRateXStatic}
   * - {@link particleGrowthRateYStatic}
   * - {@link particleGrowthAccelerationXMin}
   * - {@link particleGrowthAccelerationYMin}
   * - {@link particleGrowthAccelerationXMax}
   * - {@link particleGrowthAccelerationYMax}
   */
  particleUniformScale: boolean
  /**
   * The width of the particle.
   * 
   * **Default**: `1`
   */
  particleSizeX: number
  /**
   * The height of the particle.
   * 
   * **Default**: `1`
   */
  particleSizeY: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_73: number
  /**
   * The minimum width of the particle. A random value between this and {@link particleSizeXMin} will be added to {@link particleSizeX} to get the final width.
   * 
   * **Default**: `0`
   */
  particleSizeXMin: number
  /**
   * The minimum height of the particle. A random value between this and {@link particleSizeYMin} will be added to {@link particleSizeY} to get the final height.
   * 
   * **Default**: `0`
   */
  particleSizeYMin: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_76: number
  /**
   * The maximum width of the particle. A random value between this and {@link particleSizeXMax} will be added to {@link particleSizeX} to get the final width.
   * 
   * **Default**: `0`
   */
  particleSizeXMax: number
  /**
   * The maximum height of the particle. A random value between this and {@link particleSizeYMax} will be added to {@link particleSizeY} to get the final height.
   * 
   * **Default**: `0`
   */
  particleSizeYMax: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_79: number
  /**
   * The rate of change for the width of the particles.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleGrowthRateX}
   */
  particleGrowthRateXStatic: number
  /**
   * The rate of change for the height of the particles.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleGrowthRateY}
   */
  particleGrowthRateYStatic: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_82: number
  /**
   * Minimum rate of change for the width of the particles. A random value between this and {@link particleGrowthRateXMax} will be added to {@link particleGrowthRateX} and {@link particleGrowthRateXStatic} to get the final growth rate.
   * 
   * **Default**: `0`
   */
  particleGrowthRateXMin: number
  /**
   * Minimum rate of change for the height of the particles. A random value between this and {@link particleGrowthRateYMax} will be added to {@link particleGrowthRateY} and {@link particleGrowthRateYStatic} to get the final growth rate.
   * 
   * **Default**: `0`
   */
  particleGrowthRateYMin: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_85: number
  /**
   * Maximum rate of change for the width of the particles. A random value between this and {@link particleGrowthRateXMax} will be added to {@link particleGrowthRateX} and {@link particleGrowthRateXStatic} to get the final growth rate.
   * 
   * **Default**: `0`
   */
  particleGrowthRateXMax: number
  /**
   * Maximum rate of change for the height of the particles. A random value between this and {@link particleGrowthRateYMax} will be added to {@link particleGrowthRateY} and {@link particleGrowthRateYStatic} to get the final growth rate.
   * 
   * **Default**: `0`
   */
  particleGrowthRateYMax: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_88: number
  /**
   * Minimum acceleration of change for the width of the particles. A random value between this and {@link particleGrowthAccelerationXMax} will be the final growth acceleration.
   * 
   * **Default**: `0`
   */
  particleGrowthAccelerationXMin: number
  /**
   * Minimum acceleration of change for the height of the particles. A random value between this and {@link particleGrowthAccelerationYMax} will be the final growth acceleration.
   * 
   * **Default**: `0`
   */
  particleGrowthAccelerationYMin: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_91: number
  /**
   * Minimum acceleration of change for the width of the particles. A random value between this and {@link particleGrowthAccelerationXMin} will be the final growth acceleration.
   * 
   * **Default**: `0`
   */
  particleGrowthAccelerationXMax: number
  /**
   * Minimum acceleration of change for the height of the particles. A random value between this and {@link particleGrowthAccelerationYMin} will be the final growth acceleration.
   * 
   * **Default**: `0`
   */
  particleGrowthAccelerationYMax: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_94: number
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   */
  rgbMultiplier: number
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   */
  alphaMultiplier: number
  /**
   * Minimum random variation for the particle color. A random value between this and {@link colorMax} will be added to the base {@link color}, but it fades out over the life of the particle.
   * 
   * **Default**: `[0, 0, 0, 0]`
   */
  colorMin: Vector4
  /**
   * Maximum random variation for the particle color. A random value between this and {@link colorMin} will be added to the base {@link color}, but it fades out over the life of the particle.
   * 
   * **Default**: `[0, 0, 0, 0]`
   */
  colorMax: Vector4
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   */
  blendMode: BlendMode
  /**
   * To split the texture into multiple animation frames, this value must be set to the number of columns in the texture. It should equal `textureWidth / frameWidth`.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link totalFrames}
   */
  columns: number
  /**
   * To split the texture into multiple animation frames, this value must be set to the total number of frames in the texture.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link columns}
   */
  totalFrames: number
  /**
   * When enabled, this makes each particle pick a random frame from the animation and only display that one frame.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link columns}
   * - {@link totalFrames}
   * - {@link maxFrameIndex}
   */
  randomTextureFrame: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_109: number
  /**
   * Controls the maximum frame index when {@link randomTextureFrame picking a random frame to display}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link randomTextureFrame}
   */
  maxFrameIndex: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_111: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_112: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_113: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_114: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_115: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_116: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_117: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_118: number
  /**
   * Multiplier for {@link particleDuration}.
   * 
   * **Default**: `1`
   */
  particleDurationMultiplier: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_120: number
  /**
   * Scalar multiplier for the size of the particles.
   * 
   * **Default**: `1`
   */
  particleSizeMultiplier: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_122: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_123: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_124: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_125: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_126: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_127: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_128: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_129: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_130: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_131: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_132: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_133: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_134: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_135: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_136: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_137: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f1_138: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_139: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_140: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_141: number
  /**
   * If enabled, the particle system stops updating if the camera is beyond the distance specified by {@link updateDistance} from the node.
   * 
   * It will not stop updating immediately after the action becomes active. Instead, it will wait for a little while before stopping if the camera is too far away.
   * 
   * **Default**: `false`
   */
  limitUpdateDistance: boolean
  /**
   * Controls how close the camera needs to be to the node for the particle system to update. Requires {@link limitUpdateDistance} to be enabled.
   * 
   * **Default**: `0`
   */
  updateDistance: number
  /**
   * When enabled, this makes the particles bounce off of any surface they hit. This collision detection is just based on the depth buffer, not the full 3D scene, so it is not always perfect.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link particleBounciness}
   */
  particleCollision: boolean
  /**
   * Controls how strong the rebound from hitting a surface is when {@link particleCollision} is enabled.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleCollision}
   */
  particleBounciness: number
  /**
   * If enabled, particles will randomly make sharp turns that affect the direction of various speed and acceleration properties. Both the time between turns and the turn angle are randomized for each turn and for each particle, and they are based on {@link particleRandomTurnIntervalMax} and {@link particleRandomTurnAngle} respectively.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link particleRandomTurnIntervalMax}
   * - {@link particleRandomTurnAngle}
   */
  particleRandomTurns: boolean
  /**
   * The maximum amount of time in seconds to wait between making random turns. Due to the way this field works, the value will be rounded to the nearest 1/30s. Requires {@link particleRandomTurns} to be enabled.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link particleRandomTurns}
   * - {@link particleRandomTurnAngle}
   */
  particleRandomTurnIntervalMax: number
  /**
   * If enabled, this causes the particles to orient themselves and stretch in the direction they are moving on the screen, making them almost resemble {@link ActionType.Tracer Tracer} particles.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link particleTraceLength}
   */
  traceParticles: boolean
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_149: number
  /**
   * Controls how much the particles are stretched when {@link traceParticles} is enabled.
   * 
   * **Default**: `1`
   */
  particleTraceLength: number
  /**
   * A central fraction of the emitter volume where the particles will not be trace particles. In this volume, the particles act as if {@link traceParticles} is disabled.
   * 
   * **Default**: `0`
   */
  traceParticlesThreshold: number
  /**
   * If enabled, this will add a billboarding sprite to the leading end of trace particles.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link traceParticles}
   */
  traceParticleHead: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_153: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_154: number
  /**
   * Controls whether or not the particles have a bloom effect.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_160: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_161: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_162: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_163: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_164: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_165: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_166: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_er_f1_167: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_4: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_5: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_6: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_7: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_8: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_29: number
  /**
   * Controls how dark shaded parts of the particle are.
   * 
   * **Default**: `0`
   */
  shadowDarkness: number
  /**
   * When set to 1, this stops the particles from being shown indoors.
   * 
   * Other values are used in AC6, but what they do is unknown.
   * 
   * **Default**: `0`
   */
  unkHideIndoors: number
  /**
   * Unknown boolean.
   * 
   * Like in most other actions with this field, when enabled, it may stop {@link unk_sdt_f2_29} from doing whatever it is doing, but that field may also not work exactly the same in this action, so it's tricky to confirm. It can also cause some ugly "outline" effects on things seen through particles, and it may also fix an issue where some other particles can be seen through particles emitted by this action.
   * 
   * **Default**: `false`
   */
  unk_sdt_f2_32: boolean
  /**
   * Specular texture ID.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link lighting}
   * - {@link glossiness}
   * - {@link specularity}
   */
  specular: number
  /**
   * Controls how sharp the specular highlights are.
   * 
   * **Default**: `0.25`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   * - {@link specularity}
   */
  glossiness: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  lighting: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Controls how bright the specular highlights are.
   * 
   * **Default**: `0.5`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   * - {@link glossiness}
   */
  specularity: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_39: number
  constructor(props: Partial<Props<GPUStandardCorrectParticle>> = {}) {
    super(ActionType.GPUStandardCorrectParticle)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.LightShaft Action 10003 - LightShaft}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * A pretty simple light shafts effect only used in Dark Souls 3. It shows up if converted for Sekiro, but it doesn't seem to work correctly in that game. It does not seem to work at all in Elden Ring or Armored Core 6.
 */
class LightShaft extends DataAction {
  declare readonly type: ActionType.LightShaft
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  width: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  height: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  color1: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  color2: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  color3: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_5: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_6: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ds3_p1_7: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p1_8: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p1_9: ScalarValue
  /**
   * Texture ID.
   * 
   * **Default**: `0`
   */
  texture: number
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Add}
   */
  blendMode: BlendMode
  /**
   * Unknown float.
   * 
   * **Default**: `0.75`
   */
  unk_ds3_f1_2: number
  /**
   * Unknown float.
   * 
   * **Default**: `0.75`
   */
  unk_ds3_f1_3: number
  /**
   * Unknown float.
   * 
   * **Default**: `2`
   */
  unk_ds3_f1_4: number
  /**
   * Unknown float.
   * 
   * **Default**: `0.1`
   */
  unk_ds3_f1_5: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_6: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_7: number
  /**
   * The number of layers to use for the light shaft effect. Higher values will look better, but will probably perform worse.
   * 
   * **Default**: `30`
   */
  layers: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_9: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_10: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_13: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_14: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_17: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_18: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_19: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_20: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_21: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_22: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_25: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_26: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_27: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_29: number
  constructor(props: Partial<Props<LightShaft>> = {}) {
    super(ActionType.LightShaft)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.GPUSparkParticle Action 10008 - GPUSparkParticle}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Similar to {@link ActionType.GPUStandardParticle GPUStandardParticle}, this is essentially an entire particle system in a single action. It defines everything about an emitter as well as the particles it emits. The particles emitted by this action are GPU particles, which means that a lot of them can be rendered at the same time without much impact on performance. The particles are also not affected by most things that affect regular particles, like {@link ActionSlots.ParticleMovementAction ParticleMovement actions}.
 * 
 * What makes this different from {@link ActionType.GPUStandardParticle GPUStandardParticle} is that this actions seems to be designed specifically for effects that create sparks. While the other action's particles is more like billboard particles from, for example, {@link ActionType.BillboardEx BillboardEx}, this action's particles are more like {@link ActionType.QuadLine QuadLine} or {@link ActionType.Tracer Tracer} particles. They bend and rotate to align with the direction they are traveling, and they stretch based on how fast they're moving.
 * 
 * The name of this action is from Elden Ring's RTTI, where it's called "SparkParticle".
 * 
 * This action was first used in Armored Core 6, but definitely also works in Sekiro and Elden Ring. It might work in Dark Souls 3, but its structure is at least somewhat different there, and what that structure looks like is unknown. AC6's structure is compatible with Sekiro and ER, but some features may not work due to having been added in later versions.
 */
class GPUSparkParticle extends DataAction {
  declare readonly type: ActionType.GPUSparkParticle
  /**
   * Controls how well the particles follow the node if it moves.
   * 
   * **Default**: `0`
   */
  particleFollowFactor: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p1_1: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p1_2: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p1_3: ScalarValue
  /**
   * Particle acceleration along the X-axis.
   * 
   * **Default**: `0`
   */
  particleAccelerationX: ScalarValue
  /**
   * Particle acceleration along the Y-axis.
   * 
   * **Default**: `0`
   */
  particleAccelerationY: ScalarValue
  /**
   * Particle acceleration along the Z-axis.
   * 
   * **Default**: `0`
   */
  particleAccelerationZ: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  color: Vector4Value
  /**
   * The length of the particles.
   * 
   * **Default**: `1`
   */
  particleLength: ScalarValue
  /**
   * The width of the particles.
   * 
   * **Default**: `0.1`
   */
  particleWidth: ScalarValue
  /**
   * Similar to {@link particleAccelerationZ}, but this does not go exactly north?
   * 
   * This requires any of the following fields to have a non-zero value:
   * - {@link particleSpeedMin}
   * - {@link particleSpeedMax}
   * 
   * **Default**: `0`
   */
  unkParticleAcceleration: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p1_11: ScalarValue
  /**
   * Downwards acceleration for particles.
   * 
   * This requires any of the following fields to have a non-zero value:
   * - {@link particleSpeedMin}
   * - {@link particleSpeedMax}
   * 
   * **Default**: `1`
   */
  particleGravity: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p1_13: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ac6_p2_0: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ac6_p2_1: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ac6_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ac6_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ac6_p2_5: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p2_6: ScalarValue
  /**
   * The ID of the texture of the particles.
   * 
   * **Default**: `1`
   */
  texture: number
  /**
   * Controls the shape of the particle emitter. See {@link EmitterShape} for more details.
   * 
   * **Default**: {@link EmitterShape.Box}
   */
  emitterShape: EmitterShape
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_2: number
  /**
   * The size of the emitter.
   * 
   * **Default**: `[1, 1, 1]`
   */
  emitterSize: Vector3
  /**
   * The rotation of the emitter.
   * 
   * **Default**: `[0, 0, 0]`
   */
  emitterRotation: Vector3
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_9: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_10: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_11: number
  /**
   * Controls how the random emission points are distributed within the {@link emitterShape shape of the emitter}. How this works depend on the emitter shape:
   * | Shape | Behavior |
   * |-|-|
   * | {@link EmitterShape.Line Line} | A fraction of the line where particles can not be emitted from.<br>At 0, particles can be emitted from any point on the line.<br>At 1, they can only be emitted from the far end of the line. |
   * | {@link EmitterShape.Box Box} | A fraction of the box's size where the particles can not be emitted from. Basically an inner box that blocks emission. |
   * | {@link EmitterShape.Box2 Box2} | At 1, any point within the box is equally likely to be picked.<br>At 0, particles are more likely to be emitted near the center, but it's not a 100% chance. |
   * | {@link EmitterShape.Unk3 Unk3} | Exactly the same as {@link EmitterShape.Line Line}? |
   * | {@link EmitterShape.Cylinder Cylinder} | A fraction of the radius of the cylinder where the particles can not be emitted from. Basically an inner cylinder that blocks emission. |
   * 
   * **Default**: `0`
   */
  emitterDistribution: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_13: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_17: number
  /**
   * The number of particles to emit per emission.
   * 
   * **Default**: `10`
   * 
   * See also:
   * - {@link emissionParticleCountMin}
   * - {@link emissionParticleCountMax}
   */
  emissionParticleCount: number
  /**
   * The minimum number of particles to emit per emission. A new random value is picked for each emission, and the random value is added to the {@link emissionParticleCount base emission particle count}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionParticleCount}
   * - {@link emissionParticleCountMax}
   */
  emissionParticleCountMin: number
  /**
   * The maximum number of particles to emit per emission. A new random value is picked for each emission, and the random value is added to the {@link emissionParticleCount base emission particle count}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionParticleCount}
   * - {@link emissionParticleCountMin}
   */
  emissionParticleCountMax: number
  /**
   * The time between emissions in seconds. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionIntervalMin}
   * - {@link emissionIntervalMax}
   */
  emissionInterval: number
  /**
   * The minimum time between emissions in seconds. A random value between this and {@link emissionIntervalMax} will be added to {@link emissionInterval} to get the final emission interval. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionInterval}
   * - {@link emissionIntervalMax}
   */
  emissionIntervalMin: number
  /**
   * The maximum time between emissions in seconds. A random value between this and {@link emissionIntervalMin} will be added to {@link emissionInterval} to get the final emission interval. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionInterval}
   * - {@link emissionIntervalMin}
   */
  emissionIntervalMax: number
  /**
   * If enabled, the number of emissions will be limited by {@link concurrentEmissionsLimit}.
   * 
   * **Default**: `false`
   */
  limitConcurrentEmissions: boolean
  /**
   * The total number of emissions. This limit is only applied if {@link limitConcurrentEmissions} is enabled.
   * 
   * **Default**: `0`
   */
  concurrentEmissionsLimit: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_26: number
  /**
   * The duration of each particle in seconds. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `1`
   */
  particleDuration: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_29: number
  /**
   * Particle position offset.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleOffsetMin}
   * - {@link particleOffsetMax}
   */
  particleOffset: Vector3
  /**
   * Minimum particle position offset. A random value between this and {@link particleOffsetMax} will be added to {@link particleOffset} to get the final position offset.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleOffsetMin: Vector3
  /**
   * Maximum particle position offset. A random value between this and {@link particleOffsetMin} will be added to {@link particleOffset} to get the final position offset.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleOffsetMax: Vector3
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_39: number
  /**
   * Minimum particle speed.
   * 
   * **Default**: `[-0.01, -0.01, -0.01]`
   * 
   * See also:
   * - {@link particleSpeedMax}
   */
  particleSpeedMin: Vector3
  /**
   * Maximum particle speed.
   * 
   * **Default**: `[0.01, 0.01, 0.01]`
   * 
   * See also:
   * - {@link particleSpeedMin}
   */
  particleSpeedMax: Vector3
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   */
  rgbMultiplier: number
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   */
  alphaMultiplier: number
  /**
   * Minimum random variation for the particle color. A random value between this and {@link colorMax} will be added to the base {@link color}, but it fades out over the life of the particle.
   * 
   * **Default**: `[0, 0, 0, 0]`
   */
  colorMin: Vector4
  /**
   * Maximum random variation for the particle color. A random value between this and {@link colorMin} will be added to the base {@link color}, but it fades out over the life of the particle.
   * 
   * **Default**: `[0, 0, 0, 0]`
   */
  colorMax: Vector4
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Add}
   */
  blendMode: BlendMode
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_57: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_58: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_59: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_60: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_61: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_62: number
  /**
   * Minimum particle length. A random value between this and {@link particleLengthMax} will be **multiplied** by {@link particleLength} to get the final particle length.
   * 
   * **Default**: `1`
   */
  particleLengthMin: number
  /**
   * Maximum particle length. A random value between this and {@link particleLengthMin} will be **multiplied** by {@link particleLength} to get the final particle length.
   * 
   * **Default**: `1`
   */
  particleLengthMax: number
  /**
   * Minimum particle width. A random value between this and {@link particleWidthMax} will be **multiplied** by {@link particleWidth} to get the final particle width.
   * 
   * **Default**: `1`
   */
  particleWidthMin: number
  /**
   * Maximum particle width. A random value between this and {@link particleWidthMin} will be **multiplied** by {@link particleWidth} to get the final particle width.
   * 
   * **Default**: `1`
   */
  particleWidthMax: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_67: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_68: number
  /**
   * Multiplier for {@link particleDuration}.
   * 
   * **Default**: `1`
   */
  particleDurationMultiplier: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_70: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_71: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_72: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_73: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_74: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_75: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_76: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_77: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_78: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_79: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_80: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_81: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_82: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_83: number
  /**
   * Unknown float. Seems to make the particles fly around somewhat randomly, but with a specific average direction. {@link unk_ac6_f1_85} works in a similar way, but has the opposite average direction.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_84: number
  /**
   * Unknown float. Seems to make the particles fly around somewhat randomly, but with a specific average direction. {@link unk_ac6_f1_84} works in a similar way, but has the opposite average direction.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_85: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_86: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ac6_f1_87: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_88: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_89: number
  /**
   * If enabled, the particle system stops updating if the camera is beyond the distance specified by {@link updateDistance} from the node.
   * 
   * It will not stop updating immediately after the action becomes active. Instead, it will wait for a little while before stopping if the camera is too far away.
   * 
   * **Default**: `false`
   */
  limitUpdateDistance: boolean
  /**
   * Controls how close the camera needs to be to the node for the particle system to update. Requires {@link limitUpdateDistance} to be enabled.
   * 
   * **Default**: `0`
   */
  updateDistance: number
  /**
   * When enabled, this makes the particles bounce off of any surface they hit. This collision detection is just based on the depth buffer, not the full 3D scene, so it is not always perfect.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link particleBounciness}
   */
  particleCollision: boolean
  /**
   * Controls how strong the rebound from hitting a surface is when {@link particleCollision} is enabled.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleCollision}
   */
  particleBounciness: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_94: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_95: number
  /**
   * Controls whether or not the particles have a bloom effect.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_101: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_102: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_103: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ac6_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_4: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f2_5: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f2_6: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f2_7: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f2_8: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_13: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ac6_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_28: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_29: number
  /**
   * Controls how dark shaded parts of the particle are.
   * 
   * **Default**: `1`
   */
  shadowDarkness: number
  /**
   * When set to 1, this stops the particles from being shown indoors.
   * 
   * Other values are used in AC6, but what they do is unknown.
   * 
   * **Default**: `0`
   */
  unkHideIndoors: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_33: number
  /**
   * Unknown float.
   * 
   * **Default**: `0.5`
   */
  unk_ac6_f2_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  lighting: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_ac6_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_37: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_38: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_39: number
  constructor(props: Partial<Props<GPUSparkParticle>> = {}) {
    super(ActionType.GPUSparkParticle)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.GPUSparkCorrectParticle Action 10009 - GPUSparkCorrectParticle}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Very similar to {@link ActionType.GPUSparkParticle GPUSparkParticle}, just like how {@link ActionType.GPUStandardCorrectParticle GPUStandardCorrectParticle} is similar to {@link ActionType.GPUStandardParticle GPUStandardParticle}, except these two spark actions have some known differences.
 * 
 * Not all of the differences have been documented yet, but here are some:
 * - This action seems to have swapped some axes of rotation, causing some confusing things to happen when the node is spinning.
 * - The particles from this action are smaller.
 * - The particles from this action move slower. It's possible that this action uses a different unit of distance, since that would explain both the slower movement and the smaller particles.
 * 
 * The name of this action is from Elden Ring's RTTI, where it's called "SparkCorrectParticle".
 */
class GPUSparkCorrectParticle extends DataAction {
  declare readonly type: ActionType.GPUSparkCorrectParticle
  /**
   * Controls how well the particles follow the node if it moves.
   * 
   * **Default**: `0`
   */
  particleFollowFactor: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p1_1: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p1_2: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p1_3: ScalarValue
  /**
   * Particle acceleration along the X-axis.
   * 
   * **Default**: `0`
   */
  particleAccelerationX: ScalarValue
  /**
   * Particle acceleration along the Y-axis.
   * 
   * **Default**: `0`
   */
  particleAccelerationY: ScalarValue
  /**
   * Particle acceleration along the Z-axis.
   * 
   * **Default**: `0`
   */
  particleAccelerationZ: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  color: Vector4Value
  /**
   * The length of the particles.
   * 
   * **Default**: `1`
   */
  particleLength: ScalarValue
  /**
   * The width of the particles.
   * 
   * **Default**: `0.1`
   */
  particleWidth: ScalarValue
  /**
   * Similar to {@link particleAccelerationZ}, but this does not go exactly north?
   * 
   * This requires any of the following fields to have a non-zero value:
   * - {@link particleSpeedMin}
   * - {@link particleSpeedMax}
   * 
   * **Default**: `0`
   */
  unkParticleAcceleration: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p1_11: ScalarValue
  /**
   * Downwards acceleration for particles.
   * 
   * This requires any of the following fields to have a non-zero value:
   * - {@link particleSpeedMin}
   * - {@link particleSpeedMax}
   * 
   * **Default**: `1`
   */
  particleGravity: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p1_13: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ac6_p2_0: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ac6_p2_1: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ac6_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ac6_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ac6_p2_5: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_ac6_p2_6: ScalarValue
  /**
   * The ID of the texture of the particles.
   * 
   * **Default**: `1`
   */
  texture: number
  /**
   * Controls the shape of the particle emitter. See {@link EmitterShape} for more details.
   * 
   * **Default**: {@link EmitterShape.Box}
   */
  emitterShape: EmitterShape
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_2: number
  /**
   * The size of the emitter.
   * 
   * **Default**: `[1, 1, 1]`
   */
  emitterSize: Vector3
  /**
   * The rotation of the emitter.
   * 
   * **Default**: `[0, 0, 0]`
   */
  emitterRotation: Vector3
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_9: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_10: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_11: number
  /**
   * Controls how the random emission points are distributed within the {@link emitterShape shape of the emitter}. How this works depend on the emitter shape:
   * | Shape | Behavior |
   * |-|-|
   * | {@link EmitterShape.Line Line} | A fraction of the line where particles can not be emitted from.<br>At 0, particles can be emitted from any point on the line.<br>At 1, they can only be emitted from the far end of the line. |
   * | {@link EmitterShape.Box Box} | A fraction of the box's size where the particles can not be emitted from. Basically an inner box that blocks emission. |
   * | {@link EmitterShape.Box2 Box2} | At 1, any point within the box is equally likely to be picked.<br>At 0, particles are more likely to be emitted near the center, but it's not a 100% chance. |
   * | {@link EmitterShape.Unk3 Unk3} | Exactly the same as {@link EmitterShape.Line Line}? |
   * | {@link EmitterShape.Cylinder Cylinder} | A fraction of the radius of the cylinder where the particles can not be emitted from. Basically an inner cylinder that blocks emission. |
   * 
   * **Default**: `0`
   */
  emitterDistribution: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_13: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_17: number
  /**
   * The number of particles to emit per emission.
   * 
   * **Default**: `10`
   * 
   * See also:
   * - {@link emissionParticleCountMin}
   * - {@link emissionParticleCountMax}
   */
  emissionParticleCount: number
  /**
   * The minimum number of particles to emit per emission. A new random value is picked for each emission, and the random value is added to the {@link emissionParticleCount base emission particle count}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionParticleCount}
   * - {@link emissionParticleCountMax}
   */
  emissionParticleCountMin: number
  /**
   * The maximum number of particles to emit per emission. A new random value is picked for each emission, and the random value is added to the {@link emissionParticleCount base emission particle count}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionParticleCount}
   * - {@link emissionParticleCountMin}
   */
  emissionParticleCountMax: number
  /**
   * The time between emissions in seconds. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionIntervalMin}
   * - {@link emissionIntervalMax}
   */
  emissionInterval: number
  /**
   * The minimum time between emissions in seconds. A random value between this and {@link emissionIntervalMax} will be added to {@link emissionInterval} to get the final emission interval. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionInterval}
   * - {@link emissionIntervalMax}
   */
  emissionIntervalMin: number
  /**
   * The maximum time between emissions in seconds. A random value between this and {@link emissionIntervalMin} will be added to {@link emissionInterval} to get the final emission interval. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link emissionInterval}
   * - {@link emissionIntervalMin}
   */
  emissionIntervalMax: number
  /**
   * If enabled, the number of emissions will be limited by {@link concurrentEmissionsLimit}.
   * 
   * **Default**: `false`
   */
  limitConcurrentEmissions: boolean
  /**
   * The total number of emissions. This limit is only applied if {@link limitConcurrentEmissions} is enabled.
   * 
   * **Default**: `0`
   */
  concurrentEmissionsLimit: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_26: number
  /**
   * The duration of each particle in seconds. Due to the way this field works, the value will be rounded to the nearest 1/30s.
   * 
   * **Default**: `1`
   */
  particleDuration: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_29: number
  /**
   * Particle position offset.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link particleOffsetMin}
   * - {@link particleOffsetMax}
   */
  particleOffset: Vector3
  /**
   * Minimum particle position offset. A random value between this and {@link particleOffsetMax} will be added to {@link particleOffset} to get the final position offset.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleOffsetMin: Vector3
  /**
   * Maximum particle position offset. A random value between this and {@link particleOffsetMin} will be added to {@link particleOffset} to get the final position offset.
   * 
   * **Default**: `[0, 0, 0]`
   */
  particleOffsetMax: Vector3
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_39: number
  /**
   * Minimum particle speed.
   * 
   * **Default**: `[-0.01, -0.01, -0.01]`
   * 
   * See also:
   * - {@link particleSpeedMax}
   */
  particleSpeedMin: Vector3
  /**
   * Maximum particle speed.
   * 
   * **Default**: `[0.01, 0.01, 0.01]`
   * 
   * See also:
   * - {@link particleSpeedMin}
   */
  particleSpeedMax: Vector3
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   */
  rgbMultiplier: number
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   */
  alphaMultiplier: number
  /**
   * Minimum random variation for the particle color. A random value between this and {@link colorMax} will be added to the base {@link color}, but it fades out over the life of the particle.
   * 
   * **Default**: `[0, 0, 0, 0]`
   */
  colorMin: Vector4
  /**
   * Maximum random variation for the particle color. A random value between this and {@link colorMin} will be added to the base {@link color}, but it fades out over the life of the particle.
   * 
   * **Default**: `[0, 0, 0, 0]`
   */
  colorMax: Vector4
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Add}
   */
  blendMode: BlendMode
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_57: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_58: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_59: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_60: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_61: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_62: number
  /**
   * Minimum particle length. A random value between this and {@link particleLengthMax} will be **multiplied** by {@link particleLength} to get the final particle length.
   * 
   * **Default**: `1`
   */
  particleLengthMin: number
  /**
   * Maximum particle length. A random value between this and {@link particleLengthMin} will be **multiplied** by {@link particleLength} to get the final particle length.
   * 
   * **Default**: `1`
   */
  particleLengthMax: number
  /**
   * Minimum particle width. A random value between this and {@link particleWidthMax} will be **multiplied** by {@link particleWidth} to get the final particle width.
   * 
   * **Default**: `1`
   */
  particleWidthMin: number
  /**
   * Maximum particle width. A random value between this and {@link particleWidthMin} will be **multiplied** by {@link particleWidth} to get the final particle width.
   * 
   * **Default**: `1`
   */
  particleWidthMax: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_67: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_68: number
  /**
   * Multiplier for {@link particleDuration}.
   * 
   * **Default**: `1`
   */
  particleDurationMultiplier: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_70: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_71: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_72: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_73: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_74: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_75: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_76: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_77: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_78: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_79: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_80: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_81: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_82: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_83: number
  /**
   * Unknown float. Seems to make the particles fly around somewhat randomly, but with a specific average direction. {@link unk_ac6_f1_85} works in a similar way, but has the opposite average direction.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_84: number
  /**
   * Unknown float. Seems to make the particles fly around somewhat randomly, but with a specific average direction. {@link unk_ac6_f1_84} works in a similar way, but has the opposite average direction.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_85: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_86: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ac6_f1_87: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_88: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_89: number
  /**
   * If enabled, the particle system stops updating if the camera is beyond the distance specified by {@link updateDistance} from the node.
   * 
   * It will not stop updating immediately after the action becomes active. Instead, it will wait for a little while before stopping if the camera is too far away.
   * 
   * **Default**: `false`
   */
  limitUpdateDistance: boolean
  /**
   * Controls how close the camera needs to be to the node for the particle system to update. Requires {@link limitUpdateDistance} to be enabled.
   * 
   * **Default**: `0`
   */
  updateDistance: number
  /**
   * When enabled, this makes the particles bounce off of any surface they hit. This collision detection is just based on the depth buffer, not the full 3D scene, so it is not always perfect.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link particleBounciness}
   */
  particleCollision: boolean
  /**
   * Controls how strong the rebound from hitting a surface is when {@link particleCollision} is enabled.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link particleCollision}
   */
  particleBounciness: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_94: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_95: number
  /**
   * Controls whether or not the particles have a bloom effect.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_101: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_102: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_103: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ac6_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_4: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f2_5: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f2_6: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f2_7: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ac6_f2_8: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_13: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ac6_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_28: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_29: number
  /**
   * Controls how dark shaded parts of the particle are.
   * 
   * **Default**: `1`
   */
  shadowDarkness: number
  /**
   * When set to 1, this stops the particles from being shown indoors.
   * 
   * Other values are used in AC6, but what they do is unknown.
   * 
   * **Default**: `0`
   */
  unkHideIndoors: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_33: number
  /**
   * Unknown float.
   * 
   * **Default**: `0.5`
   */
  unk_ac6_f2_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  lighting: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_ac6_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_37: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_38: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_39: number
  constructor(props: Partial<Props<GPUSparkCorrectParticle>> = {}) {
    super(ActionType.GPUSparkCorrectParticle)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.Tracer Action 10012 - Tracer}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Creates a trail behind moving effects.
 * 
 * This is a newer version of {@link LegacyTracer} with more features, like being able to make the opacity of the trail be based on the movement speed of the particle.
 */
class Tracer extends DataAction {
  declare readonly type: ActionType.Tracer
  /**
   * Texture ID.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  texture: ScalarValue
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Normal}
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  blendMode: BlendMode | ScalarProperty
  /**
   * The width of the trail.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  width: ScalarValue
  /**
   * Multiplier for {@link width}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   */
  widthMultiplier: ScalarValue
  /**
   * Percentage along the trail from the start of the trail where the trail's opacity will start fading out towards the start. The trail will have 0 opacity at the start, and it will linearly increase towards full opacity at the point represented by this percentage.
   * 
   * The percentage is of the way from the start of the trail to the end of it, so if the trail gets longer or shorter, this point will move with it.
   * 
   * Values greater than 100 will make the trail never reach full opacity. For example, a value of 200 will make the trail fade from 0 opacity at the start to 50% (100% / 200%) at the end of the trail.
   * 
   * If this value and {@link endFadeEndpoint} sum to a value greater than 100, the trail will be "split" at the point controlled by this value and each part will fade separately based on the repsective value. For example, if this is set to 50 and {@link endFadeEndpoint} is 1000, the first half of the trail will fade normally from 0 opacity at the start to full opacity at the mid point, but the other half will fade from 5% opacity ((100% - 50%) / 1000%) at the mid point to 0 at the end. Where the two parts meet, the opacity will fade from one to the other across a single segment of the trail.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  startFadeEndpoint: ScalarValue
  /**
   * Percentage along the trail from the end of the trail where the trail's opacity will start fading out towards the end. The trail will have full opacity at the point represented by this percentage, and it will linearly decrease towards 0 opacity at the end.
   * 
   * The percentage is of the way from the end of the trail to the start of it, so if the trail gets longer or shorter, this point will move with it.
   * 
   * Values greater than 100 will make the trail never reach full opacity. For example, a value of 200 will make the trail fade from 0 opacity at the end to 50% (100% / 200%) at the start of the trail.
   * 
   * If this value and {@link startFadeEndpoint} sum to a value greater than 100, the trail will be "split" at the point controlled by {@link startFadeEndpoint} and each part will fade separately based on the repsective value. For example, if {@link startFadeEndpoint} is set to 50 and this is 1000, the first half of the trail will fade normally from 0 opacity at the start to full opacity at the mid point, but the other half will fade from 5% opacity ((100% - 50%) / 1000%) at the mid point to 0 at the end. Where the two parts meet, the opacity will fade from one to the other across a single segment of the trail.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  endFadeEndpoint: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link color3}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color2}
   * - {@link color3}
   */
  color1: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. There is no equivalent property with unrestricted values based on the emission time of the particle, but {@link color3} is still multiplicative with this and can be used to scale the values indirectly.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color3}
   */
  color2: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this are unrestricted and can go above 1. If you want values to be clamped to the 0-1 range, see {@link color1}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   */
  color3: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * Values above this threshold will be stretched to fill the alpha range, so values near the threshold will be less visible, creating a smooth transition between the parts that have been hidden by the threshold and the ones that are still visible.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  alphaFadeThreshold: ScalarValue
  /**
   * The index of the frame to show from the texture atlas. Can be animated using a {@link PropertyFunction.Linear linear property} or similar.
   * 
   * Seemingly identical to {@link frameIndexOffset}? The sum of these two properties is the actual frame index that gets used.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  frameIndex: ScalarValue
  /**
   * Seemingly identical to {@link frameIndex}? The sum of these two properties is the actual frame index that gets used.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  frameIndexOffset: ScalarValue
  /**
   * Controls how much of the texture's width is used per segment. If {@link attachedUV} is enabled, this instead controls how much of the texture's width to use for the entire trail.
   * 
   * **Default**: `0.1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  textureFraction: ScalarValue
  /**
   * Controls how fast the UV coordinates should move horizontally.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speedU: ScalarValue
  /**
   * Controls how much the UV coordinates should be randomly offset by per segment.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  varianceV: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `-1`
   */
  unk_ds3_p1_13: ScalarValue
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Controls the intensity of the distortion effect. At 0, there is no distortion at all.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link normalMap}
   */
  distortionIntensity: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_ds3_p2_5: Vector4Value
  /**
   * Parts of the particle with less opacity than this threshold will be invisible. The range is 0-255.
   * 
   * This threshold creates a hard cut-off between visible and not visible, which is unlike the {@link alphaFadeThreshold}.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaThreshold: ScalarValue
  /**
   * Tracer orientation mode. See {@link TracerOrientationMode} for more information.
   * 
   * **Default**: {@link TracerOrientationMode.LocalZ}
   */
  orientation: TracerOrientationMode
  /**
   * Normal map texture ID.
   * 
   * This is used to control the distortion effect of the trail.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link distortionIntensity}
   */
  normalMap: number
  /**
   * The trail is made up of multiple quads, or *segments*. This controls how many seconds to wait between new segments being created. Lower values produce a smoother trail.
   * 
   * **Default**: `0`
   */
  segmentInterval: number
  /**
   * The trail is made up of multiple quads, or *segments*. This controls how long each segment should last in seconds.
   * 
   * **Default**: `1`
   */
  segmentDuration: number
  /**
   * The trail is made up of multiple quads, or *segments*. This controls how many segments may exist at the same time.
   * 
   * **Default**: `100`
   */
  concurrentSegments: number
  /**
   * The trail is made up of multiple quads, or *segments*. This controls how many times each completed segment should be subdivided. Higher values makes the trail look smoother.
   * 
   * A "completed" segment is any segment that is not the leading one. The leading segment has one side attached to the end of the previous segment and the other attached to the tracer source, and is always a simple quad.
   * 
   * **Default**: `0`
   */
  segmentSubdivision: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_8: number
  /**
   * When the particle is meant to terminate, the trail will linger for this many seconds and its opacity will fade to 0 in that time.
   * 
   * **Default**: `0`
   */
  fadeOutTime: number
  /**
   * To split the texture into multiple animation frames, this value must be set to the number of columns in the texture. It should equal `textureWidth / frameWidth`.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link totalFrames}
   */
  columns: number
  /**
   * To split the texture into multiple animation frames, this value must be set to the total number of frames in the texture.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link columns}
   */
  totalFrames: number
  /**
   * Controls whether or not the UV of the trail should be attached to the node or not. If it is attached, the texture will slide along the segments to follow the source wherever it moves, as if it was a flag attached to a pole. If it is not attached, the texture will stay where it was when the segment was created, like a skid mark on a road where the road is the segments and the mark is the texture, it wouldn't follow the car/node that made it.
   * 
   * **Default**: `true`
   */
  attachedUV: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_13: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_15: number
  /**
   * When `true`, this will cause the trail's opacity to be based on the speed it's moving at. This dynamic opacity is per-segment, so each segment will remember what speed the tracer source had when the segment was created.
   * 
   * **Default**: `false`
   */
  dynamicOpacity: boolean
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_15: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_16: number
  /**
   * Maximum random horizontal offset for the UV.
   * 
   * **Default**: `0`
   */
  varianceU: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_20: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_er_f1_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_0: number
  /**
   * Unknown integer. Possibly boolean?
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_ds3_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_3: number
  /**
   * Controls whether or not the particles have an additional bloom effect controlled by {@link bloomColor}.
   * 
   * When enabled, this also allows bloom from other particles to be seen through this particle.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link bloomColor}
   */
  bloom: boolean
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   */
  bloomColor: Vector4
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_28: number
  /**
   * Unknown float.
   * 
   * This seems to be some sort of distance threshold. When the camera is within this distance, some things will look different in some ways. For example, when within the distance and the {@link blendMode blend mode} is set to {@link BlendMode.Subtract}, the opacity doesn't work the way it normally does. Other effects have been found as well, but what exactly this threshold is for is unknown.
   * 
   * **Default**: `0`
   */
  unk_ds3_f2_29: number
  /**
   * Controls how dark shaded parts of the trail are.
   * 
   * **Default**: `0`
   */
  shadowDarkness: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_31: number
  /**
   * Unknown boolean.
   * 
   * When enabled, it seems to stop {@link unk_ds3_f2_29} from doing whatever it is doing, and it can also cause some ugly "outline" effects on things seen through particles, but it also fixes an issue where some other particles can be seen through this particle.
   * 
   * **Default**: `false`
   */
  unk_sdt_f2_32: boolean
  /**
   * Specular texture ID.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link lighting}
   * - {@link glossiness}
   * - {@link specularity}
   */
  specular: number
  /**
   * Controls how sharp the specular highlights are.
   * 
   * **Default**: `0.25`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   * - {@link specularity}
   */
  glossiness: number
  /**
   * Controls how the trail is lit. See {@link LightingMode} for more information.
   * 
   * **Default**: `-1`
   */
  lighting: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_sdt_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f2_37: number
  /**
   * Controls how bright the specular highlights are.
   * 
   * **Default**: `0.5`
   * 
   * See also:
   * - {@link lighting}
   * - {@link specular}
   * - {@link glossiness}
   */
  specularity: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_39: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_er_f2_40: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f2_41: number
  constructor(props: Partial<Props<Tracer>> = {}) {
    super(ActionType.Tracer)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.WaterInteraction Action 10013 - WaterInteraction}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Simulates an interaction with water, allowing effects to create ripples in nearby water. The interaction basically pushes water in a shape controlled by a texture down to a given depth and holds it there for a duration before releasing it.
 */
class WaterInteraction extends DataAction {
  declare readonly type: ActionType.WaterInteraction
  /**
   * The ID for a texture that controls the shape of the interaction.
   * 
   * **Default**: `50004`
   */
  texture: number
  /**
   * Controls how deep to push the water, or how intense the ripples caused by the interaction are.
   * 
   * **Default**: `1`
   */
  depth: number
  /**
   * Controls the size of the interaction area. Ripples caused by the interaction may go outside of the area.
   * 
   * **Default**: `1`
   */
  size: number
  /**
   * The time it takes for the water to be pushed down to the {@link depth} in seconds.
   * 
   * **Default**: `0.15`
   */
  descent: number
  /**
   * The duration of the interaction in seconds. Basically how long to hold the water pressed down.
   * 
   * **Default**: `0.15`
   */
  duration: number
  constructor(props: Partial<Props<WaterInteraction>> = {}) {
    super(ActionType.WaterInteraction)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.LensFlare Action 10014 - LensFlare}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Creates lens flares with up to 4 textured layers with different colors and sizes.
 */
class LensFlare extends DataAction {
  declare readonly type: ActionType.LensFlare
  /**
   * Layer 1 width.
   * 
   * **Default**: `1`
   */
  layer1Width: ScalarValue
  /**
   * Layer 1 height.
   * 
   * **Default**: `1`
   */
  layer1Height: ScalarValue
  /**
   * Layer 1 color.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link layer1ColorMultiplier}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * See also:
   * - {@link layer1ColorMultiplier}
   */
  layer1Color: Vector4Value
  /**
   * Layer 2 width.
   * 
   * **Default**: `1`
   */
  layer2Width: ScalarValue
  /**
   * Layer 2 height.
   * 
   * **Default**: `1`
   */
  layer2Height: ScalarValue
  /**
   * Layer 2 color.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link layer2ColorMultiplier}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * See also:
   * - {@link layer2ColorMultiplier}
   */
  layer2Color: Vector4Value
  /**
   * Layer 3 width.
   * 
   * **Default**: `1`
   */
  layer3Width: ScalarValue
  /**
   * Layer 3 height.
   * 
   * **Default**: `1`
   */
  layer3Height: ScalarValue
  /**
   * Layer 3 color.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link layer3ColorMultiplier}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * See also:
   * - {@link layer3ColorMultiplier}
   */
  layer3Color: Vector4Value
  /**
   * Layer 4 width.
   * 
   * **Default**: `1`
   */
  layer4Width: ScalarValue
  /**
   * Layer 4 height.
   * 
   * **Default**: `1`
   */
  layer4Height: ScalarValue
  /**
   * Layer 4 color.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link layer4ColorMultiplier}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * See also:
   * - {@link layer4ColorMultiplier}
   */
  layer4Color: Vector4Value
  /**
   * Layer 1 texture ID.
   * 
   * **Default**: `1`
   */
  layer1: number
  /**
   * Layer 2 texture ID.
   * 
   * **Default**: `0`
   */
  layer2: number
  /**
   * Layer 3 texture ID.
   * 
   * **Default**: `0`
   */
  layer3: number
  /**
   * Layer 4 texture ID.
   * 
   * This layer seems to work a bit differently from the others in Sekiro.
   * 
   * **Default**: `0`
   */
  layer4: number
  /**
   * Blend mode.
   * 
   * **Default**: {@link BlendMode.Add}
   */
  blendMode: BlendMode
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_4: number
  /**
   * Diameter of the lens flare source sphere.
   * 
   * The opacity of the lens flare depends on how much of the source is in view.
   * 
   * **Default**: `1`
   */
  sourceSize: number
  /**
   * The time in seconds it takes for the opacity of the lens flare to transition when the source comes more into or goes more out of view.
   * 
   * **Default**: `1`
   */
  opacityTransitionDuration: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_8: number
  /**
   * The number of flares to create from {@link layer1}. Unless given {@link layer1OffsetVariation random offsets}, they will all just stack on top of each other in the same spot.
   * 
   * Setting it to very high values can have a significant impact on performance.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer1ScaleVariationX}
   * - {@link layer1ScaleVariationY}
   * - {@link layer1Reflection}
   * - {@link layer1Offset}
   * - {@link layer1OffsetVariation}
   */
  layer1Count: number
  /**
   * The {@link layer1Width width} of {@link layer1Count each flare} is multiplied by a random value between this and 1.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer1Count}
   * - {@link layer1UniformScale}
   * - {@link layer1ScaleVariationY}
   */
  layer1ScaleVariationX: number
  /**
   * The {@link layer1Height height} of {@link layer1Count each flare} is multiplied by a random value between this and 1.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer1Count}
   * - {@link layer1UniformScale}
   * - {@link layer1ScaleVariationX}
   */
  layer1ScaleVariationY: number
  /**
   * When enabled, the {@link layer1Width layer's width} also controls the {@link layer1Height height}, and the height property is ignored. The same is also true for the scale variation fields.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link layer1Width}
   * - {@link layer1Height}
   * - {@link layer1ScaleVariationX}
   * - {@link layer1ScaleVariationX}
   */
  layer1UniformScale: boolean
  /**
   * Multiplier for the {@link layer1Color layer's color}.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * See also:
   * - {@link layer1Color}
   */
  layer1ColorMultiplier: Vector4
  /**
   * Controls how the offset vector is calculated for {@link layer1}. See {@link ReflectionMode} for more details.
   * 
   * **Default**: {@link ReflectionMode.None}
   * 
   * See also:
   * - {@link layer1Offset}
   * - {@link layer1OffsetVariation}
   */
  layer1Reflection: number
  /**
   * Controls where the lens flare(s) from {@link layer1} will appear on the screen relative to the source and the center of the screen.
   * 
   * This is basically a scalar multiplier for the {@link layer1Reflection offset vector}.
   * 
   * This requires {@link layer1Reflection} to not be set to {@link ReflectionMode.None}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link layer1Reflection}
   * - {@link layer1OffsetVariation}
   * - {@link layer1AttenuationRadius}
   */
  layer1Offset: number
  /**
   * For {@link layer1Count each flare} of {@link layer1}, a random number is picked between this value and 1, and this random number is then multiplied with {@link layer1Offset} to get the final offset for the flare.
   * 
   * This requires {@link layer1Reflection} to not be set to {@link ReflectionMode.None}.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer1Reflection}
   * - {@link layer1Offset}
   */
  layer1OffsetVariation: number
  /**
   * This controls the radius of a sphere around the source for {@link layer1}. {@link layer1Count Each flare} has its own radius, which calculated by dividing this radius by the absolute value of the flare's {@link layer1Offset offset}. If the center of the screen is not within the projection of this sphere on the screen, the flare will not be visible, and it fades out gradually as the center of the screen moves from within the sphere to outside it.
   * In other words, this fades out flares based on their offset and the distance from the source to the center of the screen, which means it's harder to see flares farther away from the source, and if the source is far away from the center of the screen.
   * Can be set to -1 to disable this limit and always display the flare(s).
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link layer1Reflection}
   * - {@link layer1Offset}
   * - {@link layer1OffsetVariation}
   */
  layer1AttenuationRadius: number
  /**
   * The number of flares to create from {@link layer2}. Unless given {@link layer2OffsetVariation random offsets}, they will all just stack on top of each other in the same spot.
   * 
   * Setting it to very high values can have a significant impact on performance.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer2ScaleVariationX}
   * - {@link layer2ScaleVariationY}
   * - {@link layer2Reflection}
   * - {@link layer2Offset}
   * - {@link layer2OffsetVariation}
   */
  layer2Count: number
  /**
   * The {@link layer2Width width} of {@link layer2Count each flare} is multiplied by a random value between this and 1.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer2Count}
   * - {@link layer2UniformScale}
   * - {@link layer2ScaleVariationY}
   */
  layer2ScaleVariationX: number
  /**
   * The {@link layer2Height height} of {@link layer2Count each flare} is multiplied by a random value between this and 1.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer2Count}
   * - {@link layer2UniformScale}
   * - {@link layer2ScaleVariationX}
   */
  layer2ScaleVariationY: number
  /**
   * When enabled, the {@link layer2Width layer's width} also controls the {@link layer2Height height}, and the height property is ignored. The same is also true for the scale variation fields.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link layer2Width}
   * - {@link layer2Height}
   * - {@link layer2ScaleVariationX}
   * - {@link layer2ScaleVariationX}
   */
  layer2UniformScale: boolean
  /**
   * Multiplier for the {@link layer2Color layer's color}.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * See also:
   * - {@link layer2Color}
   */
  layer2ColorMultiplier: Vector4
  /**
   * Controls how the offset vector is calculated for {@link layer2}. See {@link ReflectionMode} for more details.
   * 
   * **Default**: {@link ReflectionMode.None}
   * 
   * See also:
   * - {@link layer2Offset}
   * - {@link layer2OffsetVariation}
   */
  layer2Reflection: number
  /**
   * Controls where the lens flare(s) from {@link layer2} will appear on the screen relative to the source and the center of the screen.
   * 
   * This is basically a scalar multiplier for the {@link layer2Reflection offset vector}.
   * 
   * This requires {@link layer2Reflection} to not be set to {@link ReflectionMode.None}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link layer2Reflection}
   * - {@link layer2OffsetVariation}
   * - {@link layer2AttenuationRadius}
   */
  layer2Offset: number
  /**
   * For {@link layer2Count each flare} of {@link layer2}, a random number is picked between this value and 1, and this random number is then multiplied with {@link layer2Offset} to get the final offset for the flare.
   * 
   * This requires {@link layer2Reflection} to not be set to {@link ReflectionMode.None}.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer2Reflection}
   * - {@link layer2Offset}
   */
  layer2OffsetVariation: number
  /**
   * This controls the radius of a sphere around the source for {@link layer2}. {@link layer2Count Each flare} has its own radius, which calculated by dividing this radius by the absolute value of the flare's {@link layer2Offset offset}. If the center of the screen is not within the projection of this sphere on the screen, the flare will not be visible, and it fades out gradually as the center of the screen moves from within the sphere to outside it.
   * In other words, this fades out flares based on their offset and the distance from the source to the center of the screen, which means it's harder to see flares farther away from the source, and if the source is far away from the center of the screen.
   * Can be set to -1 to disable this limit and always display the flare(s).
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link layer2Reflection}
   * - {@link layer2Offset}
   * - {@link layer2OffsetVariation}
   */
  layer2AttenuationRadius: number
  /**
   * The number of flares to create from {@link layer3}. Unless given {@link layer3OffsetVariation random offsets}, they will all just stack on top of each other in the same spot.
   * 
   * Setting it to very high values can have a significant impact on performance.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer3ScaleVariationX}
   * - {@link layer3ScaleVariationY}
   * - {@link layer3Reflection}
   * - {@link layer3Offset}
   * - {@link layer3OffsetVariation}
   */
  layer3Count: number
  /**
   * The {@link layer3Width width} of {@link layer3Count each flare} is multiplied by a random value between this and 1.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer3Count}
   * - {@link layer3UniformScale}
   * - {@link layer3ScaleVariationY}
   */
  layer3ScaleVariationX: number
  /**
   * The {@link layer3Height height} of {@link layer3Count each flare} is multiplied by a random value between this and 1.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer3Count}
   * - {@link layer3UniformScale}
   * - {@link layer3ScaleVariationX}
   */
  layer3ScaleVariationY: number
  /**
   * When enabled, the {@link layer3Width layer's width} also controls the {@link layer3Height height}, and the height property is ignored. The same is also true for the scale variation fields.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link layer3Width}
   * - {@link layer3Height}
   * - {@link layer3ScaleVariationX}
   * - {@link layer3ScaleVariationX}
   */
  layer3UniformScale: boolean
  /**
   * Multiplier for the {@link layer3Color layer's color}.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * See also:
   * - {@link layer3Color}
   */
  layer3ColorMultiplier: Vector4
  /**
   * Controls how the offset vector is calculated for {@link layer3}. See {@link ReflectionMode} for more details.
   * 
   * **Default**: {@link ReflectionMode.None}
   * 
   * See also:
   * - {@link layer3Offset}
   * - {@link layer3OffsetVariation}
   */
  layer3Reflection: number
  /**
   * Controls where the lens flare(s) from {@link layer3} will appear on the screen relative to the source and the center of the screen.
   * 
   * This is basically a scalar multiplier for the {@link layer3Reflection offset vector}.
   * 
   * This requires {@link layer3Reflection} to not be set to {@link ReflectionMode.None}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link layer3Reflection}
   * - {@link layer3OffsetVariation}
   * - {@link layer3AttenuationRadius}
   */
  layer3Offset: number
  /**
   * For {@link layer3Count each flare} of {@link layer3}, a random number is picked between this value and 1, and this random number is then multiplied with {@link layer3Offset} to get the final offset for the flare.
   * 
   * This requires {@link layer3Reflection} to not be set to {@link ReflectionMode.None}.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer3Reflection}
   * - {@link layer3Offset}
   */
  layer3OffsetVariation: number
  /**
   * This controls the radius of a sphere around the source for {@link layer3}. {@link layer3Count Each flare} has its own radius, which calculated by dividing this radius by the absolute value of the flare's {@link layer3Offset offset}. If the center of the screen is not within the projection of this sphere on the screen, the flare will not be visible, and it fades out gradually as the center of the screen moves from within the sphere to outside it.
   * In other words, this fades out flares based on their offset and the distance from the source to the center of the screen, which means it's harder to see flares farther away from the source, and if the source is far away from the center of the screen.
   * Can be set to -1 to disable this limit and always display the flare(s).
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link layer3Reflection}
   * - {@link layer3Offset}
   * - {@link layer3OffsetVariation}
   */
  layer3AttenuationRadius: number
  /**
   * The number of flares to create from {@link layer4}. Unless given {@link layer4OffsetVariation random offsets}, they will all just stack on top of each other in the same spot.
   * 
   * Setting it to very high values can have a significant impact on performance.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer4ScaleVariationX}
   * - {@link layer4ScaleVariationY}
   * - {@link layer4Reflection}
   * - {@link layer4Offset}
   * - {@link layer4OffsetVariation}
   */
  layer4Count: number
  /**
   * The {@link layer4Width width} of {@link layer4Count each flare} is multiplied by a random value between this and 1.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer4Count}
   * - {@link layer4UniformScale}
   * - {@link layer4ScaleVariationY}
   */
  layer4ScaleVariationX: number
  /**
   * The {@link layer4Height height} of {@link layer4Count each flare} is multiplied by a random value between this and 1.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer4Count}
   * - {@link layer4UniformScale}
   * - {@link layer4ScaleVariationX}
   */
  layer4ScaleVariationY: number
  /**
   * When enabled, the {@link layer4Width layer's width} also controls the {@link layer4Height height}, and the height property is ignored. The same is also true for the scale variation fields.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link layer4Width}
   * - {@link layer4Height}
   * - {@link layer4ScaleVariationX}
   * - {@link layer4ScaleVariationX}
   */
  layer4UniformScale: boolean
  /**
   * Multiplier for the {@link layer4Color layer's color}.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * See also:
   * - {@link layer4Color}
   */
  layer4ColorMultiplier: Vector4
  /**
   * Controls how the offset vector is calculated for {@link layer4}. See {@link ReflectionMode} for more details.
   * 
   * **Default**: {@link ReflectionMode.None}
   * 
   * See also:
   * - {@link layer4Offset}
   * - {@link layer4OffsetVariation}
   */
  layer4Reflection: number
  /**
   * Controls where the lens flare(s) from {@link layer4} will appear on the screen relative to the source and the center of the screen.
   * 
   * This is basically a scalar multiplier for the {@link layer4Reflection offset vector}.
   * 
   * This requires {@link layer4Reflection} to not be set to {@link ReflectionMode.None}.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link layer4Reflection}
   * - {@link layer4OffsetVariation}
   * - {@link layer4AttenuationRadius}
   */
  layer4Offset: number
  /**
   * For {@link layer4Count each flare} of {@link layer4}, a random number is picked between this value and 1, and this random number is then multiplied with {@link layer4Offset} to get the final offset for the flare.
   * 
   * This requires {@link layer4Reflection} to not be set to {@link ReflectionMode.None}.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link layer4Reflection}
   * - {@link layer4Offset}
   */
  layer4OffsetVariation: number
  /**
   * This controls the radius of a sphere around the source for {@link layer4}. {@link layer4Count Each flare} has its own radius, which calculated by dividing this radius by the absolute value of the flare's {@link layer4Offset offset}. If the center of the screen is not within the projection of this sphere on the screen, the flare will not be visible, and it fades out gradually as the center of the screen moves from within the sphere to outside it.
   * In other words, this fades out flares based on their offset and the distance from the source to the center of the screen, which means it's harder to see flares farther away from the source, and if the source is far away from the center of the screen.
   * Can be set to -1 to disable this limit and always display the flare(s).
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link layer4Reflection}
   * - {@link layer4Offset}
   * - {@link layer4OffsetVariation}
   */
  layer4AttenuationRadius: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_57: number
  /**
   * When enabled, this allows the lens flare to have a bloom effect.
   * 
   * Does not seem to work in Sekiro.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link layer1BloomColor}
   * - {@link layer2BloomColor}
   * - {@link layer3BloomColor}
   * - {@link layer4BloomColor}
   */
  bloom: boolean
  /**
   * The bloom color for layer 1. This is multiplied with the {@link layer1Color layer's color} to get the final color for the bloom.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   * - {@link layer1Color}
   */
  layer1BloomColor: Vector4
  /**
   * The bloom color for layer 2. This is multiplied with the {@link layer2Color layer's color} to get the final color for the bloom.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   * - {@link layer2Color}
   */
  layer2BloomColor: Vector4
  /**
   * The bloom color for layer 3. This is multiplied with the {@link layer3Color layer's color} to get the final color for the bloom.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   * - {@link layer3Color}
   */
  layer3BloomColor: Vector4
  /**
   * The bloom color for layer 4. This is multiplied with the {@link layer4Color layer's color} to get the final color for the bloom.
   * 
   * **Default**: `[1, 1, 1, 0]`
   * 
   * See also:
   * - {@link bloom}
   * - {@link layer4Color}
   */
  layer4BloomColor: Vector4
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_75: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_76: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_77: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_78: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_79: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_80: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_4: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_5: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_6: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_7: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_8: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_13: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_24: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_25: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_26: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_29: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_30: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_31: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_33: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_er_f2_36: number
  constructor(props: Partial<Props<LensFlare>> = {}) {
    super(ActionType.LensFlare)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.RichModel Action 10015 - RichModel}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Particle with a 3D model. Similar to {@link ActionType.Model Model}, but with some different options.
 * 
 * Some models only work properly with this action and not with the Model action for some unknown reason. A good example of this is the Carian greatsword model in Elden Ring (88300), which gets horribly stretched and distorted when used with the other action, but it works fine with this one.
 * 
 * The name is from Elden Ring's RTTI.
 */
class RichModel extends DataAction {
  declare readonly type: ActionType.RichModel
  /**
   * Model ID.
   * 
   * **Default**: `80201`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   */
  model: ScalarValue
  /**
   * The width of the particle.
   * 
   * If {@link uniformScale} is enabled, this also controls the height and depth.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationX}
   * - {@link sizeY}
   * - {@link sizeZ}
   */
  sizeX: ScalarValue
  /**
   * The height of the particle.
   * 
   * If {@link uniformScale} is enabled, {@link sizeX} also controls the height, and this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationY}
   * - {@link sizeX}
   * - {@link sizeZ}
   */
  sizeY: ScalarValue
  /**
   * The depth of the particle.
   * 
   * If {@link uniformScale} is enabled, {@link sizeX} also controls the depth, and this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link scaleVariationZ}
   * - {@link sizeX}
   * - {@link sizeY}
   */
  sizeZ: ScalarValue
  /**
   * Rotation around the X-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedX}
   * - {@link angularSpeedMultiplierX}
   */
  rotationX: ScalarValue
  /**
   * Rotation around the Y-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedY}
   * - {@link angularSpeedMultiplierY}
   */
  rotationY: ScalarValue
  /**
   * Rotation around the Z-axis in degrees.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link angularSpeedZ}
   * - {@link angularSpeedMultiplierZ}
   */
  rotationZ: ScalarValue
  /**
   * Angular speed around the X-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationX}
   * - {@link angularSpeedMultiplierX}
   */
  angularSpeedX: ScalarValue
  /**
   * Multiplier for {@link angularSpeedX}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationX}
   */
  angularSpeedMultiplierX: ScalarValue
  /**
   * Angular speed around the Y-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationY}
   * - {@link angularSpeedMultiplierY}
   */
  angularSpeedY: ScalarValue
  /**
   * Multiplier for {@link angularSpeedY}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationY}
   */
  angularSpeedMultiplierY: ScalarValue
  /**
   * Angular speed around the Z-axis in degrees per second.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationZ}
   * - {@link angularSpeedMultiplierZ}
   */
  angularSpeedZ: ScalarValue
  /**
   * Multiplier for {@link angularSpeedZ}.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link rotationZ}
   */
  angularSpeedMultiplierZ: ScalarValue
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. To use values outside of this range, see {@link color3}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color2}
   * - {@link color3}
   */
  color1: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this will be clamped to the 0-1 range. There is no equivalent property with unrestricted values based on the emission time of the particle, but {@link color3} is still multiplicative with this and can be used to scale the values indirectly.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.EmissionTime Emission time}
   * 
   * See also:
   * - {@link color1}
   * - {@link color3}
   */
  color2: Vector4Value
  /**
   * Color multiplier.
   * 
   * Values in this are unrestricted and can go above 1. If you want values to be clamped to the 0-1 range, see {@link color1}.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link color1}
   * - {@link color2}
   */
  color3: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_er_p1_16: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_er_p1_17: ScalarValue
  /**
   * Seemingly identical to {@link rgbMultiplier}?
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier2: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_er_p1_19: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_er_p1_20: ScalarValue
  /**
   * Offset for the UV coordinates of the model.
   * 
   * **Default**: `[0, 0]`
   * 
   * **Argument**: {@link PropertyArgument.Constant0 Constant 0}
   * 
   * See also:
   * - {@link speedUV}
   */
  offsetUV: Vector2Value
  /**
   * Scroll speed for the model's texture.
   * 
   * **Default**: `[0, 0]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   * 
   * See also:
   * - {@link speedMultiplierUV}
   */
  speedUV: Vector2Value
  /**
   * Multiplier for {@link speedUV}
   * 
   * **Default**: `[1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ParticleAge Particle age}
   */
  speedMultiplierUV: Vector2Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_24: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_25: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_26: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_27: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_28: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_29: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_30: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_31: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_32: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_33: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_34: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_35: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_36: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_37: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_38: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_39: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_40: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_41: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_42: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_nr_p1_43: ScalarValue
  /**
   * Scalar multiplier for the color that does not affect the alpha. Effectively a brightness multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rgbMultiplier: ScalarValue
  /**
   * Alpha multiplier.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  alphaMultiplier: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_er_p2_2: ScalarValue
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_er_p2_3: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_er_p2_4: Vector4Value
  /**
   * Unknown vector4.
   * 
   * **Default**: `[1, 1, 1, 1]`
   */
  unk_er_p2_5: Vector4Value
  /**
   * Unknown scalar.
   * 
   * **Default**: `0`
   */
  unk_er_p2_6: ScalarValue
  /**
   * Rich model orientation mode. See {@link RichModelOrientationMode} for more information.
   * 
   * **Default**: {@link RichModelOrientationMode.ParticleDirection}
   */
  orientation: RichModelOrientationMode
  /**
   * Each particle will pick a random number between this value and 1, and the width of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly thinner, down to half width. Setting it to 2 will make them randomly wider, up to double width.
   * 
   * If {@link uniformScale} is enabled, this also affects the height.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationY}
   * - {@link scaleVariationZ}
   */
  scaleVariationX: number
  /**
   * Each particle will pick a random number between this value and 1, and the height of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly shorter, down to half height. Setting it to 2 will make them randomly taller, up to double height.
   * 
   * If {@link uniformScale} is enabled, {@link scaleVariationX} also affects the height, and this field is ignored.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationX}
   * - {@link scaleVariationZ}
   */
  scaleVariationY: number
  /**
   * Each particle will pick a random number between this value and 1, and the depth of the particle will be multiplied by this number. For example, setting this to 0.5 will make the particles randomly shallower, down to half depth. Setting it to 2 will make them randomly deeper, up to double depth. 
   * 
   * If {@link uniformScale} is enabled, {@link scaleVariationX} also affects the depth, and this field is ignored.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link scaleVariationX}
   * - {@link scaleVariationY}
   */
  scaleVariationZ: number
  /**
   * If enabled, the particle X scale-related properties and fields will control the scale in all axes, and the Y and Z counterparts will be ignored.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link sizeX}
   * - {@link sizeY}
   * - {@link sizeZ}
   * - {@link scaleVariationX}
   * - {@link scaleVariationY}
   * - {@link scaleVariationZ}
   */
  uniformScale: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_5: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_6: number
  /**
   * If enabled, this allows control of the model's opacity regardless of its material by using dithered transparency. If disabled, changes to the alpha values that affect the particle will not have any effect unless the material allows it, but it will look better than the dithered transparency.
   * 
   * **Default**: `false`
   */
  dither: boolean
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_er_f1_8: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_er_f1_9: number
  /**
   * Anibnd ID.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link animation}
   * - {@link loopAnimation}
   * - {@link animationSpeed}
   */
  anibnd: number
  /**
   * Controls which animation in the {@link anibnd} to play.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link anibnd}
   * - {@link loopAnimation}
   * - {@link animationSpeed}
   */
  animation: number
  /**
   * If disabled, the {@link animation} will only play once and then freeze on the last frame. If enabled, the animation will loop.
   * 
   * **Default**: `true`
   * 
   * See also:
   * - {@link anibnd}
   * - {@link animation}
   * - {@link animationSpeed}
   */
  loopAnimation: boolean
  /**
   * Controls the speed at which the {@link animation} plays.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link anibnd}
   * - {@link animation}
   * - {@link loopAnimation}
   */
  animationSpeed: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_er_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_22: number
  /**
   * Unknown integer.
   * 
   * This is somewhat similar to the `blendMode` property of other appearance actions, but the values do not match the ones in {@link BlendMode}.
   * 
   * **Default**: `0`
   */
  unkBlendMode: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_25: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_26: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_27: number
  /**
   * Unknown float.
   * 
   * **Default**: `-1`
   */
  unk_ac6_f1_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_29: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_30: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_31: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ac6_f1_33: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ac6_f1_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_37: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_38: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_39: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_40: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_41: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_42: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_43: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_44: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_45: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_46: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_47: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_48: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_49: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_50: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_51: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_52: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_53: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_54: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_er_f1_24: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_25: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `8`
   */
  unk_er_f2_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_3: number
  /**
   * Controls the color of the additional bloom effect. The colors of the particle will be multiplied with this color to get the final color of the bloom effect.
   * 
   * Note:
   * - This has no effect if the "Effects Quality" setting is set to "Low".
   * - This does not affect the natural bloom effect from high color values.
   * 
   * **Default**: `[1, 1, 1, 0]`
   */
  bloomColor: Vector4
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_8: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_13: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link minDistance minimum view distance}. At {@link minDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link minDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minFadeDistance: number
  /**
   * Minimum view distance. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link minFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link minDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  minDistance: number
  /**
   * This controls a point where the opacity of a particle will start to fade to 0 near the {@link maxDistance maximum view distance}. At {@link maxDistance}, the opacity will be 0, and it will linearly approach 1 as the distance between the camera and the particle approaches this distance.
   * 
   * This requires {@link maxDistance} to be set to a positive value or 0. This distance limit can be disabled by setting this and minDistance to -1.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxFadeDistance: number
  /**
   * Minimum view distance. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * This requires {@link maxFadeDistance} to be set to a positive value or 0.
   * 
   * This is different from {@link maxDistanceThreshold}, as this controls the start of a distance range that has smooth transitions at each end, while the threshold value is a hard cut-off.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link minDistanceThreshold}
   * - {@link maxDistanceThreshold}
   */
  maxDistance: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is closer than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link maxDistanceThreshold}
   */
  minDistanceThreshold: number
  /**
   * A hard cut-off point for the distance between the camera and the particle. If a particle is farther away than this distance from the camera, it will be hidden. Can be set to -1 to disable the limit.
   * 
   * **Default**: `-1`
   * 
   * See also:
   * - {@link minFadeDistance}
   * - {@link minDistance}
   * - {@link maxFadeDistance}
   * - {@link maxDistance}
   * - {@link minDistanceThreshold}
   */
  maxDistanceThreshold: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unkDepthBlend1: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unkDepthBlend2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f2_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_29: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_30: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_er_f2_31: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_33: number
  /**
   * Unknown float.
   * 
   * **Default**: `0.5`
   */
  unk_er_f2_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_er_f2_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-2`
   */
  unk_er_f2_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f2_37: number
  /**
   * Unknown section10.
   * 
   * **Default**: `[]`
   */
  unk_nr_s10_0: number[]
  /**
   * Unknown section10.
   * 
   * **Default**: `[]`
   */
  unk_nr_s10_1: number[]
  /**
   * Unknown section10.
   * 
   * **Default**: `[]`
   */
  unk_nr_s10_2: number[]
  /**
   * Unknown section10.
   * 
   * **Default**: `[]`
   */
  unk_nr_s10_3: number[]
  constructor(props: Partial<Props<RichModel>> = {}) {
    super(ActionType.RichModel)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.Unk10100 Action 10100 - Unk10100}
 * **Slot**: {@link ActionSlots.Unknown10100Action Unknown10100}
 * 
 * Unknown root node action.
 */
class Unk10100 extends DataAction {
  declare readonly type: ActionType.Unk10100
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_2: number
  /**
   * Unknown integer. The only known thing about this field is that setting it to 0 stops action 10300 from doing anything.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_4: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_5: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_6: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_7: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_8: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_13: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `-1`
   */
  unk_ds3_f1_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_24: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_25: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_26: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_29: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_30: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_31: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_33: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_37: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_38: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_39: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_40: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_41: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_42: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_43: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_44: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_45: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_46: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_47: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_48: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_49: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_50: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_51: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_52: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_53: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_54: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_55: number
  constructor(props: Partial<Props<Unk10100>> = {}) {
    super(ActionType.Unk10100)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.CancelForce Action 10200 - CancelForce}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Cancels all forces in a volume. This includes wind from weather, and forces from the following actions:
 * - {@link ActionType.WindForce WindForce}
 * - {@link ActionType.GravityForce GravityForce}
 * - {@link ActionType.TurbulenceForce TurbulenceForce}
 * 
 * The name of this action is based on Elden Ring's RTTI, where it's called "ForceFieldCancelArea".
 */
class CancelForce extends DataAction {
  declare readonly type: ActionType.CancelForce
  /**
   * The shape of the volume.
   * 
   * Each shape has different fields controlling the size of the volume:
   * | Shape | Fields | Origin |
   * |-|-|-|
   * | {@link ForceVolumeShape.Boundless Boundless} | *n/a* | *n/a* |
   * | {@link ForceVolumeShape.Sphere Sphere} | {@link sphereRadius} | Center of the sphere |
   * | {@link ForceVolumeShape.Box Box} | {@link boxSize} | Center of the box |
   * | {@link ForceVolumeShape.Cylinder Cylinder} | {@link cylinderHeight}, {@link cylinderRadius} | Center of the cylinder |
   * | {@link ForceVolumeShape.SquarePrism SquarePrism} | {@link squarePrismHeight}, {@link squarePrismApothem} | Center of the base of the prism |
   * 
   * **Default**: {@link ForceVolumeShape.Sphere}
   */
  shape: ForceVolumeShape
  /**
   * The radius of the {@link ForceVolumeShape.Sphere sphere} volume.
   * 
   * **Default**: `10`
   * 
   * See also:
   * - {@link shape}
   */
  sphereRadius: number
  /**
   * The size of the {@link ForceVolumeShape.Box box} volume.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link shape}
   */
  boxSize: Vector3
  /**
   * The height of the {@link ForceVolumeShape.Cylinder cylinder} volume.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link cylinderRadius}
   */
  cylinderHeight: number
  /**
   * The radius of the {@link ForceVolumeShape.Cylinder cylinder} volume.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link cylinderHeight}
   */
  cylinderRadius: number
  /**
   * The height of the {@link ForceVolumeShape.SquarePrism square prism} volume.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link squarePrismApothem}
   */
  squarePrismHeight: number
  /**
   * The apothem of the {@link ForceVolumeShape.SquarePrism square prism} volume.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link squarePrismHeight}
   */
  squarePrismApothem: number
  constructor(props: Partial<Props<CancelForce>> = {}) {
    super(ActionType.CancelForce)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.WindForce Action 10300 - WindForce}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Creates a directional force in a volume, which is most often useful for creating wind effects. The direction of the force is based on the direction of the node.
 * 
 * The name of this action is based on Elden Ring's RTTI, where it's called "ForceFieldWindArea".
 */
class WindForce extends DataAction {
  declare readonly type: ActionType.WindForce
  /**
   * The strength of the force applied in the volume.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link forceRandomMultiplierMin}
   * - {@link forceRandomMultiplierMax}
   * - {@link forceMultiplier}
   */
  force: ScalarValue
  /**
   * The shape of the volume.
   * 
   * Each shape has different fields controlling the size of the volume:
   * | Shape | Fields | Origin |
   * |-|-|-|
   * | {@link ForceVolumeShape.Boundless Boundless} | *n/a* | *n/a* |
   * | {@link ForceVolumeShape.Sphere Sphere} | {@link sphereRadius} | Center of the sphere |
   * | {@link ForceVolumeShape.Box Box} | {@link boxSize} | Center of the box |
   * | {@link ForceVolumeShape.Cylinder Cylinder} | {@link cylinderHeight}, {@link cylinderRadius} | Center of the cylinder |
   * | {@link ForceVolumeShape.SquarePrism SquarePrism} | {@link squarePrismHeight}, {@link squarePrismApothem} | Center of the base of the prism |
   * 
   * **Default**: {@link ForceVolumeShape.Sphere}
   */
  shape: ForceVolumeShape
  /**
   * The radius of the {@link ForceVolumeShape.Sphere sphere} where the force is active.
   * 
   * **Default**: `10`
   * 
   * See also:
   * - {@link shape}
   */
  sphereRadius: number
  /**
   * The size of the {@link ForceVolumeShape.Box box} where the force is active.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link shape}
   */
  boxSize: Vector3
  /**
   * The height of the {@link ForceVolumeShape.Cylinder cylinder} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link cylinderRadius}
   */
  cylinderHeight: number
  /**
   * The radius of the {@link ForceVolumeShape.Cylinder cylinder} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link cylinderHeight}
   */
  cylinderRadius: number
  /**
   * The height of the {@link ForceVolumeShape.SquarePrism square prism} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link squarePrismApothem}
   */
  squarePrismHeight: number
  /**
   * The apothem of the {@link ForceVolumeShape.SquarePrism square prism} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link squarePrismHeight}
   */
  squarePrismApothem: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_13: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_25: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_26: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_27: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `30`
   */
  unk_ds3_f1_29: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_30: number
  /**
   * When this is set to 0, the wind will be able to affect sfx, including the one with this action. When it's set to 1, it seems to only affect non-sfx things, like plants and trees.
   * 
   * The way non-sfx are affected by the wind seems to also change a bit between values 0 and 1, but exactly how is unknown.
   * 
   * In DS3 and Sekiro, some effects have this set to 2, so it is not just a boolean. What 2 does is unknown.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_31: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_33: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_34: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_35: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_36: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_37: number
  /**
   * The minimum random multiplier for {@link force}. This multiplier will randomly change to different values in the range defined by this and {@link forceRandomMultiplierMax}.
   * 
   * This is multiplicative with both the base force and the {@link forceMultiplier other multiplier}.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link force}
   * - {@link forceRandomMultiplierMax}
   * - {@link forceMultiplier}
   */
  forceRandomMultiplierMin: number
  /**
   * The maximum random multiplier for {@link force}. This multiplier will randomly change to different values in the range defined by this and {@link forceRandomMultiplierMin}.
   * 
   * This is multiplicative with both the base force and the {@link forceMultiplier other multiplier}.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link force}
   * - {@link forceRandomMultiplierMin}
   * - {@link forceMultiplier}
   */
  forceRandomMultiplierMax: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_40: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_41: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_42: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_44: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_45: number
  /**
   * A multiplier for {@link force}.
   * 
   * This is multiplicative with both the base force and the random multiplier.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link force}
   * - {@link forceRandomMultiplierMin}
   * - {@link forceRandomMultiplierMax}
   */
  forceMultiplier: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_47: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_48: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_48: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_49: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_50: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_51: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_52: number
  /**
   * The time it takes for the force to fade out after the action has deactivated in seconds. Due to the way this value is stored, the time will be rounded to the nearest 1/30s.
   * 
   * **Default**: `0`
   */
  fadeOutTime: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_54: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_55: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_56: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_57: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_sdt_f1_58: number
  /**
   * Unknown float.
   * 
   * **Default**: `10`
   */
  unk_ds3_f1_49: number
  /**
   * Unknown float.
   * 
   * **Default**: `60`
   */
  unk_ds3_f1_50: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_43: number
  constructor(props: Partial<Props<WindForce>> = {}) {
    super(ActionType.WindForce)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.GravityForce Action 10301 - GravityForce}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Creates a radial force in a volume. This pulls things towards itself, or pushes away if the force is negative.
 * 
 * The name of this action is based on Elden Ring's RTTI, where it's called "ForceFieldGravityArea".
 */
class GravityForce extends DataAction {
  declare readonly type: ActionType.GravityForce
  /**
   * The strength of the force applied in the volume.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link forceRandomMultiplierMin}
   * - {@link forceRandomMultiplierMax}
   * - {@link forceMultiplier}
   */
  force: ScalarValue
  /**
   * The shape of the volume.
   * 
   * Each shape has different fields controlling the size of the volume, and they also change where it scales from and what point things are being pulled towards:
   * | Shape | Fields | Origin | Center of mass |
   * |-|-|-|-|
   * | {@link ForceVolumeShape.Boundless Boundless} | *n/a* | *n/a* | Node position |
   * | {@link ForceVolumeShape.Sphere Sphere} | {@link sphereRadius} | Center of the sphere | Center of the sphere |
   * | {@link ForceVolumeShape.Box Box} | {@link boxSize} | Center of the box | Center of the box |
   * | {@link ForceVolumeShape.Cylinder Cylinder} | {@link cylinderHeight}, {@link cylinderRadius} | Slightly +Z of the center of the cylinder? | Slightly +Z of the origin? |
   * | {@link ForceVolumeShape.SquarePrism SquarePrism} | {@link squarePrismHeight}, {@link squarePrismApothem} | Center of the base of the prism | Center of the prism |
   * 
   * **Default**: {@link ForceVolumeShape.Sphere}
   */
  shape: ForceVolumeShape
  /**
   * The radius of the {@link ForceVolumeShape.Sphere sphere} where the force is active.
   * 
   * **Default**: `10`
   * 
   * See also:
   * - {@link shape}
   */
  sphereRadius: number
  /**
   * The size of the {@link ForceVolumeShape.Box box} where the force is active.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link shape}
   */
  boxSize: Vector3
  /**
   * The height of the {@link ForceVolumeShape.Cylinder cylinder} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link cylinderRadius}
   */
  cylinderHeight: number
  /**
   * The radius of the {@link ForceVolumeShape.Cylinder cylinder} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link cylinderHeight}
   */
  cylinderRadius: number
  /**
   * The height of the {@link ForceVolumeShape.SquarePrism square prism} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link squarePrismApothem}
   */
  squarePrismHeight: number
  /**
   * The apothem of the {@link ForceVolumeShape.SquarePrism square prism} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link squarePrismHeight}
   */
  squarePrismApothem: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_13: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_24: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_25: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_26: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_27: number
  /**
   * The minimum "random" multiplier for {@link force}. This looks very similar to the same set of fields in the {@link ActionType.WindForce WindForce action}, but this one doesn't seem to actually be random. It seems more like it will always just be the average of this and {@link forceRandomMultiplierMax}.
   * 
   * This is multiplicative with both the base force and the {@link forceMultiplier other multiplier}.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link force}
   * - {@link forceRandomMultiplierMax}
   * - {@link forceMultiplier}
   */
  forceRandomMultiplierMin: number
  /**
   * The maximum "random" multiplier for {@link force}. This looks very similar to the same set of fields in the {@link ActionType.WindForce WindForce action}, but this one doesn't seem to actually be random. It seems more like it will always just be the average of this and {@link forceRandomMultiplierMin}.
   * 
   * This is multiplicative with both the base force and the {@link forceMultiplier other multiplier}.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link force}
   * - {@link forceRandomMultiplierMin}
   * - {@link forceMultiplier}
   */
  forceRandomMultiplierMax: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_30: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_31: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_32: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_33: number
  /**
   * Unknown integer.
   * 
   * **Default**: `3`
   */
  unk_ds3_f1_34: number
  /**
   * A multiplier for {@link force}.
   * 
   * This is multiplicative with both the base force and the "random" multiplier.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link force}
   * - {@link forceRandomMultiplierMin}
   * - {@link forceRandomMultiplierMax}
   */
  forceMultiplier: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_36: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_37: number
  /**
   * The time it takes for the force to fade out after the action has deactivated in seconds. Due to the way this value is stored, the time will be rounded to the nearest 1/30s.
   * 
   * **Default**: `0`
   */
  fadeOutTime: number
  constructor(props: Partial<Props<GravityForce>> = {}) {
    super(ActionType.GravityForce)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.ForceCollision Action 10302 - ForceCollision}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Controls the volume used to detect whether or not the node is inside a force volume.
 * 
 * The name of this action is based on Elden Ring's RTTI, where it's called "CollisionFieldArea".
 */
class ForceCollision extends DataAction {
  declare readonly type: ActionType.ForceCollision
  /**
   * The shape of the volume.
   * 
   * Each shape has different fields controlling the size of the volume:
   * | Shape | Fields |
   * |-|-|
   * | {@link ForceVolumeShape.Boundless Boundless} | *n/a* |
   * | {@link ForceVolumeShape.Sphere Sphere} | {@link sphereRadius} |
   * | {@link ForceVolumeShape.Box Box} | {@link boxSize} |
   * | {@link ForceVolumeShape.Cylinder Cylinder} | {@link cylinderHeight}, {@link cylinderRadius} |
   * 
   * **Note**: The {@link ForceVolumeShape.SquarePrism SquarePrism} shape is not valid for this action.
   * 
   * **Default**: {@link ForceVolumeShape.Sphere}
   */
  shape: ForceVolumeShape
  /**
   * The radius of the {@link ForceVolumeShape.Sphere sphere} volume.
   * 
   * **Default**: `10`
   * 
   * See also:
   * - {@link shape}
   */
  sphereRadius: number
  /**
   * The size of the {@link ForceVolumeShape.Box box} volume.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link shape}
   */
  boxSize: Vector3
  /**
   * The height of the {@link ForceVolumeShape.Cylinder cylinder} volume.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link cylinderRadius}
   */
  cylinderHeight: number
  /**
   * The radius of the {@link ForceVolumeShape.Cylinder cylinder} volume.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link cylinderHeight}
   */
  cylinderRadius: number
  constructor(props: Partial<Props<ForceCollision>> = {}) {
    super(ActionType.ForceCollision)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.TurbulenceForce Action 10303 - TurbulenceForce}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Creates a chaotic force in a volume.
 * 
 * The name of this action is based on Elden Ring's RTTI, where it's called "ForceFieldTurbulenceArea".
 */
class TurbulenceForce extends DataAction {
  declare readonly type: ActionType.TurbulenceForce
  /**
   * Offset along the X-axis for the 3D noise used to control the strength and direction of the force in the volume.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link noiseOffsetY}
   * - {@link noiseOffsetZ}
   */
  noiseOffsetX: ScalarValue
  /**
   * Offset along the Y-axis for the 3D noise used to control the strength and direction of the force in the volume.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link noiseOffsetX}
   * - {@link noiseOffsetZ}
   */
  noiseOffsetY: ScalarValue
  /**
   * Offset along the Z-axis for the 3D noise used to control the strength and direction of the force in the volume.
   * 
   * **Default**: `0`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link noiseOffsetX}
   * - {@link noiseOffsetY}
   */
  noiseOffsetZ: ScalarValue
  /**
   * The strength of the force applied in the volume.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   * 
   * See also:
   * - {@link forceRandomMultiplierMin}
   * - {@link forceRandomMultiplierMax}
   */
  force: ScalarValue
  /**
   * The shape of the volume.
   * 
   * Each shape has different fields controlling the size of the volume, and they also change where it scales from and what point things are being pulled towards:
   * | Shape | Fields | Origin |
   * |-|-|-|
   * | {@link ForceVolumeShape.Boundless Boundless} | *n/a* | *n/a* |
   * | {@link ForceVolumeShape.Sphere Sphere} | {@link sphereRadius} | Center of the sphere |
   * | {@link ForceVolumeShape.Box Box} | {@link boxSize} | Center of the box |
   * | {@link ForceVolumeShape.Cylinder Cylinder} | {@link cylinderHeight}, {@link cylinderRadius} | Slightly +Z of the center of the cylinder? |
   * | {@link ForceVolumeShape.SquarePrism SquarePrism} | {@link squarePrismHeight}, {@link squarePrismApothem} | Center of the base of the prism |
   * 
   * **Default**: {@link ForceVolumeShape.Sphere}
   */
  shape: ForceVolumeShape
  /**
   * The radius of the {@link ForceVolumeShape.Sphere sphere} where the force is active.
   * 
   * **Default**: `10`
   * 
   * See also:
   * - {@link shape}
   */
  sphereRadius: number
  /**
   * The size of the {@link ForceVolumeShape.Box box} where the force is active.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * See also:
   * - {@link shape}
   */
  boxSize: Vector3
  /**
   * The height of the {@link ForceVolumeShape.Cylinder cylinder} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link cylinderRadius}
   */
  cylinderHeight: number
  /**
   * The radius of the {@link ForceVolumeShape.Cylinder cylinder} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link cylinderHeight}
   */
  cylinderRadius: number
  /**
   * The height of the {@link ForceVolumeShape.SquarePrism square prism} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link squarePrismApothem}
   */
  squarePrismHeight: number
  /**
   * The apothem of the {@link ForceVolumeShape.SquarePrism square prism} where the force is active.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link shape}
   * - {@link squarePrismHeight}
   */
  squarePrismApothem: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_13: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_23: number
  /**
   * The minimum random multiplier for {@link force}. This multiplier will randomly change to different values in the range defined by this and {@link forceRandomMultiplierMax}.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link force}
   * - {@link forceRandomMultiplierMax}
   */
  forceRandomMultiplierMin: number
  /**
   * The maximum random multiplier for {@link force}. This multiplier will randomly change to different values in the range defined by this and {@link forceRandomMultiplierMin}.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link force}
   * - {@link forceRandomMultiplierMin}
   */
  forceRandomMultiplierMax: number
  /**
   * The scale of the 3D noise used to control the strength and direction of the force in the volume. Lower values makes it more noisy, with small vortices forming everywhere. Higher values makes the noise smoother.
   * 
   * **Default**: `1`
   */
  noiseScale: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_28: number
  /**
   * Controls whether or not {@link softRadius} is effective.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link softRadius}
   */
  enableSoftRadius: boolean
  /**
   * The radius of a sphere where the force gets weaker with the distance from the origin. Very similar to the {@link sphereRadius sphere radius} when the {@link shape} of the volume is a sphere, but this has a smooth transition from inside the radius to the outside.
   * 
   * This requires {@link enableSoftRadius} to be enabled.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link enableSoftRadius}
   */
  softRadius: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_31: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_33: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_37: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_38: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_39: number
  /**
   * The time it takes for the force to fade out after the action has deactivated in seconds. Due to the way this value is stored, the time will be rounded to the nearest 1/30s.
   * 
   * **Default**: `0`
   */
  fadeOutTime: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_41: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_42: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_43: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_44: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_45: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_46: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_47: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_48: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_49: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_50: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_unk_f1_51: number
  constructor(props: Partial<Props<TurbulenceForce>> = {}) {
    super(ActionType.TurbulenceForce)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.Unk10400 Action 10400 - Unk10400}
 * **Slot**: {@link ActionSlots.Unknown10400Action Unknown10400}
 * 
 * Unknown root node action.
 */
class Unk10400 extends DataAction {
  declare readonly type: ActionType.Unk10400
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_0: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_1: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_2: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_4: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_5: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_6: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_7: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_8: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_10: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_11: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_12: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_13: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_14: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_15: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_17: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_18: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_19: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_20: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_21: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_22: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_23: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_24: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_25: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_26: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_29: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_30: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_31: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_32: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_33: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_34: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_35: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_36: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_37: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_38: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_39: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_40: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_41: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_42: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_43: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_44: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_45: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_46: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_47: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_48: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_49: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_50: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_51: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_52: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_53: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_54: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_55: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_56: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_57: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_58: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_59: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_60: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_61: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_62: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_63: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_64: number
  constructor(props: Partial<Props<Unk10400>> = {}) {
    super(ActionType.Unk10400)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.Unk10500 Action 10500 - Unk10500}
 * **Slot**: {@link ActionSlots.Unknown10500Action Unknown10500}
 * 
 * Unknown root node action.
 */
class Unk10500 extends DataAction {
  declare readonly type: ActionType.Unk10500
  /**
   * Controls how fast time passes for the entire effect.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  rateOfTime: ScalarValue
  /**
   * When enabled, this limits visibility of nodes outside of the distance defined by {@link maxViewDistance}.
   * 
   * **Default**: `false`
   */
  limitViewDistance: boolean
  /**
   * All nodes that are farther away from the camera than this will not be visible. This restriction requires {@link limitViewDistance} to be enabled.
   * 
   * **Default**: `0`
   */
  maxViewDistance: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_2: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_3: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_4: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_5: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_6: number
  /**
   * The game will simulate playing the effect for this amount of time in seconds before actually displaying the effect. This does not mean that it will delay displaying the effect, just that the effect will start as if it had already been playing for this time, kind of like skipping ahead in the animation. This doesn't affect everything in the effect, and a list of things affected has not been made, but it does affect periodic emitters at least.
   * 
   * Setting this to very high values can cause noticeable stutters in the game when the effect is spawned due to it having to simulate playing the effect for so long.
   * 
   * In Dark Souls 3, Sekiro, and Elden Ring, this value will be rounded to the nearest 1/30s due to how it is stored in the file format. It is stored differently in Armored Core 6, and so no rounding will happen for that.
   * 
   * **Default**: `0`
   */
  initialSimulationTime: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_8: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_9: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_10: number
  constructor(props: Partial<Props<Unk10500>> = {}) {
    super(ActionType.Unk10500)
    this.assign(props)
  }
}

/**
 * ### {@link ActionType.SpotLight Action 11000 - SpotLight}
 * **Slot**: {@link ActionSlots.AppearanceAction Appearance}
 * 
 * Light source with an elliptic cone shape, a spot light.
 */
class SpotLight extends DataAction {
  declare readonly type: ActionType.SpotLight
  /**
   * Controls the diffuse color of the light.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * If {@link separateSpecular} is disabled, this also controls the specular color of the light.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  diffuseColor: Vector4Value
  /**
   * Controls the specular color of the light.
   * 
   * Values in this are unrestricted and can go above 1.
   * 
   * If {@link separateSpecular} is disabled, this property is ignored and {@link diffuseColor} controls both the diffuse as well as the specular color.
   * 
   * **Default**: `[1, 1, 1, 1]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  specularColor: Vector4Value
  /**
   * A scalar multiplier for the {@link diffuseColor diffuse color}. Good for easily adjusting the brightness of the light without changing the color.
   * 
   * If {@link separateSpecular} is disabled, this also affects the specular color of the light.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  diffuseMultiplier: ScalarValue
  /**
   * A scalar multiplier for the {@link specularColor specular color}.
   * 
   * If {@link separateSpecular} is disabled, this property is ignored.
   * 
   * **Default**: `1`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  specularMultiplier: ScalarValue
  /**
   * Controls where the light starts in the cone. It bascially "slices off" the tip of the cone. If set to 0, it acts as if it is set to 0.5.
   * 
   * **Default**: `0.01`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  near: ScalarValue
  /**
   * Controls how far away the base of the cone is from the light source.
   * 
   * **Default**: `50`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  far: ScalarValue
  /**
   * The X radius for the elliptic base of the cone.
   * 
   * **Default**: `50`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  radiusX: ScalarValue
  /**
   * The Y radius for the elliptic base of the cone.
   * 
   * **Default**: `50`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  radiusY: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p1_6: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_ds3_p1_7: ScalarValue
  /**
   * Unknown scalar.
   * 
   * **Default**: `1`
   */
  unk_sdt_p1_10: ScalarValue
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_0: number
  /**
   * Toggles the jitter and flicker animations for the light.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link jitterAcceleration}
   * - {@link jitterX}
   * - {@link jitterY}
   * - {@link jitterZ}
   * - {@link flickerIntervalMin}
   * - {@link flickerIntervalMax}
   * - {@link flickerBrightness}
   */
  jitterAndFlicker: boolean
  /**
   * Controls the acceleration of the jittering.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link jitterX}
   * - {@link jitterY}
   * - {@link jitterZ}
   */
  jitterAcceleration: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_3: number
  /**
   * Controls how much the light should move around randomly on the X-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link jitterAcceleration}
   * - {@link jitterY}
   * - {@link jitterZ}
   */
  jitterX: number
  /**
   * Controls how much the light should move around randomly on the Y-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link jitterAcceleration}
   * - {@link jitterX}
   * - {@link jitterZ}
   */
  jitterY: number
  /**
   * Controls how much the light should move around randomly on the Z-axis.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link jitterAcceleration}
   * - {@link jitterX}
   * - {@link jitterY}
   */
  jitterZ: number
  /**
   * Controls the minimum interval for flickering.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link flickerIntervalMax}
   * - {@link flickerBrightness}
   */
  flickerIntervalMin: number
  /**
   * Controls the maximum interval for flickering.
   * 
   * **Default**: `1`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link flickerIntervalMin}
   * - {@link flickerBrightness}
   */
  flickerIntervalMax: number
  /**
   * Brightness multiplier for the light when it flickers.
   * 
   * **Default**: `0.5`
   * 
   * See also:
   * - {@link jitterAndFlicker}
   * - {@link flickerIntervalMin}
   * - {@link flickerIntervalMax}
   */
  flickerBrightness: number
  /**
   * Controls if the light should have shadows or not.
   * 
   * Note: Map objects also have a setting for casting shadows, and both must be enabled for an object to cast shadows from the light source.
   * 
   * **Default**: `false`
   */
  shadows: boolean
  /**
   * When enabled, this allows other properties and fields of the action to control the specular color independently of the diffuse color. When disabled, the diffuse counterpart of the properties or fields will affect both the diffuse and specular color.
   * 
   * **Default**: `false`
   * 
   * See also:
   * - {@link diffuseColor}
   * - {@link specularColor}
   * - {@link diffuseMultiplier}
   * - {@link specularMultiplier}
   */
  separateSpecular: boolean
  /**
   * Controls how dark shadows from this light source are. At 0, the shadows will be entirely invisible.
   * 
   * **Default**: `1`
   */
  shadowDarkness: number
  /**
   * Unknown integer.
   * 
   * **Default**: `2`
   */
  unk_ds3_f1_3: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_4: number
  /**
   * The number of seconds the light takes to fade to nothing after being destroyed.
   * 
   * Due to how the field this represents works, the time will be rounded to the nearest multiple of 1/30s.
   * 
   * **Default**: `0`
   */
  fadeOutTime: number
  /**
   * Unknown integer.
   * 
   * **Default**: `100`
   */
  unk_sdt_f1_16: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_17: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_18: number
  /**
   * Controls the density of some sort of fake fog in the volume hit by the light. The fog does not affect the actual light produced by the source and is not affected by shadows.
   * 
   * **Default**: `0`
   * 
   * See also:
   * - {@link phaseFunction}
   * - {@link asymmetryParam}
   */
  volumeDensity: number
  /**
   * Unknown float.
   * 
   * **Default**: `0`
   */
  unk_sdt_f1_20: number
  /**
   * Controls whether or not {@link asymmetryParam} affects the fake fog from {@link volumeDensity}.
   * 
   * **Default**: `true`
   */
  phaseFunction: boolean
  /**
   * Controls how the fake fog from {@link volumeDensity} scatters the light. This value is ignored if {@link phaseFunction} is disabled, and the fog will scatter the light equally in all directions.
   * 
   * - At 0, the light is scattered equally in every direction.
   * - As the value approaches 1, the light is scattered more and more forward, in the same direction as the light was already traveling. This means that the fake fog will be less visible from the side or behind, and more visible from in front of the light.
   * - At 1, the fog will not scatter the light at all, so it will be entirely invisible.
   * - Values above 1 produce unnatural-looking effects where the light darkens the fog instead.
   * 
   * **Default**: `0.75`
   */
  asymmetryParam: number
  /**
   * When not in a dark enough area, the brightness of the light will be multiplied by 0.1^α, where α is this exponent value. The light will have normal brightness when the area it's in is sufficiently dark.
   * 
   * **Default**: `0`
   */
  adaptationExponent: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_24: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_er_f1_25: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_er_f1_26: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_er_f1_27: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_nr_f1_28: number
  /**
   * Unknown integer.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_0: number
  /**
   * Unknown float.
   * 
   * **Default**: `1`
   */
  unk_ds3_f1_5: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_7: number
  /**
   * Unknown integer.
   * 
   * **Default**: `0`
   */
  unk_ds3_f1_8: number
  constructor(props: Partial<Props<SpotLight>> = {}) {
    super(ActionType.SpotLight)
    this.assign(props)
  }
}
/*#ActionClasses end*/

const DataActions = {
  /*#ActionsList start*/
  [ActionType.NodeAcceleration]: NodeAcceleration, NodeAcceleration,
  [ActionType.NodeTranslation]: NodeTranslation, NodeTranslation,
  [ActionType.NodeSpin]: NodeSpin, NodeSpin,
  [ActionType.StaticNodeTransform]: StaticNodeTransform, StaticNodeTransform,
  [ActionType.RandomNodeTransform]: RandomNodeTransform, RandomNodeTransform,
  [ActionType.NodeAttachToCamera]: NodeAttachToCamera, NodeAttachToCamera,
  [ActionType.ParticleAcceleration]: ParticleAcceleration, ParticleAcceleration,
  [ActionType.ParticleSpeed]: ParticleSpeed, ParticleSpeed,
  [ActionType.ParticleSpeedRandomTurns]: ParticleSpeedRandomTurns, ParticleSpeedRandomTurns,
  [ActionType.ParticleSpeedPartialFollow]: ParticleSpeedPartialFollow, ParticleSpeedPartialFollow,
  [ActionType.NodeSound]: NodeSound, NodeSound,
  [ActionType.EmissionSound]: EmissionSound, EmissionSound,
  [ActionType.NodeAccelerationRandomTurns]: NodeAccelerationRandomTurns, NodeAccelerationRandomTurns,
  [ActionType.ParticleAccelerationRandomTurns]: ParticleAccelerationRandomTurns, ParticleAccelerationRandomTurns,
  [ActionType.ParticleAccelerationPartialFollow]: ParticleAccelerationPartialFollow, ParticleAccelerationPartialFollow,
  [ActionType.NodeAccelerationPartialFollow]: NodeAccelerationPartialFollow, NodeAccelerationPartialFollow,
  [ActionType.NodeAccelerationSpin]: NodeAccelerationSpin, NodeAccelerationSpin,
  [ActionType.NodeSpeed]: NodeSpeed, NodeSpeed,
  [ActionType.NodeSpeedRandomTurns]: NodeSpeedRandomTurns, NodeSpeedRandomTurns,
  [ActionType.NodeSpeedPartialFollow]: NodeSpeedPartialFollow, NodeSpeedPartialFollow,
  [ActionType.NodeSpeedSpin]: NodeSpeedSpin, NodeSpeedSpin,
  [ActionType.NodeAttributes]: NodeAttributes, NodeAttributes,
  [ActionType.ParticleAttributes]: ParticleAttributes, ParticleAttributes,
  [ActionType.Unk130]: Unk130, Unk130,
  [ActionType.ParticleModifier]: ParticleModifier, ParticleModifier,
  [ActionType.SFXReference]: SFXReference, SFXReference,
  [ActionType.LevelsOfDetailThresholds]: LevelsOfDetailThresholds, LevelsOfDetailThresholds,
  [ActionType.StateConfigMap]: StateConfigMap, StateConfigMap,
  [ActionType.SelectAllNodes]: SelectAllNodes, SelectAllNodes,
  [ActionType.SelectRandomNode]: SelectRandomNode, SelectRandomNode,
  [ActionType.PeriodicEmitter]: PeriodicEmitter, PeriodicEmitter,
  [ActionType.EqualDistanceEmitter]: EqualDistanceEmitter, EqualDistanceEmitter,
  [ActionType.OneTimeEmitter]: OneTimeEmitter, OneTimeEmitter,
  [ActionType.PointEmitterShape]: PointEmitterShape, PointEmitterShape,
  [ActionType.DiskEmitterShape]: DiskEmitterShape, DiskEmitterShape,
  [ActionType.RectangleEmitterShape]: RectangleEmitterShape, RectangleEmitterShape,
  [ActionType.SphereEmitterShape]: SphereEmitterShape, SphereEmitterShape,
  [ActionType.BoxEmitterShape]: BoxEmitterShape, BoxEmitterShape,
  [ActionType.CylinderEmitterShape]: CylinderEmitterShape, CylinderEmitterShape,
  [ActionType.NoSpread]: NoSpread, NoSpread,
  [ActionType.CircularSpread]: CircularSpread, CircularSpread,
  [ActionType.EllipticalSpread]: EllipticalSpread, EllipticalSpread,
  [ActionType.RectangularSpread]: RectangularSpread, RectangularSpread,
  [ActionType.PointSprite]: PointSprite, PointSprite,
  [ActionType.Line]: Line, Line,
  [ActionType.QuadLine]: QuadLine, QuadLine,
  [ActionType.BillboardEx]: BillboardEx, BillboardEx,
  [ActionType.MultiTextureBillboardEx]: MultiTextureBillboardEx, MultiTextureBillboardEx,
  [ActionType.Model]: Model, Model,
  [ActionType.LegacyTracer]: LegacyTracer, LegacyTracer,
  [ActionType.Distortion]: Distortion, Distortion,
  [ActionType.RadialBlur]: RadialBlur, RadialBlur,
  [ActionType.PointLight]: PointLight, PointLight,
  [ActionType.SimulateTermination]: SimulateTermination, SimulateTermination,
  [ActionType.FadeTermination]: FadeTermination, FadeTermination,
  [ActionType.InstantTermination]: InstantTermination, InstantTermination,
  [ActionType.NodeForceSpeed]: NodeForceSpeed, NodeForceSpeed,
  [ActionType.ParticleForceSpeed]: ParticleForceSpeed, ParticleForceSpeed,
  [ActionType.NodeForceAcceleration]: NodeForceAcceleration, NodeForceAcceleration,
  [ActionType.ParticleForceAcceleration]: ParticleForceAcceleration, ParticleForceAcceleration,
  [ActionType.ParticleForceCollision]: ParticleForceCollision, ParticleForceCollision,
  [ActionType.GPUStandardParticle]: GPUStandardParticle, GPUStandardParticle,
  [ActionType.GPUStandardCorrectParticle]: GPUStandardCorrectParticle, GPUStandardCorrectParticle,
  [ActionType.LightShaft]: LightShaft, LightShaft,
  [ActionType.GPUSparkParticle]: GPUSparkParticle, GPUSparkParticle,
  [ActionType.GPUSparkCorrectParticle]: GPUSparkCorrectParticle, GPUSparkCorrectParticle,
  [ActionType.Tracer]: Tracer, Tracer,
  [ActionType.WaterInteraction]: WaterInteraction, WaterInteraction,
  [ActionType.LensFlare]: LensFlare, LensFlare,
  [ActionType.RichModel]: RichModel, RichModel,
  [ActionType.Unk10100]: Unk10100, Unk10100,
  [ActionType.CancelForce]: CancelForce, CancelForce,
  [ActionType.WindForce]: WindForce, WindForce,
  [ActionType.GravityForce]: GravityForce, GravityForce,
  [ActionType.ForceCollision]: ForceCollision, ForceCollision,
  [ActionType.TurbulenceForce]: TurbulenceForce, TurbulenceForce,
  [ActionType.Unk10400]: Unk10400, Unk10400,
  [ActionType.Unk10500]: Unk10500, Unk10500,
  [ActionType.SpotLight]: SpotLight, SpotLight,
  /*#ActionsList end*/
}

//#region Field
abstract class Field<T extends FieldType> {
  constructor(
    public readonly type: T,
    public value: TypeMap.FieldValue[T]
  ) {}

  static from<T extends FieldType>(type: T, value: TypeMap.FieldValue[T]) {
    switch (type) {
      case FieldType.Boolean: return new BoolField(value as boolean)
      case FieldType.Integer: return new IntField(value as number)
      case FieldType.Float: return new FloatField(value as number)
      case FieldType.Vector2: return new Vector2Field(value as Vector2)
      case FieldType.Vector3: return new Vector3Field(value as Vector3)
      case FieldType.Vector4: return new Vector4Field(value as Vector4)
    }
  }

  static fromJSON<T extends FieldType>({ type, value }: {
    type: TypeMap.FieldTypeName[T],
    value: TypeMap.FieldValue[T]
  }) {
    switch (type) {
      case 'Boolean': return new BoolField(value as boolean)
      case 'Integer': return new IntField(value as number)
      case 'Float': return new FloatField(value as number)
      case 'Vector2': return new Vector2Field(value as Vector2)
      case 'Vector3': return new Vector3Field(value as Vector3)
      case 'Vector4': return new Vector4Field(value as Vector4)
    }
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions): {
    type: TypeMap.FieldTypeName[T],
    value: TypeMap.FieldValue[T]
  } {
    return {
      type: FieldType[this.type] as TypeMap.FieldTypeName[T],
      value: this.value
    }
  }

  abstract clone(): Field<T>
}

class BoolField extends Field<FieldType.Boolean> {
  declare readonly type = FieldType.Boolean
  constructor(value: boolean = false) { super(FieldType.Boolean, value) }
  clone(): Field<FieldType.Boolean> { return new BoolField(this.value) }
}

class IntField extends Field<FieldType.Integer> {
  declare readonly type = FieldType.Integer
  constructor(value: number = 0) { super(FieldType.Integer, value) }
  clone(): Field<FieldType.Integer> { return new IntField(this.value) }
}

class FloatField extends Field<FieldType.Float> {
  declare readonly type = FieldType.Float
  constructor(value: number = 0) { super(FieldType.Float, value) }
  clone(): Field<FieldType.Float> { return new FloatField(this.value) }
}

class Vector2Field extends Field<FieldType.Vector2> {
  declare readonly type = FieldType.Vector2
  constructor(value: Vector2 = [0, 0]) { super(FieldType.Vector2, value) }
  clone(): Field<FieldType.Vector2> { return new Vector2Field(this.value.slice() as Vector2) }
}

class Vector3Field extends Field<FieldType.Vector3> {
  declare readonly type = FieldType.Vector3
  constructor(value: Vector3 = [0, 0, 0]) { super(FieldType.Vector3, value) }
  clone(): Field<FieldType.Vector3> { return new Vector3Field(this.value.slice() as Vector3) }
}

class Vector4Field extends Field<FieldType.Vector4> {
  declare readonly type = FieldType.Vector4
  constructor(value: Vector4 = [0, 0, 0, 0]) { super(FieldType.Vector4, value) }
  clone(): Field<FieldType.Vector4> { return new Vector4Field(this.value.slice() as Vector4) }
}

//#region Keyframe
class Keyframe<T extends ValueType> implements IBasicKeyframe<T> {

  constructor(
    public position: number,
    public value: TypeMap.PropertyValue[T]
  ) {}

  static copy<T extends ValueType, K extends AnyKeyframe<T>>(orig: K): K {
    if ('p1' in orig) {
      return new BezierKeyframe(orig.position, orig.value, orig.p1, orig.p2) as K
    } else if ('t1' in orig) {
      return new HermiteKeyframe(orig.position, orig.value, orig.t1, orig.t2) as K
    }
    return new Keyframe(orig.position, orig.value) as K
  }

  static component<T extends ValueType, K extends AnyKeyframe<T>>(kf: K, i: number): ScalarKeyframeFromAny<K, T> {
    if (Array.isArray(kf.value)) {
      if (i < 0 || i >= kf.value.length) {
        throw new Error('Index of keyframe component out of range.')
      }
      if ('p1' in kf) {
        return new BezierKeyframe(kf.position, kf.value[i], kf.p1[i], kf.p2[i]) as ScalarKeyframeFromAny<K, T>
      } else if ('t1' in kf) {
        return new HermiteKeyframe(kf.position, kf.value[i], kf.t1[i], kf.t2[i]) as ScalarKeyframeFromAny<K, T>
      }
      return new Keyframe(kf.position, kf.value[i]) as ScalarKeyframeFromAny<K, T>
    } else {
      if (i !== 0) {
        throw new Error('Index of keyframe component out of range.')
      }
      return kf as unknown as ScalarKeyframeFromAny<K, T>
    }
  }

  static scale<T extends AnyKeyframe<ValueType>>(kf: AnyKeyframe<ValueType>, factor: PropertyValue): T {
    if (typeof kf.value === 'number') {
      kf.value = typeof factor === 'number' ? kf.value * factor : factor.map(e => (kf.value as number) * e) as Vector
    } else {
      kf.value = (typeof factor === 'number' ? kf.value.map(e => e * factor) : kf.value.map((e, i) => e * factor[i])) as Vector
    }
    if ('p1' in kf) {
      if (typeof kf.p1 === 'number') {
        kf.p1 = typeof factor === 'number' ? kf.p1 * factor : factor.map(e => (kf.p1 as number) * e) as Vector
      } else {
        kf.p1 = (typeof factor === 'number' ? kf.p1.map(e => e * factor) : kf.p1.map((e, i) => e * factor[i])) as Vector
      }
      if (typeof kf.p2 === 'number') {
        kf.p2 = typeof factor === 'number' ? kf.p2 * factor : factor.map(e => (kf.p2 as number) * e) as Vector
      } else {
        kf.p2 = (typeof factor === 'number' ? kf.p2.map(e => e * factor) : kf.p2.map((e, i) => e * factor[i])) as Vector
      }
    }
    return kf as T
  }

  static add<T extends AnyKeyframe<ValueType>>(kf: AnyKeyframe<ValueType>, summand: PropertyValue): T {
    if (typeof kf.value === 'number') {
      kf.value = typeof summand === 'number' ? kf.value + summand : summand.map(e => (kf.value as number) + e) as Vector
    } else {
      kf.value = (typeof summand === 'number' ? kf.value.map(e => e + summand) : kf.value.map((e, i) => e + summand[i])) as Vector
    }
    return kf as T
  }

  static equal<T extends ValueType, K extends IBasicKeyframe<T> | IBezierKeyframe<T>>(kf1: K, kf2: K) {
    return propValueEqual(kf1.value, kf2.value) && (
      !('p1' in kf1 && 'p1' in kf2) ||
      propValueEqual(kf1.p1, kf2.p1) && propValueEqual(kf1.p2, kf2.p2)
    )
  }

}

class BezierKeyframe<T extends ValueType> extends Keyframe<T> implements IBezierKeyframe<T> {

  constructor(
    position: number,
    value: TypeMap.PropertyValue[T],
    public p1: TypeMap.PropertyValue[T],
    public p2: TypeMap.PropertyValue[T],
  ) {
    super(position, value)
  }

}

class HermiteKeyframe<T extends ValueType> extends Keyframe<T> implements IHermiteKeyframe<T> {

  constructor(
    position: number,
    value: TypeMap.PropertyValue[T],
    public t1: TypeMap.PropertyValue[T],
    public t2: TypeMap.PropertyValue[T],
  ) {
    super(position, value)
  }

  /**
   * Creates a new keyframe with an easing function that starts slow, speeds up
   * towards the midpoint, and slows down towards the end.
   * 
   * Similar to {@link easeInOut}, but this starts slightly faster.
   */
  static ease<T extends ValueType>(position: number, value: TypeMap.PropertyValue[T]) {
    const valType = getValueType(value)
    return new HermiteKeyframe(position, value, valueWithType(valType, 21.8 * deg2rad), valueWithType(valType, 0))
  }

  /**
   * Creates a new keyframe with an easing function that starts slow and speeds
   * up towards the end.
   */
  static easeIn<T extends ValueType>(position: number, value: TypeMap.PropertyValue[T]) {
    const valType = getValueType(value)
    return new HermiteKeyframe(position, value, valueWithType(valType, 0), valueWithType(valType, 45 * deg2rad))
  }

  /**
   * Creates a new keyframe with an easing function that starts fast and slows
   * down towards the end.
   */
  static easeOut<T extends ValueType>(position: number, value: TypeMap.PropertyValue[T]) {
    const valType = getValueType(value)
    return new HermiteKeyframe(position, value, valueWithType(valType, 45 * deg2rad), valueWithType(valType, 0))
  }

  /**
   * Creates a new keyframe with an easing function that starts slow, speeds up
   * towards the midpoint, and slows down towards the end.
   * 
   * Similar to {@link ease}, but this starts slightly slower.
   */
  static easeInOut<T extends ValueType>(position: number, value: TypeMap.PropertyValue[T]) {
    const valType = getValueType(value)
    return new HermiteKeyframe(position, value, valueWithType(valType, 0), valueWithType(valType, 0))
  }

  /**
   * Creates a new keyframe with an easing function that starts very slow, but
   * speeds up very quickly near the end.
   */
  static launch<T extends ValueType>(position: number, value: TypeMap.PropertyValue[T]) {
    const valType = getValueType(value)
    return new HermiteKeyframe(position, value, valueWithType(valType, 0), valueWithType(valType, 90 * deg2rad))
  }

  /**
   * Creates a new keyframe with an easing function that starts very fast, but
   * very quickly slows down.
   */
  static explosive<T extends ValueType>(position: number, value: TypeMap.PropertyValue[T]) {
    const valType = getValueType(value)
    return new HermiteKeyframe(position, value, valueWithType(valType, 90 * deg2rad), valueWithType(valType, 0))
  }

  /**
   * Creates a new keyframe with a linear easing function.
   */
  static linear<T extends ValueType>(position: number, value: TypeMap.PropertyValue[T]) {
    const valType = getValueType(value)
    return new HermiteKeyframe(position, value, valueWithType(valType, 45 * deg2rad), valueWithType(valType, 45 * deg2rad))
  }

}

//#region Property
abstract class Property<T extends ValueType, F extends PropertyFunction> implements IModifiableProperty<T, F> {

  valueType: T
  function: F
  modifiers: IModifier<T>[]

  constructor(
    valueType: T,
    func: F,
    modifiers: IModifier<T>[] = []
  ) {
    this.valueType = valueType
    this.function = func
    this.modifiers = modifiers
  }

  get componentCount() { return this.valueType + 1 as 1 | 2 | 3 | 4 }

  withModifiers(...modifiers: IModifier<T>[]) {
    this.modifiers.push(...modifiers)
    return this
  }

  static fromJSON<T extends ValueType>(obj: any) {
    if (obj instanceof Property) {
      return obj
    }
    if (typeof obj === 'object' && 'function' in obj) {
      switch (PropertyFunction[obj.function as string]) {
        case PropertyFunction.Stepped:
        case PropertyFunction.Linear:
        case PropertyFunction.Bezier:
        case PropertyFunction.Hermite:
          return SequenceProperty.fromJSON<T>(obj)
        case PropertyFunction.ComponentHermite:
          return ComponentSequenceProperty.fromJSON<T>(obj)
      }
    } else {
      return ValueProperty.fromJSON<T>(obj)
    }
  }

  /**
   * Returns an equal property that works with the given game.
   * 
   * If the property has multiple modifiers, there is a chance that the output
   * of this method will not be perfectly equal, but it should still be close.
   * @param game The game to ensure that the property works with.
   * @returns 
   */
  for(game: Game) {
    if (
      (game === Game.DarkSouls3 || game === Game.Sekiro) &&
      this.modifiers.some(mod => mod.type === ModifierType.RandomRange)
    ) {
      const summand = Array(this.componentCount).fill(0)
      const mods = this.modifiers.map(mod => {
        if (mod instanceof RandomRangeModifier) {
          const vt = mod.valueType
          const comps = []
          if (vt === ValueType.Scalar) {
            comps.push(mod.min*0.5 + mod.max*0.5)
          } else for (let i = 0; i <= vt; i++) {
            comps.push(mod.min[i]*0.5 + mod.max[i]*0.5)
          }
          for (const [i, v] of comps.entries()) {
            summand[i] += v
          }
          return new RandomDeltaModifier<any>(comps.length === 1 ? comps[0] : comps, mod.seed)
        }
        return mod.clone()
      })
      const clone = this.clone().add(summand.length === 1 ? summand[0] : summand)
      clone.modifiers = mods
      return clone
    }
    return this
  }

  clamp(min: TypeMap.PropertyValue[T], max: TypeMap.PropertyValue[T]): Property<T, PropertyFunction> {
    return clampProp(this, min, max)
  }

  toJSON() { return this.serialize() }

  abstract fieldCount: number
  abstract fields: NumericalField[]
  abstract serialize(options?: FXRSerializeOptions): any
  abstract scale(factor: PropertyValue): this
  abstract add(summand: PropertyValue): this
  abstract valueAt(arg: number): TypeMap.PropertyValue[T]
  abstract clone(): Property<T, F>
  abstract separateComponents(): Property<ValueType.Scalar, F>[]
  abstract min(): TypeMap.PropertyValue[T]
  abstract max(): TypeMap.PropertyValue[T]
  abstract minify(): Property<T, PropertyFunction>

}

class ValueProperty<T extends ValueType>
  extends Property<T, ValuePropertyFunction>
  implements IModifiableProperty<T, ValuePropertyFunction> {

  value: TypeMap.PropertyValue[T]

  constructor(
    valueType: T,
    value: TypeMap.PropertyValue[T],
    modifiers: IModifier<T>[] = []
  ) {
    super(valueType, PropertyFunction.Constant, modifiers)
    this.value = value
  }

  get isZero() { return Array.isArray(this.value) ? this.value.every(e => e === 0) : this.value === 0 }
  get isOne()  { return Array.isArray(this.value) ? this.value.every(e => e === 1) : this.value === 1 }

  get fieldCount(): number {
    if (this.isZero || this.isOne) {
      return 0
    }
    return this.componentCount
  }

  get fields(): NumericalField[] {
    if (this.isZero || this.isOne) {
      return []
    }
    if (this.valueType === ValueType.Scalar) {
      return [ new FloatField(this.value as number) ]
    }
    return (this.value as Vector).map(e => new FloatField(e))
  }

  static fromFields<T extends ValueType>(
    valueType: T,
    func: ValuePropertyFunction,
    modifiers: IModifier<T>[],
    fieldValues: number[]
  ): ValueProperty<T> {
    switch (func) {
      case PropertyFunction.Zero:
        return new ConstantProperty(valueType === ValueType.Scalar ? 0 : Array(valueType + 1).fill(0) as Vector).withModifiers(
          ...modifiers
        ) as unknown as ValueProperty<T>
      case PropertyFunction.One:
        return new ConstantProperty(valueType === ValueType.Scalar ? 1 : Array(valueType + 1).fill(1) as Vector).withModifiers(
          ...modifiers
        ) as unknown as ValueProperty<T>
      case PropertyFunction.Constant:
        return new ConstantProperty(valueType === ValueType.Scalar ? fieldValues[0] : fieldValues as Vector).withModifiers(
          ...modifiers
        ) as unknown as ValueProperty<T>
      default:
        throw new Error('Incompatible or unknown function in property: ' + func)
    }
  }

  static fromJSON<T extends ValueType>(obj: {
    value: PropertyValue
    modifiers?: any[]
  } | PropertyValue): ConstantProperty<T> {
    if (Array.isArray(obj)) {
      return new ConstantProperty(obj as TypeMap.PropertyValue[T])
    } else if (typeof obj === 'number') {
      return new ConstantProperty(obj as TypeMap.PropertyValue[T])
    }
    return new ConstantProperty<T>(obj.value as TypeMap.PropertyValue[T]).withModifiers(
      ...(obj.modifiers ?? []).map(e => Modifier.fromJSON(e) as IModifier<T>)
    )
  }

  serialize(options?: FXRSerializeOptions): any {
    if (this.modifiers.length > 0) {
      return {
        value: this.value,
        modifiers: this.modifiers.map(mod => mod.serialize(options))
      }
    } else {
      return this.value
    }
  }

  scale(factor: TypeMap.PropertyValue[T] | number) {
    if (this.valueType === ValueType.Scalar) {
      (this.value as number) *= factor as number
    } else {
      if (typeof factor === 'number') {
        this.value = (this.value as Vector).map(e => e * factor) as TypeMap.PropertyValue[T]
      } else {
        this.value = (this.value as Vector).map((e, i) => e * factor[i]) as TypeMap.PropertyValue[T]
      }
    }
    scalePropMods(this, factor)
    return this
  }

  add(summand: TypeMap.PropertyValue[T] | number) {
    if (this.valueType === ValueType.Scalar) {
      (this.value as number) += summand as number
    } else {
      if (typeof summand === 'number') {
        this.value = (this.value as Vector).map(e => e + summand) as TypeMap.PropertyValue[T]
      } else {
        this.value = (this.value as Vector).map((e, i) => e + summand[i]) as TypeMap.PropertyValue[T]
      }
    }
    return this
  }

  valueAt(arg: number): TypeMap.PropertyValue[T] {
    return this.value
  }

  clone(): ValueProperty<T> {
    return new ValueProperty(this.valueType, this.value, this.modifiers.map(e => e.clone()))
  }

  separateComponents(): ValueProperty<ValueType.Scalar>[] {
    if (this.valueType === ValueType.Scalar) {
      return [this.clone() as ValueProperty<ValueType.Scalar>]
    } else {
      const mods = this.modifiers.map(e => e.separateComponents())
      return (this.value as Vector).map((e, i) => new ConstantProperty<ValueType.Scalar>(e).withModifiers(
        ...mods.map(comps => comps[i]).filter(Modifier.isEffective)
      ))
    }
  }

  min(): TypeMap.PropertyValue[T] {
    return this.value
  }

  max(): TypeMap.PropertyValue[T] {
    return this.value
  }

  minify(): ValueProperty<T> {
    const clone = this.clone()
    clone.modifiers = clone.modifiers.map(mod => mod.minify()).filter(Modifier.isEffective)
    return clone
  }

}

class SequenceProperty<T extends ValueType, F extends SequencePropertyFunction>
  extends Property<T, F>
  implements IModifiableProperty<T, F> {

  constructor(
    valueType: T,
    func: F,
    public loop: boolean = false,
    public keyframes: TypeMap.Keyframe<T>[F][] = [],
    modifiers: IModifier<T>[] = []
  ) {
    super(valueType, func, modifiers)
  }

  sortKeyframes() {
    this.keyframes.sort((a, b) => a.position - b.position)
    return this
  }

  get fieldCount(): number {
    switch (this.function) {
      case PropertyFunction.Stepped:
      case PropertyFunction.Linear:
        return 1 + 2 * this.componentCount + (1 + this.componentCount) * this.keyframes.length
      case PropertyFunction.Bezier:
      case PropertyFunction.Hermite:
        return 1 + 2 * this.componentCount + (1 + 3 * this.componentCount) * this.keyframes.length
    }
  }

  get fields(): NumericalField[] {
    const cc = this.componentCount
    switch (this.function) {
      case PropertyFunction.Stepped:
      case PropertyFunction.Linear:
        return [
          new IntField(this.keyframes.length),
          ...(cc === 1 ? [this.min()] : this.min() as Vector).map(e => new FloatField(e)),
          ...(cc === 1 ? [this.max()] : this.max() as Vector).map(e => new FloatField(e)),
          ...this.keyframes.map(e => new FloatField(e.position)),
          ...this.keyframes.flatMap(
            this.valueType === ValueType.Scalar ?
              e => [ new FloatField(e.value as number) ] :
              e => (e.value as Vector).map(e => new FloatField(e))
          )
        ]
      case PropertyFunction.Bezier:
        return [
          new IntField(this.keyframes.length),
          ...(cc === 1 ? [this.min()] : this.min() as Vector).map(e => new FloatField(e)),
          ...(cc === 1 ? [this.max()] : this.max() as Vector).map(e => new FloatField(e)),
          ...this.keyframes.map(e => new FloatField(e.position)),
          ...this.keyframes.flatMap(
            this.valueType === ValueType.Scalar ?
              e => [ new FloatField(e.value as number) ] :
              e => (e.value as Vector).map(e => new FloatField(e))
          ),
          ...this.keyframes.flatMap(
            this.valueType === ValueType.Scalar ?
              e => [ new FloatField((e as IBezierKeyframe<T>).p1 as number) ] :
              e => ((e as IBezierKeyframe<T>).p1 as Vector).map(e => new FloatField(e))
          ),
          ...this.keyframes.flatMap(
            this.valueType === ValueType.Scalar ?
              e => [ new FloatField((e as IBezierKeyframe<T>).p2 as number) ] :
              e => ((e as IBezierKeyframe<T>).p2 as Vector).map(e => new FloatField(e))
          ),
        ]
      case PropertyFunction.Hermite:
        return [
          new IntField(this.keyframes.length),
          ...(cc === 1 ? [this.min()] : this.min() as Vector).map(e => new FloatField(e)),
          ...(cc === 1 ? [this.max()] : this.max() as Vector).map(e => new FloatField(e)),
          ...this.keyframes.map(e => new FloatField(e.position)),
          ...this.keyframes.flatMap(
            this.valueType === ValueType.Scalar ?
              e => [ new FloatField(e.value as number) ] :
              e => (e.value as Vector).map(e => new FloatField(e))
          ),
          ...this.keyframes.flatMap(
            this.valueType === ValueType.Scalar ?
              e => [ new FloatField((e as IHermiteKeyframe<T>).t1 as number) ] :
              e => ((e as IHermiteKeyframe<T>).t1 as Vector).map(e => new FloatField(e))
          ),
          ...this.keyframes.flatMap(
            this.valueType === ValueType.Scalar ?
              e => [ new FloatField((e as IHermiteKeyframe<T>).t2 as number) ] :
              e => ((e as IHermiteKeyframe<T>).t2 as Vector).map(e => new FloatField(e))
          ),
        ]
      default:
        throw new Error('Incompatible or unknown function in property: ' + this.function)
    }
  }

  static fromFields<T extends ValueType, F extends SequencePropertyFunction>(
    valueType: T,
    func: F,
    loop: boolean,
    modifiers: IModifier<T>[],
    fieldValues: number[]
  ): SequenceProperty<T, F> {
    switch (func) {
      case PropertyFunction.Stepped:
      case PropertyFunction.Linear:
        return new SequenceProperty(valueType, func, loop, arrayOf(
          fieldValues[0],
          i => new Keyframe(
            fieldValues[1 + 2 * (valueType + 1) + i],
            (valueType === ValueType.Scalar ?
              fieldValues[1 + (2 + i) * (valueType + 1) + fieldValues[0]] :
              fieldValues.slice(1 + (2 + i) * (valueType + 1) + fieldValues[0], 1 + (2 + i) * (valueType + 1) + fieldValues[0] + (valueType + 1)) as Vector
            ) as TypeMap.PropertyValue[T]
          ) as TypeMap.Keyframe<T>[F]
        ), modifiers)
      case PropertyFunction.Bezier:
      case PropertyFunction.Hermite:
        return new SequenceProperty(valueType, func, loop, arrayOf(
          fieldValues[0],
          i => new (func === PropertyFunction.Bezier ? BezierKeyframe : HermiteKeyframe)(
            fieldValues[1 + 2 * (valueType + 1) + i],
            (valueType === ValueType.Scalar ?
              fieldValues[1 + (2 + i) * (valueType + 1) + fieldValues[0]] :
              fieldValues.slice(1 + (2 + i) * (valueType + 1) + fieldValues[0], 1 + (2 + i) * (valueType + 1) + fieldValues[0] + (valueType + 1)) as Vector
            ) as TypeMap.PropertyValue[T],
            (valueType === ValueType.Scalar ?
              fieldValues[1 + (2 + i + fieldValues[0]) * (valueType + 1) + fieldValues[0]] :
              fieldValues.slice(1 + (2 + i + fieldValues[0]) * (valueType + 1) + fieldValues[0], 1 + (2 + i + fieldValues[0]) * (valueType + 1) + fieldValues[0] + (valueType + 1)) as Vector
            ) as TypeMap.PropertyValue[T],
            (valueType === ValueType.Scalar ?
              fieldValues[1 + (2 + i + 2 * fieldValues[0]) * (valueType + 1) + fieldValues[0]] :
              fieldValues.slice(1 + (2 + i + 2 * fieldValues[0]) * (valueType + 1) + fieldValues[0], 1 + (2 + i + 2 * fieldValues[0]) * (valueType + 1) + fieldValues[0] + (valueType + 1)) as Vector
            ) as TypeMap.PropertyValue[T],
          ) as TypeMap.Keyframe<T>[F]
        ), modifiers)
      default:
        throw new Error('Incompatible or unknown function in property: ' + func)
    }
  }

  static fromJSON<T extends ValueType>(obj: {
    function: string
    modifiers?: any[]
    keyframes?: AnyKeyframe<T>[]
    loop?: boolean
  }): SequenceProperty<T, any> {
    return new SequenceProperty(
      (Array.isArray(obj.keyframes[0].value) ? obj.keyframes[0].value.length - 1 : ValueType.Scalar) as T,
      PropertyFunction[obj.function],
      obj.loop ?? false,
      obj.keyframes,
      (obj.modifiers ?? []).map(mod => Modifier.fromJSON(mod))
    )
  }

  serialize(options?: FXRSerializeOptions) {
    switch (this.function) {
      case PropertyFunction.Stepped:
      case PropertyFunction.Linear: {
        const o: {
          function: string
          loop: boolean
          keyframes: any[]
          modifiers?: any[]
        } = {
          function: PropertyFunction[this.function],
          loop: this.loop,
          keyframes: this.keyframes.map(e => ({
            position: e.position,
            value: e.value
          }))
        }
        if (this.modifiers.length > 0) o.modifiers = this.modifiers.map(mod => mod.serialize(options))
        return o
      }
      case PropertyFunction.Bezier: {
        const o: {
          function: string
          loop: boolean
          keyframes: any[]
          modifiers?: any[]
        } = {
          function: PropertyFunction[this.function],
          loop: this.loop,
          keyframes: this.keyframes.map(e => ({
            position: e.position,
            value: e.value,
            p1: (e as IBezierKeyframe<T>).p1,
            p2: (e as IBezierKeyframe<T>).p2,
          }))
        }
        if (this.modifiers.length > 0) o.modifiers = this.modifiers.map(mod => mod.serialize(options))
        return o
      }
      case PropertyFunction.Hermite: {
        const o: {
          function: string
          loop: boolean
          keyframes: any[]
          modifiers?: any[]
        } = {
          function: PropertyFunction[this.function],
          loop: this.loop,
          keyframes: this.keyframes.map(e => ({
            position: e.position,
            value: e.value,
            t1: (e as IHermiteKeyframe<T>).t1,
            t2: (e as IHermiteKeyframe<T>).t2,
          }))
        }
        if (this.modifiers.length > 0) o.modifiers = this.modifiers.map(mod => mod.serialize(options))
        return o
      }
    }
  }

  scale(factor: TypeMap.PropertyValue[T] | number) {
    if (this.valueType === ValueType.Scalar && Array.isArray(factor)) {
      throw new Error([
        'Scalar properties cannot be scaled by a vector.',
        'If you need to make a vector property by scaling a',
        'scalar property by a vector, use anyValueMult instead.'
      ].join(' '))
    }
    for (const kf of this.keyframes) {
      Keyframe.scale(kf, factor)
    }
    scalePropMods(this, factor)
    return this
  }

  add(summand: TypeMap.PropertyValue[T] | number) {
    if (this.valueType === ValueType.Scalar && Array.isArray(summand)) {
      throw new Error([
        'Vectors cannot be added to scalar properties.',
        'If you need to make a vector property by adding a',
        'vector to a scalar property, use anyValueSum instead.'
      ].join(' '))
    }
    for (const kf of this.keyframes) {
      Keyframe.add(kf, summand)
    }
    return this
  }

  valueAt(arg: number): TypeMap.PropertyValue[T] {
    if (this.loop) {
      const duration = this.duration
      if (duration === 0) {
        // Return NaN when the property loops and the duration is 0.
        // This matches what the games do in the same case.
        return (
          this.valueType === ValueType.Scalar ?
            NaN :
            arrayOf(this.componentCount, _ => NaN)
        ) as TypeMap.PropertyValue[T]
      }
      arg %= duration
    } else if (arg > this.duration) {
      return this.keyframes[this.keyframes.length - 1].value
    }
    switch (this.function) {
      case PropertyFunction.Stepped:
        return stepKeyframes(this.keyframes, arg)
      case PropertyFunction.Linear:
        return lerpKeyframes(this.keyframes, arg)
      case PropertyFunction.Bezier:
        return bezierInterpKeyframes((this.keyframes as IBezierKeyframe<T>[]), arg)
      case PropertyFunction.Hermite:
        return hermiteInterpKeyframes((this.keyframes as IHermiteKeyframe<T>[]), arg)
    }
  }

  clone(): SequenceProperty<T, F> {
    return new SequenceProperty(
      this.valueType,
      this.function,
      this.loop,
      this.keyframes.map(e => Keyframe.copy(e)),
      this.modifiers.map(e => e.clone())
    )
  }

  separateComponents(): SequenceProperty<ValueType.Scalar, F>[] {
    if (this.valueType === ValueType.Scalar) {
      return [this.clone() as SequenceProperty<ValueType.Scalar, F>]
    } else {
      const mods = this.modifiers.map(e => e.separateComponents())
      return arrayOf(this.componentCount, i => new SequenceProperty(
        ValueType.Scalar,
        this.function,
        this.loop,
        this.keyframes.map(kf => Keyframe.component(kf, i) as TypeMap.Keyframe<ValueType.Scalar>[F])
      ).withModifiers(
          ...mods.map(comps => comps[i]).filter(Modifier.isEffective)
        )
      )
    }
  }

  min(): TypeMap.PropertyValue[T] {
    const cc = this.componentCount
    if (cc === 1) {
      return Math.min(...this.keyframes.map(e => e.value as number)) as TypeMap.PropertyValue[T]
    } else {
      return arrayOf(cc, i => Math.min(...this.keyframes.map(e => e.value[i]))) as TypeMap.PropertyValue[T]
    }
  }

  max(): TypeMap.PropertyValue[T] {
    const cc = this.componentCount
    if (cc === 1) {
      return Math.max(...this.keyframes.map(e => e.value as number)) as TypeMap.PropertyValue[T]
    } else {
      return arrayOf(cc, i => Math.max(...this.keyframes.map(e => e.value[i]))) as TypeMap.PropertyValue[T]
    }
  }

  minify(): Property<T, PropertyFunction> {
    const mods = this.modifiers.map(mod => mod.minify()).filter(Modifier.isEffective)
    if (this.keyframes.length === 1 || this.keyframes.slice(1).every(kf => Keyframe.equal(this.keyframes[0], kf))) {
      return new ConstantProperty<T>(this.keyframes[0].value).withModifiers(...mods)
    }
    const clone = this.clone()
    clone.modifiers = mods
    if (clone.function === PropertyFunction.Stepped) {
      clone.keyframes = clone.keyframes.filter((e, i, a) => i === 0 || i === a.length - 1 || !propValueEqual(a[i-1].value, e.value))
    } else if (clone.function === PropertyFunction.Linear) {
      clone.keyframes = clone.keyframes.filter((e, i, a) =>
        i === 0 ||
        i === a.length - 1 ||
        !propValueEqual(a[i-1].value, e.value) ||
        !propValueEqual(e.value, a[i+1].value)
      )
    }
    return clone
  }

  get duration() { return Math.max(0, ...this.keyframes.map(kf => kf.position)) }
  set duration(value: number) {
    const factor = value / this.duration
    for (const kf of this.keyframes) {
      kf.position *= factor
    }
  }

}

class ComponentSequenceProperty<T extends ValueType>
  extends Property<T, PropertyFunction.ComponentHermite>
  implements IModifiableProperty<T, PropertyFunction.ComponentHermite> {

  declare function: PropertyFunction.ComponentHermite

  components: GenComponents<HermiteProperty<ValueType.Scalar>, T>

  constructor(
    public loop: boolean = false,
    components: GenComponents<IHermiteKeyframe<ValueType.Scalar>[], T>,
    modifiers: IModifier<T>[] = []
  ) {
    super(components.length - 1 as T, PropertyFunction.ComponentHermite, modifiers)
    this.components = components.map(
      e => new HermiteProperty(false, e)
    ) as GenComponents<HermiteProperty<ValueType.Scalar>, T>
  }

  sortComponentKeyframes() {
    for (const comp of this.components) {
      comp.sortKeyframes()
    }
    return this
  }

  get fieldCount(): number {
    return 1 + 3 * this.componentCount + this.components.reduce((a, e) => a + 4 * e.keyframes.length, 0)
  }

  get fields(): NumericalField[] {
    return [
      new FloatField(this.duration),
      ...this.components.map(e => new IntField(e.keyframes.length)),
      ...this.components.map(comp => new FloatField(comp.min())),
      ...this.components.map(comp => new FloatField(comp.max())),
      ...this.components.flatMap(comp => [
        ...comp.keyframes.map(e => new FloatField(e.position)),
        ...comp.keyframes.map(e => new FloatField(e.value)),
        ...comp.keyframes.map(e => new FloatField(e.t1)),
        ...comp.keyframes.map(e => new FloatField(e.t2)),
      ])
    ]
  }

  static fromFields<T extends ValueType>(
    valueType: T,
    loop: boolean,
    modifiers: IModifier<T>[],
    fieldValues: number[]
  ): ComponentSequenceProperty<T> {
    let offset = 1 + 3 * (valueType + 1)
    return new ComponentSequenceProperty(loop, arrayOf(valueType + 1, i => {
      return SequenceProperty.fromFields(ValueType.Scalar, PropertyFunction.Hermite, false, [], [
        fieldValues[1 + i], 0, 0,
        ...fieldValues.slice(offset, offset = offset + 4 * fieldValues[1 + i])
      ]).keyframes
    }) as GenComponents<IHermiteKeyframe<ValueType.Scalar>[], T>, modifiers)
  }

  serialize(options?: FXRSerializeOptions) {
    const o: {
      function: 'ComponentHermite'
      loop: boolean
      components: IHermiteKeyframe<ValueType.Scalar>[][]
      modifiers?: any[]
    } = {
      function: PropertyFunction[this.function] as 'ComponentHermite',
      loop: this.loop,
      components: this.components.map(e => e.keyframes.map(f => ({
        position: f.position,
        value: f.value,
        t1: f.t1,
        t2: f.t2,
      })))
    }
    if (this.modifiers.length > 0) o.modifiers = this.modifiers.map(e => e.serialize(options))
    return o
  }

  static fromJSON<T extends ValueType>({
    components,
    loop = false,
    modifiers = []
  }: {
    components: GenComponents<IHermiteKeyframe<ValueType.Scalar>[], T>
    loop: boolean
    modifiers?: any[]
  }): ComponentSequenceProperty<T> {
    return new ComponentSequenceProperty(
      loop,
      components,
      (modifiers ?? []).map(mod => Modifier.fromJSON(mod) as IModifier<T>)
    )
  }

  scale(factor: TypeMap.PropertyValue[T] | number) {
    for (const [i, comp] of this.components.entries()) {
      comp.scale(typeof factor === 'number' ? factor : factor[i])
    }
    scalePropMods(this, factor)
    return this
  }

  add(summand: TypeMap.PropertyValue[T] | number) {
    for (const [i, comp] of this.components.entries()) {
      comp.add(typeof summand === 'number' ? summand : summand[i])
    }
    return this
  }

  valueAt(arg: number): TypeMap.PropertyValue[T] {
    if (this.loop) {
      const duration = this.duration
      if (duration === 0) {
        // Return NaN when the property loops and the duration is 0.
        // This matches what the games do in the same case.
        return (
          this.valueType === ValueType.Scalar ?
            NaN :
            arrayOf(this.componentCount, _ => NaN)
        ) as TypeMap.PropertyValue[T]
      }
      arg %= duration
    }
    return (
      this.valueType === ValueType.Scalar ?
        this.components[0].valueAt(arg)
      : this.components.map(e => e.valueAt(arg))
    ) as TypeMap.PropertyValue[T]
  }

  clone(): ComponentSequenceProperty<T> {
    return new ComponentSequenceProperty(
      this.loop,
      this.components.map(
        e => e.keyframes.map(f => Keyframe.copy(f))
      ) as GenComponents<IHermiteKeyframe<ValueType.Scalar>[], T>,
      this.modifiers.map(e => e.clone())
    )
  }

  separateComponents(): ComponentSequenceProperty<ValueType.Scalar>[] {
    if (this.valueType === ValueType.Scalar) {
      return [this.clone() as ComponentSequenceProperty<ValueType.Scalar>]
    } else {
      const mods = this.modifiers.map(e => e.separateComponents())
      return arrayOf(this.componentCount, i => new ComponentSequenceProperty(
        this.loop,
        [this.components[i].keyframes],
        mods.map(comps => comps[i]).filter(Modifier.isEffective)
      ))
    }
  }

  /**
   * If all components have the same number of keyframes and keyframe
   * positions, the property can be converted to a {@link HermiteProperty}
   * without losing any information or functionality.
   * 
   * This method performs these checks and returns a boolean indicating if the
   * property can be simplified this way or not.
   */
  canBeSimplified(): boolean {
    const kfs = this.components[0].keyframes
    const l = kfs.length
    return this.valueType === ValueType.Scalar || this.components.slice(1).every(c =>
      c.keyframes.length === l &&
      c.keyframes.every((e, i) => e.position === kfs[i].position)
    )
  }

  /**
   * Combines the components to form a new {@link SequenceProperty} with
   * roughly the same values and the same modifiers.
   * 
   * Note that linear interpolation is used to approximate both sampling of the
   * components as well as the function of the output property, meaning that
   * non-linear curves used are lost in this conversion.
   */
  combineComponents() {
    if (this.canBeSimplified()) {
      if (this.valueType === ValueType.Scalar) {
        return new HermiteProperty(this.loop, this.components[0].keyframes).withModifiers(
          ...(this.modifiers as IModifier<ValueType.Scalar>[])
        ) as HermiteProperty<T>
      }
      return new HermiteProperty(this.loop, arrayOf(this.components[0].keyframes.length, i => new HermiteKeyframe(
        this.components[0].keyframes[i].position,
        this.components.map(c => c.keyframes[i].value) as Vector,
        this.components.map(c => c.keyframes[i].t1) as Vector,
        this.components.map(c => c.keyframes[i].t2) as Vector,
      ))).withModifiers(...this.modifiers) as HermiteProperty<T>
    }
    const positions = new Set<number>
    for (const comp of this.components) {
      for (const keyframe of comp.keyframes) {
        positions.add(keyframe.position)
      }
    }
    const keyframes = filterMillisecondDiffs(interpolateSegments(Array.from(positions).sort((a, b) => a - b), 0.1, 40))
      .map(e => new Keyframe(e, this.valueAt(e)))
    return new LinearProperty(this.loop, keyframes).withModifiers(...this.modifiers.map(mod => mod.clone()))
  }

  min(): TypeMap.PropertyValue[T] {
    if (this.valueType == ValueType.Scalar) {
      return this.components[0].min() as TypeMap.PropertyValue[T]
    } else {
      return this.components.map(c => c.min()) as TypeMap.PropertyValue[T]
    }
  }

  max(): TypeMap.PropertyValue[T] {
    if (this.valueType == ValueType.Scalar) {
      return this.components[0].max() as TypeMap.PropertyValue[T]
    } else {
      return this.components.map(c => c.max()) as TypeMap.PropertyValue[T]
    }
  }

  minify(): Property<T, PropertyFunction> {
    if (
      this.components.every(c =>
        c.keyframes.length === 1 ||
        c.keyframes.slice(1).every(kf => Keyframe.equal(c.keyframes[0], kf))
      )
    ) {
      return new ConstantProperty<T>(
        this.valueType === ValueType.Scalar ?
          this.components[0].keyframes[0].value as TypeMap.PropertyValue[T] :
          this.components.map(c => c.keyframes[0].value) as TypeMap.PropertyValue[T]
      ).withModifiers(
        ...this.modifiers.map(mod => mod.minify()).filter(Modifier.isEffective)
      )
    }
    if (this.canBeSimplified()) return this.combineComponents().minify()
    const clone = this.clone()
    clone.modifiers = clone.modifiers.map(mod => mod.minify()).filter(Modifier.isEffective)
    return clone
  }

  get duration() { return Math.max(0, ...this.components.flatMap(c => c.keyframes.map(kf => kf.position))) }
  set duration(value: number) {
    const factor = value / this.duration
    for (const c of this.components) {
      for (const kf of c.keyframes) {
        kf.position *= factor
      }
    }
  }

}

class ConstantProperty<T extends ValueType> extends ValueProperty<T> {

  constructor(value: TypeMap.PropertyValue[T], modifiers?: IModifier<T>[]) {
    super(getValueType(value), value, modifiers)
  }

}

class SteppedProperty<T extends ValueType> extends SequenceProperty<T, PropertyFunction.Stepped> {

  constructor(loop: boolean, keyframes: IBasicKeyframe<T>[]) {
    if (keyframes.length === 0) {
      throw new Error ('Sequence properties must have at least one keyframe.')
    }
    const comps = Array.isArray(keyframes[0].value) ? keyframes[0].value.length : 1
    super(comps - 1 as T, PropertyFunction.Stepped, loop, keyframes)
  }

  /**
   * Creates a new sequence property that steps from one value to another.
   * @param duration The duration of the animation.
   * @param startValue The value at the start of the animation.
   * @param endValue The value at the end of the animation.
   */
  static basic<T extends ValueType>(
    duration: number,
    startValue: TypeMap.PropertyValue[T],
    endValue: TypeMap.PropertyValue[T]
  ): SteppedProperty<T> {
    return new SteppedProperty(false, [
      new Keyframe(0, startValue),
      new Keyframe(duration, endValue),
    ])
  }

}

class LinearProperty<T extends ValueType> extends SequenceProperty<T, PropertyFunction.Linear> {

  constructor(loop: boolean, keyframes: IBasicKeyframe<T>[]) {
    if (keyframes.length === 0) {
      throw new Error ('Sequence properties must have at least one keyframe.')
    }
    const comps = Array.isArray(keyframes[0].value) ? keyframes[0].value.length : 1
    super(comps - 1 as T, PropertyFunction.Linear, loop, keyframes)
  }

  /**
   * Creates a new sequence property that linearly transitions from one value
   * to another over a given duration.
   * @param loop Controls whether the animation should loop or not.
   * @param duration The duration of the animation.
   * @param startValue The value at the start of the animation.
   * @param endValue The value at the end of the animation.
   */
  static basic<T extends ValueType>(
    loop: boolean,
    duration: number,
    startValue: TypeMap.PropertyValue[T],
    endValue: TypeMap.PropertyValue[T]
  ): LinearProperty<T> {
    return new LinearProperty(loop, [
      new Keyframe(0, startValue),
      new Keyframe(duration, endValue),
    ])
  }

  /**
   * Creates a new sequence property that linearly transitions from one value
   * to another at a given speed.
   * @param loop Controls whether the animation should loop or not.
   * @param speed The speed for the animation to move at.
   * @param startValue The value at the start of the animation.
   * @param endValue The value at the end of the animation.
   */
  static withSpeed<T extends ValueType>(
    loop: boolean,
    speed: number,
    startValue: TypeMap.PropertyValue[T],
    endValue: TypeMap.PropertyValue[T]
  ): LinearProperty<T> {
    if (getComponentCount(startValue) !== getComponentCount(endValue)) {
      throw new Error('Start and end values do not have the same number of components.')
    }
    const ss = isScalarValue(startValue)
    const es = isScalarValue(endValue)
    const duration = ss && es ?
      Math.abs(endValue - startValue) / speed :
      !ss && !es ?
        Math.hypot(...startValue.map((e, i) => e - endValue[i])) / speed :
        1
    return LinearProperty.basic(loop, duration, startValue, endValue)
  }

  /**
   * Creates a new linear property that approximates a power function.
   * @param loop Controls whether the animation should loop or not.
   * @param exponent The exponent used in the power function. For example,
   * setting this to values greater than 1 will make the property value change
   * slowly at the start, but get faster and faster until it reaches the end.
   * @param keyframeCount How many keyframes to use for the approximation. Must
   * be greater than or equal to 2.
   * Using higher values will produce a smoother curve. Setting it to 2 will
   * make it linear, which means you might as well use the {@link basic} 
   * method instead of this.
   * @param duration The duration of the animation.
   * @param startValue The value at the start of the animation.
   * @param endValue The value at the end of the animation.
   */
  static power<T extends ValueType>(
    loop: boolean,
    exponent: number,
    keyframeCount: number,
    duration: number,
    startValue: TypeMap.PropertyValue[T],
    endValue: TypeMap.PropertyValue[T]
  ): LinearProperty<T> {
    if (keyframeCount < 2) {
      throw new Error('Property stop count must be greater than or equal to 2.')
    }
    if (Array.isArray(startValue) && Array.isArray(endValue)) {
      return new LinearProperty(loop, arrayOf(keyframeCount, i => new Keyframe(
        i / (keyframeCount - 1) * duration,
        startValue.map((e: number, j: number) => lerp(e, endValue[j], (i / (keyframeCount - 1)) ** exponent)) as TypeMap.PropertyValue[T]
      )))
    } else if (typeof startValue === 'number' && typeof endValue === 'number') {
      return new LinearProperty(loop, arrayOf(keyframeCount, i => new Keyframe(
        i / (keyframeCount - 1) * duration,
        lerp(startValue, endValue, (i / (keyframeCount - 1)) ** exponent) as TypeMap.PropertyValue[T]
      )))
    } else {
      throw new Error('startValue and endValue must be of the same type.')
    }
  }

  /**
   * Creates a new linear property that approximates a sine wave.
   * @param min The value used when the sine wave is at its minimum.
   * @param max The value used when the sine wave is at its maximum.
   * @param period The period of the sine wave.
   * @param phaseShift The phase shift of the sine wave. 1 shifts it by one
   * period.
   * @param stops The number of stops to use to approximate the sine wave.
   * Higher values result in a smoother curve. Defaults to 21.
   */
  static sine<T extends ValueType>(
    min: TypeMap.PropertyValue[T],
    max: TypeMap.PropertyValue[T],
    period: number,
    phaseShift: number = 0,
    stops: number = 21
  ): LinearProperty<T> {
    if (Array.isArray(min) && Array.isArray(max)) {
      return new LinearProperty(true, arrayOf(stops, i => new Keyframe(
        i / (stops - 1) * period,
        min.map((e, j) => (max[j] + e) / 2 + (max[j] - e) / 2 * Math.sin(
          (i / (stops - 1) + phaseShift) * Math.PI * 2
        )) as TypeMap.PropertyValue[T]
      )))
    } else if (typeof min === 'number' && typeof max === 'number') {
      return new LinearProperty(true, arrayOf(stops, i => new Keyframe(
        i / (stops - 1) * period,
        (max + min) / 2 + (max - min) / 2 * Math.sin(
          (i / (stops - 1) + phaseShift) * Math.PI * 2
        ) as TypeMap.PropertyValue[T]
      )))
    } else {
      throw new Error('min and max must be of the same type.')
    }
  }

}

class BezierProperty<T extends ValueType> extends SequenceProperty<T, PropertyFunction.Bezier> {

  constructor(loop: boolean, keyframes: IBezierKeyframe<T>[]) {
    if (keyframes.length === 0) {
      throw new Error ('Sequence properties must have at least one keyframe.')
    }
    const comps = Array.isArray(keyframes[0].value) ? keyframes[0].value.length : 1
    super(comps - 1 as T, PropertyFunction.Bezier, loop, keyframes)
  }

}

class HermiteProperty<T extends ValueType> extends SequenceProperty<T, PropertyFunction.Hermite> {

  constructor(loop: boolean, keyframes: IHermiteKeyframe<T>[]) {
    if (keyframes.length === 0) {
      throw new Error ('Sequence properties must have at least one keyframe.')
    }
    const comps = Array.isArray(keyframes[0].value) ? keyframes[0].value.length : 1
    super(comps - 1 as T, PropertyFunction.Hermite, loop, keyframes)
  }

  /**
   * Creates a new sequence property that smoothly transitions from one value
   * to another using an easing function that starts slowly, speeds up towards
   * the midpoint, and then slows down towards the end.
   * 
   * This is very similar to the {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#ease ease}
   * keyword in CSS.
   * @param loop Controls whether the animation should loop or not.
   * @param duration The duration of the animation.
   * @param startValue The value at the start of the animation.
   * @param endValue The value at the end of the animation.
   */
  static ease<T extends ValueType>(
    loop: boolean,
    duration: number,
    startValue: TypeMap.PropertyValue[T],
    endValue: TypeMap.PropertyValue[T]
  ): HermiteProperty<T> {
    return new HermiteProperty(loop, [
      HermiteKeyframe.ease(0, startValue),
      HermiteKeyframe.easeInOut(duration, endValue),
    ])
  }

  /**
   * Creates a new sequence property that smoothly transitions from one value
   * to another using an easing function that starts slowly and speeds up
   * towards the end.
   * 
   * This is very similar to the {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#ease-in ease-in}
   * keyword in CSS.
   * @param loop Controls whether the animation should loop or not.
   * @param duration The duration of the animation.
   * @param startValue The value at the start of the animation.
   * @param endValue The value at the end of the animation.
   */
  static easeIn<T extends ValueType>(
    loop: boolean,
    duration: number,
    startValue: TypeMap.PropertyValue[T],
    endValue: TypeMap.PropertyValue[T]
  ): HermiteProperty<T> {
    return new HermiteProperty(loop, [
      HermiteKeyframe.easeIn(0, startValue),
      HermiteKeyframe.easeInOut(duration, endValue),
    ])
  }

  /**
   * Creates a new sequence property that smoothly transitions from one value
   * to another using an easing function that starts fast and slows down
   * towards the end.
   * 
   * This is very similar to the {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#ease-out ease-out}
   * keyword in CSS.
   * @param loop Controls whether the animation should loop or not.
   * @param duration The duration of the animation.
   * @param startValue The value at the start of the animation.
   * @param endValue The value at the end of the animation.
   */
  static easeOut<T extends ValueType>(
    loop: boolean,
    duration: number,
    startValue: TypeMap.PropertyValue[T],
    endValue: TypeMap.PropertyValue[T]
  ): HermiteProperty<T> {
    return new HermiteProperty(loop, [
      HermiteKeyframe.easeOut(0, startValue),
      HermiteKeyframe.easeInOut(duration, endValue),
    ])
  }

  /**
   * Creates a new sequence property that smoothly transitions from one value
   * to another using an easing function that starts slowly, speeds up towards
   * the midpoint, and then slows down towards the end.
   * 
   * This is very similar to the {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#ease-in-out ease-in-out}
   * keyword in CSS.
   * @param loop Controls whether the animation should loop or not.
   * @param duration The duration of the animation.
   * @param startValue The value at the start of the animation.
   * @param endValue The value at the end of the animation.
   */
  static easeInOut<T extends ValueType>(
    loop: boolean,
    duration: number,
    startValue: TypeMap.PropertyValue[T],
    endValue: TypeMap.PropertyValue[T]
  ): HermiteProperty<T> {
    return new HermiteProperty(loop, [
      HermiteKeyframe.easeInOut(0, startValue),
      HermiteKeyframe.easeInOut(duration, endValue),
    ])
  }

  /**
   * Creates a new sequence property that transitions from one value to another
   * using an easing function that starts very slow, but speeds up very quickly
   * near the end.
   * @param loop Controls whether the animation should loop or not.
   * @param duration The duration of the animation.
   * @param startValue The value at the start of the animation.
   * @param endValue The value at the end of the animation.
   */
  static launch<T extends ValueType>(
    loop: boolean,
    duration: number,
    startValue: TypeMap.PropertyValue[T],
    endValue: TypeMap.PropertyValue[T]
  ): HermiteProperty<T> {
    return new HermiteProperty(loop, [
      HermiteKeyframe.launch(0, startValue),
      HermiteKeyframe.easeInOut(duration, endValue),
    ])
  }

  /**
   * Creates a new sequence property that transitions from one value to another
   * using an easing function that starts very fast, but very quickly slows
   * down.
   * @param loop Controls whether the animation should loop or not.
   * @param duration The duration of the animation.
   * @param startValue The value at the start of the animation.
   * @param endValue The value at the end of the animation.
   */
  static explosive<T extends ValueType>(
    loop: boolean,
    duration: number,
    startValue: TypeMap.PropertyValue[T],
    endValue: TypeMap.PropertyValue[T]
  ): HermiteProperty<T> {
    return new HermiteProperty(loop, [
      HermiteKeyframe.explosive(0, startValue),
      HermiteKeyframe.easeInOut(duration, endValue),
    ])
  }

}

/**
 * Creates a property with a {@link RandomDeltaModifier} and a mean value,
 * effectively creating a property with a random values around a mean.
 * @param mean The average value. Used as the value for the property itself.
 * @param devation How far away from the mean the values generated by the
 * property can be.
 * @param seed A seed or set of seeds for the random number generator to use
 * to generate the random property values. Leave this empty if you want a
 * random seed. See {@link randomSeed} if you want a random seed *and* to link
 * multiple values together.
 */
function RandomDeltaProperty<T extends ValueType>(
  mean: TypeMap.PropertyValue[T],
  devation: TypeMap.PropertyValue[T],
  seed?: TypeMap.PropertyValue[T]
): ConstantProperty<T> {
  return new ConstantProperty<T>(mean).withModifiers(
    new RandomDeltaModifier(devation, seed)
  )
}

/**
 * Creates a property with a {@link RandomRangeModifier} and no value,
 * effectively creating a property with a random value in a given range.
 * @param minValue The lower bound of the range of possible values for the
 * property.
 * @param maxValue The upper bound of the range of possible values for the
 * property.
 * @param seed A seed or set of seeds for the random number generator to use
 * to generate the random property values. Leave this empty if you want a
 * random seed. See {@link randomSeed} if you want a random seed *and* to link
 * multiple values together.
 */
function RandomRangeProperty<T extends ValueType>(
  minValue: TypeMap.PropertyValue[T],
  maxValue: TypeMap.PropertyValue[T],
  seed?: TypeMap.PropertyValue[T]
): ConstantProperty<T> {
  return new ConstantProperty<T>(
    (Array.isArray(minValue) ? Array(minValue.length).fill(0) as Vector : 0) as TypeMap.PropertyValue[T]
  ).withModifiers(
    new RandomRangeModifier(minValue, maxValue, seed)
  )
}

/**
 * Creates a property with a {@link RandomFractionModifier} and a mean value,
 * effectively creating a property with a random values around a mean based on
 * a fraction of that mean value.
 * @param mean The average value. Used as the value for the property itself.
 * @param devationFract How far away from the mean the values generated by the
 * property can be, as a fraction of the `mean` value.
 * @param seed A seed or set of seeds for the random number generator to use
 * to generate the random property values. Leave this empty if you want a
 * random seed. See {@link randomSeed} if you want a random seed *and* to link
 * multiple values together.
 */
function RandomFractionProperty<T extends ValueType>(
  mean: TypeMap.PropertyValue[T],
  devationFract: TypeMap.PropertyValue[T],
  seed?: TypeMap.PropertyValue[T]
): ConstantProperty<T> {
  return new ConstantProperty<T>(mean).withModifiers(
    new RandomFractionModifier(devationFract, seed)
  )
}

/**
 * Generates a rainbow color animation property with a configurable duration.
 * @param duration How long it takes to go around the entire hue circle in
 * seconds. Defaults to 4 seconds.
 * @param loop Controls whether the animation should loop or not. Defaults to
 * true.
 * @returns 
 */
function RainbowProperty(duration: number = 4, loop: boolean = true) {
  const unit = duration / 6
  return new LinearProperty(loop, [
    new Keyframe(0,        [1, 0, 0, 1]),
    new Keyframe(unit,     [1, 0, 1, 1]),
    new Keyframe(unit * 2, [0, 0, 1, 1]),
    new Keyframe(unit * 3, [0, 1, 1, 1]),
    new Keyframe(unit * 4, [0, 1, 0, 1]),
    new Keyframe(unit * 5, [1, 1, 0, 1]),
    new Keyframe(duration, [1, 0, 0, 1]),
  ])
}

/**
 * Creates a property with different values depending on the "Display Blood"
 * setting.
 * @param onValue The value of the property when the "Display Blood" setting
 * is set to "On".
 * @param mildValue The value of the property when the "Display Blood" setting
 * is set to "Mild".
 * @param offValue The value of the property when the "Display Blood" setting
 * is set to "Off".
 * @returns 
 */
function BloodVisibilityProperty<T extends ValueType>(
  onValue: TypeMap.PropertyValue[T],
  mildValue: TypeMap.PropertyValue[T],
  offValue: TypeMap.PropertyValue[T]
): ConstantProperty<T> {
  return new ConstantProperty<T>((typeof onValue === 'number' ? 1 : onValue.map(() => 1)) as TypeMap.PropertyValue[T]).withModifiers(
    BloodVisibilityModifier(onValue, mildValue, offValue)
  )
}

//#region Modifier
namespace Modifier {

  export function fromJSON<T extends ValueType>(obj: any): IModifier<T> {
    if ('fields' in obj || 'properties' in obj || !(obj.type in ModifierType)) {
      return new GenericModifier(
        obj.type,
        obj.valueType,
        obj.fields.map((e: {
          type: TypeMap.FieldTypeName[FieldType.Integer | FieldType.Float],
          value: number
        }) => Field.fromJSON<FieldType.Integer | FieldType.Float>(e)),
        obj.properties.map((e: any) => Property.fromJSON(e)),
      )
    }
    switch (ModifierType[obj.type as string]) {
      case ModifierType.RandomDelta:
        return new RandomDeltaModifier(obj.max, obj.seed)
      case ModifierType.RandomRange:
        return new RandomRangeModifier(obj.min, obj.max, obj.seed)
      case ModifierType.RandomFraction:
        return new RandomFractionModifier(obj.max, obj.seed)
      case ModifierType.ExternalValue1:
        return new ExternalValue1Modifier(obj.externalValue, Property.fromJSON(obj.factor) as any)
      case ModifierType.ExternalValue2:
        return new ExternalValue2Modifier(obj.externalValue, Property.fromJSON(obj.factor) as any)
    }
  }

  export const enumBValues = {
    [Game.DarkSouls3]: {
      [ModifierType.RandomDelta]: 0,
      [ModifierType.ExternalValue1]: 4,
      [ModifierType.RandomFraction]: 8,
    },
    [Game.Sekiro]: {
      [ModifierType.RandomDelta]: 0,
      [ModifierType.RandomRange]: 4,
      [ModifierType.ExternalValue1]: 8,
      [ModifierType.RandomFraction]: 12,
    },
    [Game.EldenRing]: {
      [ModifierType.RandomDelta]: 0,
      [ModifierType.RandomRange]: 4,
      [ModifierType.ExternalValue1]: 8,
      [ModifierType.ExternalValue2]: 12,
      [ModifierType.RandomFraction]: 16,
    },
    [Game.ArmoredCore6]: {
      [ModifierType.RandomDelta]: 0,
      [ModifierType.RandomRange]: 4,
      [ModifierType.ExternalValue1]: 8,
      [ModifierType.ExternalValue2]: 12,
      [ModifierType.RandomFraction]: 16,
    },
    [Game.Nightreign]: {
      [ModifierType.RandomDelta]: 0,
      [ModifierType.RandomRange]: 4,
      [ModifierType.ExternalValue1]: 8,
      [ModifierType.ExternalValue2]: 12,
      [ModifierType.RandomFraction]: 16,
    },
  }

  export function enumAToType(typeEnumA: number): ModifierType {
    return (typeEnumA >>> 12 & 0b11) << 4 | typeEnumA >>> 4 & 0b1111
  }

  export function typeToEnumA(type: ModifierType, valueType: ValueType = ValueType.Scalar) {
    return (type >>> 4 | 0b1100) << 12 | (type & 0b1111) << 4 | valueType
  }

  export function vectorFromScalar<T extends ValueType>(mod: IModifier<ValueType.Scalar>, vt: T): IModifier<any> {
    const cc = vt + 1
    if (mod instanceof RandomDeltaModifier) {
      return new RandomDeltaModifier(
        arrayOf(cc, () => mod.max) as TypeMap.PropertyValue[T],
        arrayOf(cc, () => mod.seed) as TypeMap.PropertyValue[T],
      )
    } else if (mod instanceof RandomRangeModifier) {
      return new RandomRangeModifier(
        arrayOf(cc, () => mod.min) as TypeMap.PropertyValue[T],
        arrayOf(cc, () => mod.max) as TypeMap.PropertyValue[T],
        arrayOf(cc, () => mod.seed) as TypeMap.PropertyValue[T],
      )
    } else if (mod instanceof RandomFractionModifier) {
      return new RandomFractionModifier(
        arrayOf(cc, () => mod.max) as TypeMap.PropertyValue[T],
        arrayOf(cc, () => mod.seed) as TypeMap.PropertyValue[T],
      )
    } else if (mod instanceof ExternalValue1Modifier || mod instanceof ExternalValue2Modifier) {
      let prop = mod.factor
      if (prop instanceof ValueProperty) {
        prop = new ValueProperty(vt, arrayOf(cc,
          () => (prop as ValueProperty<ValueType.Scalar>).value as number
        ) as TypeMap.PropertyValue[T])
      } else if (prop instanceof SequenceProperty) {
        prop = new SequenceProperty(vt, prop.function, prop.loop, prop.keyframes.map(kf =>
          new Keyframe(kf.position, arrayOf(cc, () => kf.value) as TypeMap.PropertyValue[T])
        ))
      } else if (prop instanceof ComponentSequenceProperty) {
        prop = new ComponentSequenceProperty(prop.loop,
          arrayOf(cc,
            () => (prop as ComponentSequenceProperty<any>).components[0].keyframes.map(kf => Keyframe.copy(kf))
          ) as GenComponents<IHermiteKeyframe<ValueType.Scalar>[], ValueType>
        )
      }
      return new (mod.constructor as any)(mod.externalValue, prop)
    }
  }

  export function multPropertyValue<T extends ValueType>(mod: IModifier<T>, v: TypeMap.PropertyValue[T] | number): IModifier<T> {
    mod = mod.clone()
    if (typeof v === 'number') {
      if (mod instanceof RandomDeltaModifier) {
        if (mod.valueType === ValueType.Scalar) {
          mod.max *= v
        } else for (let i = mod.valueType; i >= 0; i--) {
          mod.max[i] *= v
        }
      } else if (mod instanceof RandomRangeModifier) {
        if (mod.valueType === ValueType.Scalar) {
          mod.min *= v
          mod.max *= v
        } else for (let i = mod.valueType; i >= 0; i--) {
          mod.min[i] *= v
          mod.max[i] *= v
        }
      }
    } else {
      if (mod instanceof RandomDeltaModifier) {
        if (mod.valueType === ValueType.Scalar) {
          mod.max *= v[0]
        } else for (let i = mod.valueType; i >= 0; i--) {
          mod.max[i] *= v[i]
        }
      } else if (mod instanceof RandomRangeModifier) {
        if (mod.valueType === ValueType.Scalar) {
          mod.min *= v[0]
          mod.max *= v[0]
        } else for (let i = mod.valueType; i >= 0; i--) {
          mod.min[i] *= v[i]
          mod.max[i] *= v[i]
        }
      }
    }
    return mod
  }

  export function isEffective(mod: IModifier<ValueType>): boolean {
    if (mod instanceof GenericModifier) {
      return true
    }
    if (mod instanceof RandomDeltaModifier || mod instanceof RandomFractionModifier) {
      if (mod.valueType === ValueType.Scalar) {
        return mod.max !== 0 && mod.seed !== 0
      } else {
        type T = RandomDeltaModifier<VectorValueType> | RandomFractionModifier<VectorValueType>
        return (
          (mod as T).max.some(e => e !== 0) &&
          (mod as T).seed.some(e => e !== 0)
        )
      }
    }
    if (mod instanceof RandomRangeModifier) {
      if (mod.valueType === ValueType.Scalar) {
        return (mod.min !== 0 || mod.max !== 0) && mod.seed !== 0
      } else {
        type T = RandomRangeModifier<VectorValueType>
        return (
          (
            (mod as T).min.some(e => e !== 0) ||
            (mod as T).max.some(e => e !== 0)
          ) &&
          (mod as T).seed.some(e => e !== 0)
        )
      }
    }
    if (mod instanceof ExternalValue1Modifier || mod instanceof ExternalValue2Modifier) {
      if (mod.factor instanceof ValueProperty) {
        return !mod.factor.isOne
      }
      if (mod.factor instanceof SequenceProperty) {
        switch (mod.factor.function) {
          case PropertyFunction.Stepped:
          case PropertyFunction.Linear:
          case PropertyFunction.Hermite:
            return mod.factor.keyframes.some(e => e.value !== 1)
        }
      }
      return mod.factor !== 1
    }
  }

}

/**
 * This is a generic modifier class that has a similar structure to modifiers
 * in the file format. It is only intended to be used as a fallback or for
 * research, and usage of it will greatly limit various functions in the
 * library. Do not use it unless you know what you're doing.
 */
class GenericModifier<T extends ValueType> implements IModifier<T> {

  constructor(
    public readonly type: ModifierType,
    public readonly valueType: T,
    public fields: Field<FieldType>[],
    public properties: IProperty<T, PropertyFunction>[],
  ) {}

  getFieldCount(): number {
    return fieldsCount(this.fields)
  }

  getFields(): Field<FieldType>[] {
    return this.fields
  }

  getPropertyCount(): number {
    return this.properties.length
  }

  getProperties(game: Game): AnyProperty[] {
    return this.properties.map(prop => prop.for(game) as AnyProperty)
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions) {
    const o: {
      type: string
      valueType: T
      fields?: any[]
      properties?: any[]
    } = {
      type: ModifierType[this.type],
      valueType: this.valueType
    }
    if (this.fields.length !== 0) {
      o.fields = this.fields.map(e => e.serialize(options))
    }
    if (this.properties.length !== 0) {
      o.properties = this.properties.map(e => e.serialize(options))
    }
    return o
  }

  clone(): GenericModifier<T> {
    return new GenericModifier(
      this.type,
      this.valueType,
      this.fields.map(e => e.clone()),
      this.properties.map(e => e.clone())
    )
  }

  separateComponents(): IModifier<ValueType.Scalar>[] {
    throw new Error('Generic modifiers cannot be split into component modifiers.')
  }

  minify(): GenericModifier<T> {
    return this
  }

}

/**
 * Makes a property's value randomly vary by up to a given maximum from the
 * property's base value. In other words, if `p` is the property's base value
 * and `max` is the {@link max maximum difference}, the property's modified
 * value will be between `p - max` and `p + max`.
 */
class RandomDeltaModifier<T extends ValueType> implements IModifier<T> {

  readonly type: ModifierType = ModifierType.RandomDelta
  readonly valueType: T

  constructor(
    public max: TypeMap.PropertyValue[T],
    public seed: TypeMap.PropertyValue[T] = randomSeed(getValueType(max)) as TypeMap.PropertyValue[T]
  ) {
    this.valueType = getValueType(max)
    if (this.valueType !== getValueType(seed)) {
      throw new Error('Invalid seed type. Seed type must match value type.')
    }
  }

  getFieldCount(): number {
    return (this.valueType + 1) * 2
  }

  getFields(): NumericalField[] {
    if (typeof this.max === 'number') {
      return [
        new IntField(this.seed as number),
        new FloatField(this.max),
      ]
    } else {
      return [
        ...(this.seed as Vector).map(e => new IntField(e)),
        ...this.max.map(e => new FloatField(e)),
      ]
    }
  }

  getPropertyCount(): number {
    return 0
  }

  getProperties(game: Game): AnyProperty[] {
    return []
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions) {
    return {
      type: ModifierType[this.type],
      seed: this.seed,
      max: this.max
    }
  }

  clone(): RandomDeltaModifier<T> {
    return new RandomDeltaModifier(
      typeof this.max === 'number' ? this.max : this.max.slice() as TypeMap.PropertyValue[T],
      typeof this.seed === 'number' ? this.seed : this.seed.slice() as TypeMap.PropertyValue[T]
    )
  }

  separateComponents(): IModifier<ValueType.Scalar>[] {
    if (this.valueType === ValueType.Scalar) {
      return [ this.clone() as IModifier<ValueType.Scalar> ]
    } else {
      return (this.max as Vector).map((e, i) => new RandomDeltaModifier(e, (this.seed as Vector)[i]))
    }
  }

  minify(): RandomDeltaModifier<T> {
    return this
  }

}

/**
 * Adds a random value in a given range to a property's value.
 */
class RandomRangeModifier<T extends ValueType> implements IModifier<T> {

  readonly type: ModifierType = ModifierType.RandomRange
  readonly valueType: T

  constructor(
    public min: TypeMap.PropertyValue[T],
    public max: TypeMap.PropertyValue[T],
    public seed: TypeMap.PropertyValue[T] = randomSeed(getValueType(min)) as TypeMap.PropertyValue[T]
  ) {
    this.valueType = getValueType(min)
    if (this.valueType !== getValueType(seed)) {
      throw new Error('Invalid seed type. Seed type must match value type.')
    }
  }

  getFieldCount(): number {
    return (this.valueType + 1) * 3
  }

  getFields(): NumericalField[] {
    if (this.valueType === ValueType.Scalar) {
      return [
        new IntField(this.seed as number),
        new FloatField(this.min as number),
        new FloatField(this.max as number),
      ]
    } else {
      return [
        ...(this.seed as Vector).map(e => new IntField(e)),
        ...(this.min as Vector).map(e => new FloatField(e)),
        ...(this.max as Vector).map(e => new FloatField(e)),
      ]
    }
  }

  getPropertyCount(): number {
    return 0
  }

  getProperties(game: Game): AnyProperty[] {
    return []
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions) {
    return {
      type: ModifierType[this.type],
      seed: this.seed,
      min: this.min,
      max: this.max
    }
  }

  clone(): RandomRangeModifier<T> {
    return new RandomRangeModifier(
      typeof this.min === 'number' ? this.min : this.min.slice() as TypeMap.PropertyValue[T],
      typeof this.max === 'number' ? this.max : this.max.slice() as TypeMap.PropertyValue[T],
      typeof this.seed === 'number' ? this.seed : this.seed.slice() as TypeMap.PropertyValue[T]
    )
  }

  separateComponents(): IModifier<ValueType.Scalar>[] {
    if (this.valueType === ValueType.Scalar) {
      return [ this.clone() as IModifier<ValueType.Scalar> ]
    } else {
      return (this.min as Vector).map((e, i) => new RandomRangeModifier(e, (this.max as Vector)[i], (this.seed as Vector)[i]))
    }
  }

  minify(): RandomRangeModifier<T> {
    return this
  }

}

/**
 * Makes a property's value randomly vary by up to a given maximum fraction
 * from the property's base value. In other words, if `p` is the property's
 * base value and `max` is the {@link max maximum fraction}, the property's
 * modified value will be between `p - p * max` and `p + p * max`.
 */
class RandomFractionModifier<T extends ValueType> implements IModifier<T> {

  readonly type: ModifierType = ModifierType.RandomFraction
  readonly valueType: T

  constructor(
    public max: TypeMap.PropertyValue[T],
    public seed: TypeMap.PropertyValue[T] = randomSeed(getValueType(max)) as TypeMap.PropertyValue[T]
  ) {
    this.valueType = getValueType(max)
    if (this.valueType !== getValueType(seed)) {
      throw new Error('Invalid seed type. Seed type must match value type.')
    }
  }

  getFieldCount(): number {
    return (this.valueType + 1) * 2
  }

  getFields(): NumericalField[] {
    if (typeof this.max === 'number') {
      return [
        new IntField(this.seed as number),
        new FloatField(this.max),
      ]
    } else {
      return [
        ...(this.seed as Vector).map(e => new IntField(e)),
        ...this.max.map(e => new FloatField(e)),
      ]
    }
  }

  getPropertyCount(): number {
    return 0
  }

  getProperties(game: Game): AnyProperty[] {
    return []
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions) {
    return {
      type: ModifierType[this.type],
      seed: this.seed,
      max: this.max
    }
  }

  clone(): RandomFractionModifier<T> {
    return new RandomFractionModifier(
      typeof this.max === 'number' ? this.max : this.max.slice() as TypeMap.PropertyValue[T],
      typeof this.seed === 'number' ? this.seed : this.seed.slice() as TypeMap.PropertyValue[T]
    )
  }

  separateComponents(): IModifier<ValueType.Scalar>[] {
    if (this.valueType === ValueType.Scalar) {
      return [ this.clone() as IModifier<ValueType.Scalar> ]
    }
    return (this.max as Vector).map((e, i) => new RandomFractionModifier(e, (this.seed as Vector)[i]))
  }

  minify(): RandomFractionModifier<T> {
    return this
  }

}

/**
 * Modifies a property's value by multiplying it with different values
 * depending on an {@link ExternalValue external value}.
 */
class ExternalValue1Modifier<T extends ValueType> implements IModifier<T> {

  readonly type: ModifierType = ModifierType.ExternalValue1
  readonly valueType: T

  constructor(
    public externalValue: AnyExternalValue,
    public factor: TypeMap.Property[T]
  ) {
    this.valueType = factor.valueType as T
  }

  getFieldCount(): number {
    return 1
  }

  getFields(): NumericalField[] {
    return [
      new IntField(this.externalValue)
    ]
  }

  getPropertyCount(): number {
    return 1
  }

  getProperties(game: Game): AnyProperty[] {
    return [
      this.factor.for(game)
    ]
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions) {
    return {
      type: ModifierType[this.type],
      externalValue: this.externalValue,
      factor: this.factor.serialize(options)
    }
  }

  clone(): ExternalValue1Modifier<T> {
    return new ExternalValue1Modifier(
      this.externalValue,
      this.factor.clone() as TypeMap.Property[T]
    )
  }

  separateComponents(): IModifier<ValueType.Scalar>[] {
    if (this.valueType === ValueType.Scalar) {
      return [ this.clone() as IModifier<ValueType.Scalar> ]
    }
    return this.factor.separateComponents().map(e => new ExternalValue1Modifier(this.externalValue, e))
  }

  minify(): ExternalValue1Modifier<T> {
    const clone = this.clone()
    clone.factor = clone.factor.minify() as TypeMap.Property[T]
    return clone
  }

}

class ExternalValue2Modifier<T extends ValueType> implements IModifier<T> {

  readonly type: ModifierType = ModifierType.ExternalValue2
  readonly valueType: T

  constructor(
    public externalValue: AnyExternalValue,
    public factor: TypeMap.Property[T]
  ) {
    this.valueType = factor.valueType as T
  }

  getFieldCount(): number {
    return 1
  }

  getFields(): NumericalField[] {
    return [
      new IntField(this.externalValue)
    ]
  }

  getPropertyCount(): number {
    return 1
  }

  getProperties(game: Game): AnyProperty[] {
    return [
      this.factor.for(game)
    ]
  }

  toJSON() { return this.serialize() }

  serialize(options?: FXRSerializeOptions) {
    return {
      type: ModifierType[this.type],
      externalValue: this.externalValue,
      factor: this.factor.serialize(options)
    }
  }

  clone(): ExternalValue2Modifier<T> {
    return new ExternalValue2Modifier(
      this.externalValue,
      this.factor.clone() as TypeMap.Property[T]
    )
  }

  separateComponents(): IModifier<ValueType.Scalar>[] {
    if (this.valueType === ValueType.Scalar) {
      return [ this.clone() as IModifier<ValueType.Scalar> ]
    }
    return this.factor.separateComponents().map(e => new ExternalValue2Modifier(this.externalValue, e))
  }

  minify(): ExternalValue2Modifier<T> {
    const clone = this.clone()
    clone.factor = clone.factor.minify() as TypeMap.Property[T]
    return clone
  }

}

/**
 * Creates a modifier that modifies a property's value by mutliplying it with
 * different values depending on the "Display Blood" setting.
 * @param onValue 
 * @param mildValue 
 * @param offValue 
 * @param modifierConstructor 
 * @returns 
 */
function BloodVisibilityModifier<T extends ValueType>(
  onValue: TypeMap.PropertyValue[T],
  mildValue: TypeMap.PropertyValue[T],
  offValue: TypeMap.PropertyValue[T],
  modifierConstructor: typeof ExternalValue1Modifier<T> | typeof ExternalValue2Modifier<T> = ExternalValue2Modifier<T>
): ExternalValue1Modifier<T> | ExternalValue2Modifier<T> {
  return new modifierConstructor(ExternalValue.EldenRing.BloodVisibility, new SteppedProperty<T>(false, [
    new Keyframe<T>(-1, offValue),
    new Keyframe<T>(0, onValue),
    new Keyframe<T>(1, mildValue),
  ]) as unknown as TypeMap.Property[T])
}

/**
 * Creates a property modifier that multiplies the property's value with
 * different values depending on if it's raining/snowing or not.
 * 
 * Only functional in Elden Ring.
 * @param clear The value when it's not raining or snowing.
 * @param precip The value when it's raining or snowing.
 */
function PrecipitationModifier<T extends ValueType>(
  clear: TypeMap.PropertyValue[T],
  precip: TypeMap.PropertyValue[T]
): ExternalValue1Modifier<T> {
  return new ExternalValue1Modifier(ExternalValue.EldenRing.Precipitation, new SteppedProperty<T>(false, [
    new Keyframe<T>(0, clear),
    new Keyframe<T>(1, precip),
  ]) as unknown as TypeMap.Property[T])
}

//#region Recolor
/**
 * Contains various functions related to recoloring effects.
 */
namespace Recolor {

  export type RecolorFunction = <T extends DataAction>(
    color: Vector4,
    config?: BasicConfig,
    action?: T,
    property?: keyof T
  ) => Vector4

  export type PaletteSlots = {
    CommonParticle: {
      modifier: any
      color1: any
      color2: any
      color3: any
      rgbMultiplier: any
      bloomColor: any
    }
    DistortionParticle: {
      modifier: any
      color: any
      rgbMultiplier: any
      bloomColor: any
    }
    BlurParticle: {
      modifier: any
      color: any
      rgbMultiplier: any
      bloomColor: any
    }
    Light: {
      diffuseColor: any
      diffuseMultiplier: any
      specularColor?: any
      specularMultiplier?: any
    }
    GPUParticle: {
      color: any
      rgbMultiplier: any
      colorMin: any
      colorMax: any
      bloomColor?: any
    }
    LensFlare: {
      color: any
      colorMultiplier: any
      bloomColor: any
    }
  }

  export interface ColorPalette {
    commonParticleNormal?: PaletteSlots['CommonParticle'][]
    commonParticleMultiply?: PaletteSlots['CommonParticle'][]
    commonParticleAdd?: PaletteSlots['CommonParticle'][]
    commonParticleSubtract?: PaletteSlots['CommonParticle'][]
    distortionParticle?: PaletteSlots['DistortionParticle'][]
    blurParticle?: PaletteSlots['BlurParticle'][]
    light?: PaletteSlots['Light'][]
    gpuParticle?: PaletteSlots['GPUParticle'][]
    lensFlare?: PaletteSlots['LensFlare'][]
  }

  export type WeightedColorPalette = {
    [K in keyof ColorPalette]: ColorPalette[K] extends (infer U)[]
      ? (U & { weight?: number })[]
      : ColorPalette[K]
  }

  /**
   * Create a new palette with the average of the entries in the given palette.
   * Each entry in the input palette may have a `weight` property that controls
   * how much the entry affects the average.
   * @param palette A color palette, with optional weights. The weights default
   * to 1 if not set.
   */
  export function weightedAveragePalette(palette: WeightedColorPalette): ColorPalette {
    const p: ColorPalette = {}
    for (const [k, v] of Object.entries(palette) as Entries<Recolor.WeightedColorPalette>) {
      const entries = []
      for (const entry of v) {
        entries.push({
          weight: 1,
          ...entry
        })
      }
      if (entries.length === 1) {
        p[k] = entries
        continue
      }
      const weightSum = entries.reduce((a, e) => a + e.weight!, 0)
      const obj: any = {}
      for (const entry of entries) {
        for (const p of Object.keys(entry)) if (p !== 'weight') {
          obj[p] = anyValueSum<AnyProperty>(
            Property.fromJSON(obj[p] ?? 0),
            anyValueMult(entry.weight / weightSum, Property.fromJSON(entry[p]))
          ).toJSON()
        }
      }
      p[k] = [obj]
    }
    return p
  }

  /**
   * Generates a color palette that can be used to recolor other nodes based on
   * the colors in the given nodes and their descendants.
   * @param sources An array of FXRs or nodes to sample colors from.
   * @param mode Controls the behavior of the color sampler. See
   * {@link PaletteMode} for more information.
   */
  export function generatePalette(sources: (FXR | Node)[], mode: PaletteMode = PaletteMode.Average) {
    const palette: Recolor.ColorPalette = {}
    function normalize<T>(val: AnyValue): T {
      if (val instanceof SequenceProperty || val instanceof ComponentSequenceProperty) {
        let clone = val.clone().minify()
        const extValMods = clone.modifiers.filter(mod => 
          mod instanceof ExternalValue1Modifier ||
          mod instanceof ExternalValue2Modifier
        )
        clone.modifiers = clone.modifiers.filter(mod => !(
          mod instanceof ExternalValue1Modifier ||
          mod instanceof ExternalValue2Modifier
        ))
        for (const mod of extValMods) {
          clone = anyValueMult(mod.factor.valueAt(0), clone as AnyValue)
        }
        if (clone instanceof SequenceProperty || clone instanceof ComponentSequenceProperty) {
          clone.duration = 1
        }
        return clone as T
      }
      return (val instanceof Property ? val.clone().minify() : val) as T
    }
    function nonWhiteVisible(color: Vector4Value) {
      return (
        color instanceof SequenceProperty ||
        color instanceof ComponentSequenceProperty ||
        (
          Array.isArray(color) &&
          color[3] !== 0 &&
          color.some(e => !f32Equal(e, 1))
        ) ||
        (
          color instanceof ValueProperty &&
          (color.value as Vector4)[3] !== 0 &&
          (color.value as Vector4).some(e => !f32Equal(e, 1))
        )
      )
    }
    function *walkConfigs(sources: (FXR | Node)[]) {
      for (const src of sources) {
        if (src instanceof FXR) {
          yield* src.root.walkConfigs()
        } else {
          yield* src.walkConfigs()
        }
      }
    }
    for (const config of walkConfigs(sources)) {
      if (config instanceof BasicConfig) {
        const a = config.appearance
        if (
          a instanceof PointSprite ||
          a instanceof Line ||
          a instanceof QuadLine ||
          a instanceof BillboardEx ||
          a instanceof MultiTextureBillboardEx ||
          a instanceof Model ||
          a instanceof RichModel ||
          a instanceof LegacyTracer ||
          a instanceof Tracer
        ) {
          if (!(config.particleModifier instanceof ParticleModifier)) continue
          let blendMode = 'blendMode' in a ? a.blendMode : BlendMode.Normal
          if (blendMode instanceof Property) {
            blendMode = blendMode.valueAt(0)
          }
          if (blendMode === BlendMode.Source || blendMode === BlendMode.Unk6) {
            blendMode = BlendMode.Normal
          } else if (blendMode === BlendMode.Unk0 || blendMode === BlendMode.Unk7) {
            blendMode = BlendMode.Add
          }
          const key = `commonParticle${BlendMode[blendMode]}` as KeysOfType<
            ColorPalette,
            PaletteSlots['CommonParticle'][]
          >
          if (key in palette && mode === PaletteMode.First) continue
          palette[key] ??= []
          palette[key].push({
            modifier: normalize(config.particleModifier.color),
            color1: normalize(a.color1),
            color2: normalize(a.color2),
            color3: normalize(a.color3),
            rgbMultiplier: normalize(a.rgbMultiplier),
            bloomColor: normalize(a.bloomColor),
          })
        } else if (a instanceof Distortion) {
          if (!(config.particleModifier instanceof ParticleModifier)) continue
          if ('distortionParticle' in palette && mode === PaletteMode.First) continue
          palette.distortionParticle ??= []
          palette.distortionParticle.push({
            modifier: normalize(config.particleModifier.color),
            color: normalize(a.color),
            rgbMultiplier: normalize(a.rgbMultiplier),
            bloomColor: normalize(a.bloomColor),
          })
        } else if (a instanceof RadialBlur) {
          if (!(config.particleModifier instanceof ParticleModifier)) continue
          if ('blurParticle' in palette && mode === PaletteMode.First) continue
          palette.blurParticle ??= []
          palette.blurParticle.push({
            modifier: normalize(config.particleModifier.color),
            color: normalize(a.color),
            rgbMultiplier: normalize(a.rgbMultiplier),
            bloomColor: normalize(a.bloomColor),
          })
        } else if (a instanceof PointLight || a instanceof SpotLight) {
          if ('light' in palette && mode === PaletteMode.First) continue
          palette.light ??= []
          palette.light.push({
            diffuseColor: normalize(a.diffuseColor),
            diffuseMultiplier: normalize(a.diffuseMultiplier),
            ...a.separateSpecular && {
              specularColor: normalize(a.specularColor),
              specularMultiplier: normalize(a.specularMultiplier),
            }
          })
        } else if (
          a instanceof GPUStandardParticle ||
          a instanceof GPUStandardCorrectParticle ||
          a instanceof GPUSparkParticle ||
          a instanceof GPUSparkCorrectParticle
        ) {
          if ('gpuParticle' in palette && mode === PaletteMode.First) continue
          palette.gpuParticle ??= []
          palette.gpuParticle.push({
            color: normalize(a.color),
            rgbMultiplier: normalize(a.rgbMultiplier),
            colorMin: normalize(a.colorMin),
            colorMax: normalize(a.colorMax),
            ...a.bloom && {
              bloomColor: normalize(a.bloomColor)
            }
          })
        } else if (a instanceof LensFlare) {
          if ('lensFlare' in palette && mode === PaletteMode.First) continue
          interface LensFlareLayer {
            color: 'layer1Color' | 'layer2Color' | 'layer3Color' | 'layer4Color'
            mult: 'layer1ColorMultiplier' | 'layer2ColorMultiplier' | 'layer3ColorMultiplier' | 'layer4ColorMultiplier'
            bloom: 'layer1BloomColor' | 'layer2BloomColor' | 'layer3BloomColor' | 'layer4BloomColor'
          }
          const layers = arrayOf(4, i => ({
            color: `layer${i+1}Color`,
            mult: `layer${i+1}ColorMultiplier`,
            bloom: `layer${i+1}BloomColor`,
          })) as LensFlareLayer[]
          let color: LensFlareLayer["color"], mult: LensFlareLayer["mult"], bloom: LensFlareLayer["bloom"]
          for ({ color, mult, bloom } of layers) {
            if (nonWhiteVisible(a[color]) || nonWhiteVisible(a[mult]) || nonWhiteVisible(a[bloom])) {
              break
            }
          }
          palette.lensFlare ??= []
          palette.lensFlare.push({
            color: normalize(a[color]),
            colorMultiplier: normalize(a[mult]),
            bloomColor: normalize(a[bloom]),
          })
        }
      }
    }
    if (mode === PaletteMode.Average) {
      for (const [k, v] of Object.entries(palette)) {
        palette[k] = averagePaletteEntries(v)
      }
    }
    for (const o of Object.values(palette)) {
      for (const [k, v] of Object.entries(o)) {
        o[k] = v instanceof Property ? v.minify().toJSON() : v
      }
    }
    return palette
  }

  /**
   * Because most of the color properties in most actions are multipliers,
   * setting all of them to the same color does not make the effect that color.
   * Instead, it will make the color much deeper/darker unless it's just white.
   * 
   * This function can be used to filter properties to assign the target color
   * to. It does this by defining "primary" and "secondary" color properties
   * for all actions with colors. If primary color properties are set to the
   * target color and secondary color properties (all non-primary ones) are set
   * to white, the final color will match the target color exactly.
   * 
   * For example, {@link BillboardEx} has four color properties:
   * - {@link BillboardEx.color1} - Secondary
   * - {@link BillboardEx.color2} - Secondary
   * - {@link BillboardEx.color3} - **Primary**
   * - {@link BillboardEx.bloomColor} - Secondary
   * 
   * This function will return false for color1, color2, and bloomColor, but
   * true for color3. Since the product of color1, color2, and color3 is the
   * actual color of the particle, and the bloom color is the product of the
   * particle color and bloomColor, setting only color3 to the target color
   * and the RGB values for the rest of the properties to white will make the
   * particle's final color match the target color.
   * @param action Any data action.
   * @param property A property name from the `action`.
   */
  export function isPrimary<T extends DataAction>(action: T, property: keyof T): boolean {
    return !action || action.$data.props?.[property]?.color === 1
  }

  /**
   * Creates a recolor function that replaces {@link isPrimary primary colors}
   * with the given color.
   * 
   * Secondary color properties will be replaced with white.
   * 
   * Some "tricks" are used to keep opacity animations and the general
   * brightness similar to the original color. These can be turned off by
   * passing `false` for `multAlpha`, `keepBrightness`, and `keepScale`. If
   * these are all disabled, the primary color will be replaced with the target
   * color without any modifications to it.
   * @param targetColor The target color.
   * @param multAlpha If enabled, the alpha will be multiplied instead of
   * replaced. This allows the original opacity to be maintained or just
   * tweaked instead of replacing it entirely by a static value, which means
   * that fade animations will still work correctly, whereas they may not in
   * some cases if it is replaced. Defaults to `true`.
   * @param keepBrightness If enabled, this will make the function multiply the
   * target color by the brightness of the original color. Defaults to `true`.
   * @param keepScale If enabled, this will force the function to maintain the
   * scale of the original color. So, if the original color has values greater
   * than 1, the target color will be multiplied by the highest value. This is
   * ignored if `keepBrightness` is enabled. Defaults to `true`.
   */
  export function replace(
    targetColor: Vector4,
    multAlpha: boolean = true,
    keepBrightness: boolean = true,
    keepScale: boolean = true,
  ): RecolorFunction {
    const [r, g, b, a] = targetColor
    if (multAlpha && keepBrightness) { // Extra optimization for the default settings
      return ([r2, g2, b2, a2], config, action, prop): Vector4 => {
        const scale = Math.max(r2, g2, b2)
        if (!isPrimary(action, prop)) return [scale, scale, scale, a2]
        return [r * scale, g * scale, b * scale, (a ?? 1) * a2]
      }
    }
    return ([r2, g2, b2, a2], config, action, prop): Vector4 => {
      const scale = keepBrightness ? Math.max(r2, g2, b2) : keepScale ? Math.max(1, r2, g2, b2) : 1
      if (!isPrimary(action, prop)) return [scale, scale, scale, a2]
      return [r * scale, g * scale, b * scale, multAlpha ? (a ?? 1) * a2 : a ?? a2]
    }
  }

  /**
   * Creates a recolor function that multiplies
   * {@link isPrimary primary color properties} by the given color.
   * 
   * Secondary color properties are left unchanged.
   * @param targetColor The target color.
   */
  export function multiply(targetColor: Vector4): RecolorFunction {
    const [r, g, b, a] = targetColor
    return ([r2, g2, b2, a2], config, action, prop): Vector4 => {
      if (!isPrimary(action, prop)) return [r2, g2, b2, a2]
      return [r * r2, g * g2, b * b2, a * a2]
    }
  }

  /**
   * Recolor function that simply inverts colors.
   */
  export const invert: RecolorFunction = ([r, g, b, a]) => {
    const scale = Math.max(r, g, b, 1)
    return [
      (1 - (r / scale)) * scale,
      (1 - (g / scale)) * scale,
      (1 - (b / scale)) * scale,
      a
    ]
  }

  /**
   * Recolor function that makes colors grayscale.
   */
  export const grayscale: RecolorFunction = ([r, g, b, a]) => {
    const l = r * 0.21 + g * 0.72 + b * 0.07
    return [l, l, l, a]
  }

  /**
   * Creates a recolor function that modifies the original color by using it to
   * sample values from a given property. This works in a very similar way to
   * the "Curves" tool in many image editing apps.
   * @param curves The property to sample color values from.
   */
  export function curves(curves: Vector4Property): RecolorFunction {
    return ([r, g, b, a]) => [
      curves.valueAt(r)[0],
      curves.valueAt(g)[1],
      curves.valueAt(b)[2],
      curves.valueAt(a)[3],
    ]
  }

  /**
   * Creates a recolor function that linearly interpolates between the original
   * color and the given color using the interpolation factor `t`.
   * @param color The target color to interpolate towards.
   * @param t The interpolation factor. At t=0, the colors will not be modified
   * at all. At t=1, the colors will be replaced with the target color. At
   * t=0.5, the color will be the average of the original color and the target
   * color.
   */
  export function mix(color: Vector4, t: number): RecolorFunction {
    const [r, g, b, a] = color
    return ([r2, g2, b2, a2]) => [
      lerp(r2, r, t),
      lerp(g2, g, t),
      lerp(b2, b, t),
      lerp(a2, a, t),
    ]
  }

  /**
   * Creates a recolor function that hue-shifts colors by a given angle in
   * degrees.
   * @param angle The angle in degrees to shift the hue.
   */
  export function hueShift(angle: number): RecolorFunction {
    return ([r, g, b, a]) => {
      const scale = Math.max(r, g, b, 1)
      const [ h, s, v ] = rgbToHsv(r / scale, g / scale, b / scale)
      return [...(hsvToRgb(mod(h * 360 + angle, 360) / 360, s, v).map(e => e * scale) as Vector3), a]
    }
  }

  /**
   * Creates a recolor function that replaces the hue of the original color
   * with that of a given color.
   * @param color The color whose hue will be used.
   */
  export function replaceHue(color: Vector3 | Vector4): RecolorFunction {
    const [ th ] = rgbToHsv(...(color.slice(0, 3) as Vector3))
    return ([r, g, b, a]) => {
      const scale = Math.max(r, g, b, 1)
      const [ , s, v ] = rgbToHsv(r / scale, g / scale, b / scale)
      return [...(hsvToRgb(th, s, v).map(e => e * scale) as Vector3), a]
    }
  }

  /**
   * Creates a recolor function that replaces the hue and saturation of
   * {@link isPrimary primary color properties} with those of a given color.
   * 
   * Secondary color properties will be replaced with grayscale versions of
   * the original colors, which means the overall brightness is kept, but only
   * the primary color properties affect the hue and saturation.
   * @param color The color whose hue and saturation will be used.
   */
  export function colorBlend(color: Vector3 | Vector4): RecolorFunction {
    const rgb = color.slice(0, 3) as Vector3
    const inputScale = Math.max(...rgb, 1)
    const [ th, ts ] = rgbToHsv(...(rgb.map(e => e / inputScale) as Vector3))
    return ([r, g, b, a], config, action, prop) => {
      if (!isPrimary(action, prop)) return grayscale([r, g, b, a])
      const scale = Math.max(r, g, b, 1)
      const [ ,, v ] = rgbToHsv(r / scale, g / scale, b / scale)
      return [...(hsvToRgb(th, ts, v).map(e => e * scale) as Vector3), a]
    }
  }

  /**
   * Creates a recolor function that scales the saturation of the colors by a
   * given factor.
   * @param factor The saturation scaling factor.
   */
  export function scaleSaturation(factor: number): RecolorFunction {
    return ([r, g, b, a]) => {
      const scale = Math.max(r, g, b, 1)
      const [ h, s, v ] = rgbToHsv(r / scale, g / scale, b / scale)
      return [...(hsvToRgb(h, s * factor, v).map(e => e * scale) as Vector3), a]
    }
  }

}

//#region FXRUtility
/**
 * Contains utility functions that may be useful when creating new effects.
 */
namespace FXRUtility {

  type Glyph = [Vector2, Vector2][]
  const font: { [char: string]: Glyph } = {
    'A': [
      [[1, 0.5], [4, 0.5]],
      [[1, 3.5], [4, 3.5]],
      [[0.5, 1], [0.5, 7]],
      [[4.5, 1], [4.5, 7]],
    ],
    'B': [
      [[0, 0.5], [4, 0.5]],
      [[1, 3.5], [4, 3.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 7]],
      [[4.5, 1], [4.5, 3]],
      [[4.5, 4], [4.5, 6]],
    ],
    'C': [
      [[1, 0.5], [4, 0.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 6]],
      [[4.5, 1], [4.5, 2]],
      [[4.5, 5], [4.5, 6]],
    ],
    'D': [
      [[0, 0.5], [4, 0.5]],
      [[0, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 6]],
      [[4.5, 1], [4.5, 6]],
    ],
    'E': [
      [[0, 0.5], [5, 0.5]],
      [[1, 3.5], [3, 3.5]],
      [[0, 6.5], [5, 6.5]],
      [[0.5, 1], [0.5, 6]],
    ],
    'F': [
      [[0, 0.5], [5, 0.5]],
      [[1, 3.5], [3, 3.5]],
      [[0.5, 1], [0.5, 7]],
    ],
    'G': [
      [[1, 0.5], [4, 0.5]],
      [[2, 3.5], [5, 3.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 6]],
      [[4.5, 1], [4.5, 2]],
      [[4.5, 4], [4.5, 6]],
    ],
    'H': [
      [[0.5, 0], [0.5, 7]],
      [[4.5, 0], [4.5, 7]],
      [[1, 3.5], [4, 3.5]],
    ],
    'I': [
      [[0, 0.5], [5, 0.5]],
      [[0, 6.5], [5, 6.5]],
      [[2.5, 1], [2.5, 6]],
    ],
    'J': [
      [[0.5, 4], [0.5, 6]],
      [[4.5, 0], [4.5, 6]],
      [[1, 6.5], [4, 6.5]],
    ],
    'K': [
      [[0.5, 0], [0.5, 7]],
      [[4.5, 0], [4.5, 1]],
      [[3.5, 1], [3.5, 2]],
      [[2.5, 2], [2.5, 3]],
      [[1.5, 3], [1.5, 4]],
      [[2.5, 4], [2.5, 5]],
      [[3.5, 5], [3.5, 6]],
      [[4.5, 6], [4.5, 7]],
    ],
    'L': [
      [[1, 6.5], [5, 6.5]],
      [[0.5, 0], [0.5, 7]],
    ],
    'M': [
      [[0.5, 0], [0.5, 7]],
      [[4.5, 0], [4.5, 7]],
      [[1.5, 1], [1.5, 2]],
      [[2.5, 2], [2.5, 3]],
      [[3.5, 1], [3.5, 2]],
    ],
    'N': [
      [[0.5, 0], [0.5, 7]],
      [[4.5, 0], [4.5, 7]],
      [[1.5, 2], [1.5, 3]],
      [[2.5, 3], [2.5, 4]],
      [[3.5, 4], [3.5, 5]],
    ],
    'O': [
      [[1, 0.5], [4, 0.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 6]],
      [[4.5, 1], [4.5, 6]],
    ],
    'P': [
      [[0, 0.5], [4, 0.5]],
      [[1, 3.5], [4, 3.5]],
      [[0.5, 1], [0.5, 7]],
      [[4.5, 1], [4.5, 3]],
    ],
    'Q': [
      [[1, 0.5], [4, 0.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 6]],
      [[4.5, 1], [4.5, 6]],
      [[3, 7.5], [5, 7.5]],
    ],
    'R': [
      [[0, 0.5], [4, 0.5]],
      [[1, 3.5], [4, 3.5]],
      [[0.5, 1], [0.5, 7]],
      [[4.5, 1], [4.5, 3]],
      [[4.5, 4], [4.5, 7]],
    ],
    'S': [
      [[1, 0.5], [4, 0.5]],
      [[1, 3.5], [4, 3.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 3]],
      [[0.5, 5], [0.5, 6]],
      [[4.5, 1], [4.5, 2]],
      [[4.5, 4], [4.5, 6]],
    ],
    'T': [
      [[0, 0.5], [5, 0.5]],
      [[2.5, 1], [2.5, 7]],
    ],
    'U': [
      [[0.5, 0], [0.5, 6]],
      [[4.5, 0], [4.5, 6]],
      [[1, 6.5], [4, 6.5]],
    ],
    'V': [
      [[0.5, 0], [0.5, 4]],
      [[1.5, 4], [1.5, 6]],
      [[2.5, 6], [2.5, 7]],
      [[3.5, 4], [3.5, 6]],
      [[4.5, 0], [4.5, 4]],
    ],
    'W': [
      [[0.5, 0], [0.5, 7]],
      [[4.5, 0], [4.5, 7]],
      [[1.5, 5], [1.5, 6]],
      [[2.5, 4], [2.5, 5]],
      [[3.5, 5], [3.5, 6]],
    ],
    'X': [
      [[0.5, 0], [0.5, 2]],
      [[4.5, 0], [4.5, 2]],
      [[0.5, 5], [0.5, 7]],
      [[4.5, 5], [4.5, 7]],
      [[1.5, 2], [1.5, 3]],
      [[1.5, 4], [1.5, 5]],
      [[2.5, 3], [2.5, 4]],
      [[3.5, 2], [3.5, 3]],
      [[3.5, 4], [3.5, 5]],
    ],
    'Y': [
      [[0.5, 0], [0.5, 2]],
      [[4.5, 0], [4.5, 2]],
      [[1.5, 2], [1.5, 3]],
      [[2.5, 3], [2.5, 7]],
      [[3.5, 2], [3.5, 3]],
    ],
    'Z': [
      [[0, 0.5], [5, 0.5]],
      [[4.5, 1], [4.5, 2]],
      [[3.5, 2], [3.5, 3]],
      [[2.5, 3], [2.5, 4]],
      [[1.5, 4], [1.5, 5]],
      [[0.5, 5], [0.5, 6]],
      [[0, 6.5], [5, 6.5]],
    ],
    'a': [
      [[1, 2.5], [5, 2.5]],
      [[1, 6.5], [5, 6.5]],
      [[0.5, 3], [0.5, 6]],
      [[4.5, 3], [4.5, 6]],
    ],
    'b': [
      [[1, 2.5], [4, 2.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 0], [0.5, 7]],
      [[4.5, 3], [4.5, 6]],
    ],
    'c': [
      [[1, 2.5], [4, 2.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 3], [0.5, 6]],
      [[4.5, 3], [4.5, 4]],
      [[4.5, 5], [4.5, 6]],
    ],
    'd': [
      [[1, 2.5], [4, 2.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 3], [0.5, 6]],
      [[4.5, 0], [4.5, 7]],
    ],
    'e': [
      [[1, 2.5], [4, 2.5]],
      [[1, 4.5], [4, 4.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 3], [0.5, 6]],
      [[4.5, 3], [4.5, 5]],
    ],
    'f': [
      [[2, 0.5], [4, 0.5]],
      [[0, 3.5], [1, 3.5]],
      [[2, 3.5], [4, 3.5]],
      [[1.5, 1], [1.5, 7]],
      [[4.5, 1], [4.5, 2]],
    ],
    'g': [
      [[1, 2.5], [5, 2.5]],
      [[1, 6.5], [4, 6.5]],
      [[1, 8.5], [4, 8.5]],
      [[0.5, 3], [0.5, 6]],
      [[4.5, 3], [4.5, 8]],
    ],
    'h': [
      [[1, 2.5], [4, 2.5]],
      [[0.5, 0], [0.5, 7]],
      [[4.5, 3], [4.5, 7]],
    ],
    'i': [
      [[1, 2.5], [3, 2.5]],
      [[0, 6.5], [5, 6.5]],
      [[2.5, 0], [2.5, 1]],
      [[2.5, 3], [2.5, 6]],
    ],
    'j': [
      [[3, 2.5], [5, 2.5]],
      [[1, 8.5], [4, 8.5]],
      [[0.5, 7], [0.5, 8]],
      [[4.5, 0], [4.5, 1]],
      [[4.5, 3], [4.5, 8]],
    ],
    'k': [
      [[0.5, 0], [0.5, 7]],
      [[4.5, 2], [4.5, 3]],
      [[3.5, 3], [3.5, 4]],
      [[1, 4.5], [3, 4.5]],
      [[3.5, 5], [3.5, 6]],
      [[4.5, 6], [4.5, 7]],
    ],
    'l': [
      [[0, 0.5], [1, 0.5]],
      [[2, 6.5], [5, 6.5]],
      [[1.5, 0], [1.5, 6]],
    ],
    'm': [
      [[0, 2.5], [4, 2.5]],
      [[0.5, 3], [0.5, 7]],
      [[2.5, 3], [2.5, 7]],
      [[4.5, 3], [4.5, 7]],
    ],
    'n': [
      [[0, 2.5], [4, 2.5]],
      [[0.5, 3], [0.5, 7]],
      [[4.5, 3], [4.5, 7]],
    ],
    'o': [
      [[1, 2.5], [4, 2.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 3], [0.5, 6]],
      [[4.5, 3], [4.5, 6]],
    ],
    'p': [
      [[0, 2.5], [4, 2.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 3], [0.5, 9]],
      [[4.5, 3], [4.5, 6]],
    ],
    'q': [
      [[1, 2.5], [5, 2.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 3], [0.5, 6]],
      [[4.5, 3], [4.5, 9]],
    ],
    'r': [
      [[1, 3.5], [2, 3.5]],
      [[2, 2.5], [4, 2.5]],
      [[4, 3.5], [5, 3.5]],
      [[0.5, 2], [0.5, 7]],
    ],
    's': [
      [[1, 2.5], [5, 2.5]],
      [[1, 4.5], [4, 4.5]],
      [[0, 6.5], [4, 6.5]],
      [[0.5, 3], [0.5, 4]],
      [[4.5, 5], [4.5, 6]],
    ],
    't': [
      [[0, 2.5], [1, 2.5]],
      [[2, 2.5], [4, 2.5]],
      [[2, 6.5], [5, 6.5]],
      [[1.5, 0], [1.5, 6]],
    ],
    'u': [
      [[1, 6.5], [5, 6.5]],
      [[0.5, 2], [0.5, 6]],
      [[4.5, 2], [4.5, 6]],
    ],
    'v': [
      [[0.5, 2], [0.5, 5]],
      [[1.5, 5], [1.5, 6]],
      [[2.5, 6], [2.5, 7]],
      [[3.5, 5], [3.5, 6]],
      [[4.5, 2], [4.5, 5]],
    ],
    'w': [
      [[0.5, 2], [0.5, 6]],
      [[1.5, 6], [1.5, 7]],
      [[2.5, 4], [2.5, 6]],
      [[3.5, 6], [3.5, 7]],
      [[4.5, 2], [4.5, 6]],
    ],
    'x': [
      [[0.5, 2], [0.5, 3]],
      [[0.5, 6], [0.5, 7]],
      [[1.5, 3], [1.5, 4]],
      [[1.5, 5], [1.5, 6]],
      [[2.5, 4], [2.5, 5]],
      [[3.5, 3], [3.5, 4]],
      [[3.5, 5], [3.5, 6]],
      [[4.5, 2], [4.5, 3]],
      [[4.5, 6], [4.5, 7]],
    ],
    'y': [
      [[1, 6.5], [4, 6.5]],
      [[1, 8.5], [4, 8.5]],
      [[0.5, 2], [0.5, 6]],
      [[4.5, 2], [4.5, 8]],
    ],
    'z': [
      [[0, 2.5], [5, 2.5]],
      [[1.5, 5], [1.5, 6]],
      [[2.5, 4], [2.5, 5]],
      [[3.5, 3], [3.5, 4]],
      [[0, 6.5], [5, 6.5]],
    ],
    '0': [
      [[1, 0.5], [4, 0.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 6]],
      [[2.5, 3], [2.5, 4]],
      [[4.5, 1], [4.5, 6]],
    ],
    '1': [
      [[1, 1.5], [2, 1.5]],
      [[0, 6.5], [5, 6.5]],
      [[2.5, 0], [2.5, 6]],
    ],
    '2': [
      [[1, 0.5], [4, 0.5]],
      [[0.5, 1], [0.5, 2]],
      [[4.5, 1], [4.5, 3]],
      [[3.5, 3], [3.5, 4]],
      [[2.5, 4], [2.5, 5]],
      [[1.5, 5], [1.5, 6]],
      [[0, 6.5], [5, 6.5]],
    ],
    '3': [
      [[1, 0.5], [4, 0.5]],
      [[0.5, 1], [0.5, 2]],
      [[4.5, 1], [4.5, 3]],
      [[2, 3.5], [4, 3.5]],
      [[4.5, 4], [4.5, 6]],
      [[0.5, 5], [0.5, 6]],
      [[1, 6.5], [4, 6.5]],
    ],
    '4': [
      [[0, 3.5], [4, 3.5]],
      [[1.5, 0], [1.5, 2]],
      [[0.5, 2], [0.5, 3]],
      [[4.5, 0], [4.5, 7]],
    ],
    '5': [
      [[0, 0.5], [5, 0.5]],
      [[0, 3.5], [4, 3.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 3]],
      [[0.5, 5], [0.5, 6]],
      [[4.5, 4], [4.5, 6]],
    ],
    '6': [
      [[1, 0.5], [4, 0.5]],
      [[1, 3.5], [4, 3.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 6]],
      [[4.5, 1], [4.5, 2]],
      [[4.5, 4], [4.5, 6]],
    ],
    '7': [
      [[0, 0.5], [5, 0.5]],
      [[4.5, 1], [4.5, 3]],
      [[3.5, 3], [3.5, 4]],
      [[2.5, 4], [2.5, 7]],
    ],
    '8': [
      [[1, 0.5], [4, 0.5]],
      [[1, 3.5], [4, 3.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 3]],
      [[0.5, 4], [0.5, 6]],
      [[4.5, 1], [4.5, 3]],
      [[4.5, 4], [4.5, 6]],
    ],
    '9': [
      [[1, 0.5], [4, 0.5]],
      [[1, 3.5], [4, 3.5]],
      [[1, 6.5], [4, 6.5]],
      [[0.5, 1], [0.5, 3]],
      [[0.5, 5], [0.5, 6]],
      [[4.5, 1], [4.5, 6]],
    ],
    '.': [
      [[0.5, 5], [0.5, 7]],
    ],
    ',': [
      [[1.5, 5], [1.5, 7]],
      [[0.5, 7], [0.5, 8]],
    ],
    ':': [
      [[0.5, 1], [0.5, 3]],
      [[0.5, 5], [0.5, 7]],
    ],
    ';': [
      [[1.5, 1], [1.5, 3]],
      [[1.5, 5], [1.5, 7]],
      [[0.5, 7], [0.5, 8]],
    ],
    '_': [
      [[0, 6.5], [5, 6.5]],
    ],
    '-': [
      [[0, 3.5], [5, 3.5]],
    ],
    '+': [
      [[0, 3.5], [5, 3.5]],
      [[2.5, 1], [2.5, 3]],
      [[2.5, 4], [2.5, 6]],
    ],
    '*': [
      [[1, 2.5], [4, 2.5]],
      [[2.5, 0], [2.5, 2]],
      [[2.5, 3], [2.5, 5]],
      [[0.5, 1], [0.5, 2]],
      [[4.5, 1], [4.5, 2]],
      [[0.5, 3], [0.5, 4]],
      [[4.5, 3], [4.5, 4]],
    ],
    '=': [
      [[0, 2.5], [5, 2.5]],
      [[0, 4.5], [5, 4.5]],
    ],
    '<': [
      [[3, 2.5], [5, 2.5]],
      [[1, 3.5], [3, 3.5]],
      [[0, 4.5], [1, 4.5]],
      [[1, 5.5], [3, 5.5]],
      [[3, 6.5], [5, 6.5]],
    ],
    '>': [
      [[0, 2.5], [1, 2.5]],
      [[1, 3.5], [3, 3.5]],
      [[3, 4.5], [5, 4.5]],
      [[1, 5.5], [3, 5.5]],
      [[0, 6.5], [1, 6.5]],
    ],
    '/': [
      [[4.5, 0], [4.5, 2]],
      [[3.5, 2], [3.5, 3]],
      [[2.5, 3], [2.5, 4]],
      [[1.5, 4], [1.5, 5]],
      [[0.5, 5], [0.5, 7]],
    ],
    '\\': [
      [[0.5, 0], [0.5, 2]],
      [[1.5, 2], [1.5, 3]],
      [[2.5, 3], [2.5, 4]],
      [[3.5, 4], [3.5, 5]],
      [[4.5, 5], [4.5, 7]],
    ],
    '#': [
      [[0, 2.5], [5, 2.5]],
      [[0, 5.5], [5, 5.5]],
      [[1.5, 1], [1.5, 2]],
      [[3.5, 1], [3.5, 2]],
      [[1.5, 3], [1.5, 5]],
      [[3.5, 3], [3.5, 5]],
      [[1.5, 6], [1.5, 7]],
      [[3.5, 6], [3.5, 7]],
    ],
    '(': [
      [[1.5, 0], [1.5, 1]],
      [[0.5, 1], [0.5, 6]],
      [[1.5, 6], [1.5, 7]],
    ],
    ')': [
      [[0.5, 0], [0.5, 1]],
      [[1.5, 1], [1.5, 6]],
      [[0.5, 6], [0.5, 7]],
    ],
    '[': [
      [[1.5, 0], [1.5, 1]],
      [[0.5, 0], [0.5, 7]],
      [[1.5, 6], [1.5, 7]],
    ],
    ']': [
      [[0.5, 0], [0.5, 1]],
      [[1.5, 0], [1.5, 7]],
      [[0.5, 6], [0.5, 7]],
    ],
    '{': [
      [[2.5, 0], [2.5, 1]],
      [[1.5, 1], [1.5, 3]],
      [[0.5, 3], [0.5, 4]],
      [[1.5, 4], [1.5, 6]],
      [[2.5, 6], [2.5, 7]],
    ],
    '}': [
      [[0.5, 0], [0.5, 1]],
      [[1.5, 1], [1.5, 3]],
      [[2.5, 3], [2.5, 4]],
      [[1.5, 4], [1.5, 6]],
      [[0.5, 6], [0.5, 7]],
    ],
    '\'': [
      [[0.5, 0], [0.5, 3]],
    ],
    '"': [
      [[0.5, 0], [0.5, 3]],
      [[2.5, 0], [2.5, 3]],
    ],
    '!': [
      [[0.5, 0], [0.5, 5]],
      [[0.5, 6], [0.5, 7]],
    ],
    '?': [
      [[1, 0.5], [4, 0.5]],
      [[0.5, 1], [0.5, 2]],
      [[4.5, 1], [4.5, 3]],
      [[3.5, 3], [3.5, 4]],
      [[2.5, 4], [2.5, 5]],
      [[2.5, 6], [2.5, 7]],
    ],
    '%': [
      [[0.5, 0], [0.5, 2]],
      [[4.5, 0], [4.5, 2]],
      [[0.5, 5], [0.5, 7]],
      [[4.5, 5], [4.5, 7]],
      [[1.5, 4], [1.5, 5]],
      [[2.5, 3], [2.5, 4]],
      [[3.5, 2], [3.5, 3]],
    ],
    '&': [
      [[1, 0.5], [3, 0.5]],
      [[1, 3.5], [3, 3.5]],
      [[1, 6.5], [3, 6.5]],
      [[0.5, 1], [0.5, 3]],
      [[0.5, 4], [0.5, 6]],
      [[3.5, 1], [3.5, 2]],
      [[3.5, 4], [3.5, 6]],
      [[4.5, 3], [4.5, 4]],
      [[4.5, 6], [4.5, 7]],
    ],
  }

  function rad2deg(rad: number) {
    return rad * 180 / Math.PI
  }

  /**
   * Wraps the given `nodes` in a node or set of nodes that have a
   * transform applied to them. This can be useful to make the nodes point in a
   * specific direction.
   * @param offset Translation offset.
   * @param axis The direction to point towards.
   * @param roll The roll angle in degrees.
   * @param nodes The nodes to transform.
   */
  export function transform(offset: Vector3, axis: Vector3, roll: number, nodes: Node[]) {
    if (axis[0] === 0 && axis[1] === 0 && axis[2] === 0 && roll === 0) {
      return new BasicNode([
        NodeTransform({ offset })
      ], nodes)
    }
    axis = normalizeVector3(axis)
    const yaw = -Math.atan2(axis[1], axis[2]) * 180 / Math.PI
    const pitch = -Math.asin(axis[0]) * 180 / Math.PI
    return new BasicNode([
      NodeTransform({
        offset,
        rotation: [yaw, 0, 0]
      })
    ], [
      new BasicNode([
        NodeTransform({
          rotation: [0, pitch, roll]
        }),
      ], nodes)
    ])
  }

  /**
   * Creates a node with an attached particle that forms a line between two
   * given points.
   * @param p1 The first point.
   * @param p2 The second point.
   * @param color Line color.
   * @param width Line width.
   * @param orientation Particle orientation mode.
   * @param args Extra arguments for the particle action constructor.
   * @param actionClass The particle action constructor to use.
   */
  export function line<
    T extends new (...args: any) => InstanceType<Q>,
    Q extends typeof BillboardEx | typeof MultiTextureBillboardEx
  >(
    p1: Vector3,
    p2: Vector3,
    color: Vector4Value = [1, 1, 1, 1],
    width: ScalarValue = 0.02,
    orientation: OrientationMode.LocalSouth | OrientationMode.LocalYaw = OrientationMode.LocalYaw,
    args?: ConstructorParameters<T>[0],
    actionClass: Q = BillboardEx as Q
  ) {
    const dx = p2[0] - p1[0]
    const dy = p2[1] - p1[1]
    const dz = p2[2] - p1[2]
    const cx = p1[0] + dx * 0.5
    const cy = p1[1] + dy * 0.5
    const cz = p1[2] + dz * 0.5
    return new BasicNode([
      new StaticNodeTransform({
        offset: [cx, cy, cz],
        rotation: [
          0,
          rad2deg(Math.atan2(dz, dx)),
          rad2deg(Math.atan2(dy, Math.sqrt(dx * dx + dz * dz))),
        ]
      })
    ], [
      new BasicNode([
        ...orientation === OrientationMode.LocalYaw ? [
          new StaticNodeTransform({ rotation: [0, 90, 0] })
        ] : [],
        new actionClass({
          blendMode: BlendMode.Source,
          rgbMultiplier: 0.6,
          ...args,
          color3: color,
          width: Math.sqrt(dx * dx + dy * dy + dz * dz),
          height: width,
          orientation,
        })
      ])
    ])
  }

  /**
   * Creates a node with a box outline. This can be useful for visualizing box
   * volumes.
   * @param pos The center point of the box.
   * @param size The size of the box.
   * @param color The color of the box outline.
   * @param lineWidth The width of the box outline.
   * @param args Extra arguments for the particle action constructor.
   */
  export function box(
    pos: Vector3 = [0, 0, 0],
    size: Vector3 = [1, 1, 1],
    color?: Vector4Value,
    lineWidth?: ScalarValue,
    args?: Partial<Props<BillboardEx>>
  ) {
    const x1 = pos[0] - size[0] * 0.5
    const y1 = pos[1] - size[1] * 0.5
    const z1 = pos[2] - size[2] * 0.5
    const x2 = pos[0] + size[0] * 0.5
    const y2 = pos[1] + size[1] * 0.5
    const z2 = pos[2] + size[2] * 0.5
    return new BasicNode([], [
      line([x1, y1, z1], [x1, y1, z2], color, lineWidth, OrientationMode.LocalYaw, args),
      line([x1, y1, z2], [x1, y2, z2], color, lineWidth, OrientationMode.LocalYaw, args),
      line([x1, y1, z1], [x1, y2, z1], color, lineWidth, OrientationMode.LocalYaw, args),
      line([x1, y2, z1], [x1, y2, z2], color, lineWidth, OrientationMode.LocalYaw, args),

      line([x2, y1, z1], [x2, y1, z2], color, lineWidth, OrientationMode.LocalYaw, args),
      line([x2, y1, z2], [x2, y2, z2], color, lineWidth, OrientationMode.LocalYaw, args),
      line([x2, y1, z1], [x2, y2, z1], color, lineWidth, OrientationMode.LocalYaw, args),
      line([x2, y2, z1], [x2, y2, z2], color, lineWidth, OrientationMode.LocalYaw, args),

      line([x1, y1, z1], [x2, y1, z1], color, lineWidth, OrientationMode.LocalYaw, args),
      line([x1, y1, z2], [x2, y1, z2], color, lineWidth, OrientationMode.LocalYaw, args),
      line([x1, y2, z1], [x2, y2, z1], color, lineWidth, OrientationMode.LocalYaw, args),
      line([x1, y2, z2], [x2, y2, z2], color, lineWidth, OrientationMode.LocalYaw, args),
    ])
  }

  /**
   * Creates a node with a rectangular outline.
   * @param width The width of the rectangle.
   * @param height The height of the rectangle.
   * @param color The color of the outline.
   * @param lineWidth The width of the outline.
   * @param args Extra arguments for the particle action constructor.
   */
  export function rect(
    width: number = 1,
    height: number = 1,
    color?: Vector4Value,
    lineWidth?: ScalarValue,
    args?: Partial<Props<BillboardEx>>
  ) {
    const w = width * 0.5
    const h = height * 0.5
    return new BasicNode([], [
      line([-w, -h, 0], [ w, -h, 0], color, lineWidth, OrientationMode.LocalYaw, args),
      line([-w,  h, 0], [ w,  h, 0], color, lineWidth, OrientationMode.LocalYaw, args),
      line([-w, -h, 0], [-w,  h, 0], color, lineWidth, OrientationMode.LocalYaw, args),
      line([ w, -h, 0], [ w,  h, 0], color, lineWidth, OrientationMode.LocalYaw, args),
    ])
  }

  /**
   * Creates a node with an elliptical outline.
   * @param radiusX The X radius of the ellipse.
   * @param radiusY The Y radius of the ellipse.
   * @param segments The number of line segments to use to approximate the
   * ellipse.
   * @param color The color of the outline.
   * @param lineWidth The width of the outline.
   * @param args Extra arguments for the particle action constructor.
   */
  export function ellipse(
    radiusX: number = 1,
    radiusY: number = radiusX,
    segments: number = 16,
    color?: Vector4Value,
    lineWidth?: ScalarValue,
    args?: Partial<Props<BillboardEx>>,
  ) {
    const angleInc = 2 * Math.PI / segments
    return new BasicNode([], arrayOf(segments, i => {
      const a1 = i * angleInc
      const a2 = (i + 1) * angleInc
      return line(
        [radiusX * Math.cos(a1), radiusY * Math.sin(a1), 0],
        [radiusX * Math.cos(a2), radiusY * Math.sin(a2), 0],
        color,
        lineWidth,
        OrientationMode.LocalYaw,
        args,
      )
    }))
  }

  /**
   * Creates a node with three elliptical outlines forming an ellipsoid.
   * @param radiusX The X radius of the ellipsoid.
   * @param radiusY The Y radius of the ellipsoid.
   * @param radiusZ The Z radius of the ellipsoid.
   * @param segments The number of line segments to use to approximate the
   * ellipses.
   * @param color The color of the outline.
   * @param lineWidth The width of the outline.
   * @param args Extra arguments for the particle action constructor.
   */
  export function ellipsoid(
    radiusX: number = 1,
    radiusY: number = radiusX,
    radiusZ: number = radiusX,
    segments: number = 16,
    color?: Vector4Value,
    lineWidth?: ScalarValue,
    args?: Partial<Props<BillboardEx>>,
  ) {
    return new BasicNode([], [
      ellipse(radiusX, radiusY, segments, color, lineWidth, args),
      transform([0, 0, 0], [0, 1, 0], 0, ellipse(radiusX, radiusZ, segments, color, lineWidth, args).nodes),
      transform([0, 0, 0], [1, 0, 0], 0, ellipse(radiusZ, radiusY, segments, color, lineWidth, args).nodes)
    ])
  }

  /**
   * Creates a node with two elliptical outlines and four line segments
   * connecting them, forming a cylinder.
   * @param radiusX The X radius of the cylinder.
   * @param radiusY The Y radius of the cylinder.
   * @param height The height of the cylinder.
   * @param segments The number of line segments to use to approximate the
   * ellipses.
   * @param color The color of the lines.
   * @param lineWidth The width of the lines.
   * @param args Extra arguments for the particle action constructor.
   */
  export function cylinder(
    radiusX: number = 1,
    radiusY: number = radiusX,
    height: number = 1,
    segments: number = 16,
    color?: Vector4Value,
    lineWidth?: ScalarValue,
    args?: Partial<Props<BillboardEx>>,
  ) {
    return new BasicNode([], [
      transform([0, 0, -height * 0.5], [0, 0, 0], 0, ellipse(radiusX, radiusY, segments, color, lineWidth, args).nodes),
      transform([0, 0,  height * 0.5], [0, 0, 0], 0, ellipse(radiusX, radiusY, segments, color, lineWidth, args).nodes),
      line([ radiusX, 0, -height * 0.5], [ radiusX, 0, height * 0.5], color, lineWidth, OrientationMode.LocalYaw, args),
      line([-radiusX, 0, -height * 0.5], [-radiusX, 0, height * 0.5], color, lineWidth, OrientationMode.LocalYaw, args),
      line([0,  radiusY, -height * 0.5], [0,  radiusY, height * 0.5], color, lineWidth, OrientationMode.LocalYaw, args),
      line([0, -radiusY, -height * 0.5], [0, -radiusY, height * 0.5], color, lineWidth, OrientationMode.LocalYaw, args),
    ])
  }

  /**
   * Adds outlines for all particle and node emitters in the node.
   * 
   * GPU particle emitters are not outlined, as they work very differently, and
   * adding child nodes to the node with the emitter can seemingly sometimes
   * affect the rotation of the GPU particle emitter somehow.
   * @param node The node to add the emitter outlines to.
   * @param recurse Controls if the outlines should be added to the entire
   * branch or only to the `node`. Defaults to `true`.
   * @param color The color of the outlines.
   * @param lineWidth The width of the outlines.
   * @param args Extra arguments for the particle action constructor.
   */
  export function outlineEmitters(
    node: Node,
    recurse: boolean = true,
    color?: Vector4Value,
    lineWidth?: ScalarValue,
    args?: Partial<Props<BillboardEx>>
  ) {
    const nodes = recurse ? Array.from(node.walk()) : [node]
    for (const n of nodes) {
      if (n instanceof BasicNode || n instanceof NodeEmitterNode) {
        for (const config of n.walkConfigs(false)) {
          if (config instanceof NodeEmitterConfig || (
            config instanceof BasicConfig &&
            config.appearance instanceof DataAction &&
            config.appearance.$data.isParticle
          )) {
            const emShape = config.emitterShape
            if (emShape instanceof DiskEmitterShape) {
              const radius = constantValueOf(emShape.radius)
              n.nodes.push(ellipse(radius, radius, 16, color, lineWidth, args))
            } else if (emShape instanceof RectangleEmitterShape) {
              const width = constantValueOf(emShape.sizeX)
              const height = constantValueOf(emShape.sizeY)
              n.nodes.push(rect(width, height, color, lineWidth, args))
            } else if (emShape instanceof SphereEmitterShape) {
              const radius = constantValueOf(emShape.radius)
              n.nodes.push(ellipsoid(radius, radius, radius, 16, color, lineWidth, args))
            } else if (emShape instanceof BoxEmitterShape) {
              const x = constantValueOf(emShape.sizeX)
              const y = constantValueOf(emShape.sizeY)
              const z = constantValueOf(emShape.sizeZ)
              n.nodes.push(box([0, 0, 0], [x, y, z], color, lineWidth, args))
            } else if (emShape instanceof CylinderEmitterShape) {
              const radius = constantValueOf(emShape.radius)
              const height = constantValueOf(emShape.height)
              n.nodes.push(cylinder(radius, radius, height, 16, color, lineWidth, args))
            }
          }
        }
      }
    }
  }

  /**
   * Creates a node that represents a string, which contains nodes that
   * represent characters. This can be very useful for displaying text in an
   * effect, which is often useful to, for example, debug or test things.
   * 
   * Note: This generates a *lot* of nodes depending on the text. Avoid using
   * it to display very long strings. That can be done better using a custom
   * texture on a single particle instead.
   * @param text The text to convert.
   * @param options Alignment, size, and other options for the text.
   */
  export function text(
    text: string,
    options: {
      originX?: 'left' | 'center' | 'right'
      originY?: 'baseline' | 'top' | 'middle' | 'bottom'
      fontSize?: number
      color?: Vector4Value
      args?: Partial<Props<BillboardEx>>
    } = {}
  ): BasicNode {
    const lines = text.split('\n')
    const nodes: Node[] = []
    let offset: Vector2 = [0, {
      baseline: 10 * (lines.length - 1) - 3,
      top: -7,
      middle: (10 * (lines.length - 1) - 3) / 2,
      bottom: 10 * (lines.length - 1),
    }[options.originY ?? 'baseline'] ?? 10 * lines.length - 3]
    function vec3(v2: Vector2): Vector3 {
      return [v2[0], 7 - v2[1], 0]
    }
    function glyphWidth(glyph: Glyph) {
      return Math.ceil(glyph.reduce((a, e) => Math.max(a, e[0][0], e[1][0]), 0))
    }
    function addGlyph(glyph: Glyph) {
      nodes.push(new BasicNode([
        new StaticNodeTransform({
          offset: [...offset, 0]
        })
      ], glyph.map(([p1, p2]) => line(
        vec3(p1),
        vec3(p2),
        options.color,
        1,
        OrientationMode.LocalSouth,
        options.args
      ))))
      offset[0] += glyphWidth(glyph) + 1
    }
    for (const line of lines) {
      const w = Array.from(line).reduce((a, e) => {
        if (e === ' ') return a + 3
        if (!(e in font)) return a
        return a + glyphWidth(font[e]) + 1
      }, -1)
      offset[0] = {
        left: 0,
        center: -w/2,
        right: -w,
      }[options.originX ?? 'left'] ?? 0
      for (const char of line) {
        if (char === ' ') {
          offset[0] += 3
          continue
        }
        if (!(char in font)) {
          continue
        }
        addGlyph(font[char])
      }
      offset[1] -= 10
    }
    return new BasicNode([], nodes).scale((options.fontSize ?? 1) / 7)
  }

  /**
   * Creates a {@link ActionType.NodeSpin NodeSpin} action from an animated
   * rotation property.
   * 
   * Normally, to animate the rotation of a node, you would need to use
   * {@link ActionType.NodeSpin NodeSpin} to animate the angular speed.
   * Controlling the angular speed instead of the rotation directly can be tricky
   * if you want the node to point in specific directions at specific times. This
   * function automatically converts an animated rotation property to an angular
   * speed property to make this easier.
   * 
   * **Notes**:
   * - High angular velocities are not very well supported. Avoid using
   * this function if you need the rotation to change quickly. Stepped rotation
   * properties are not supported at all.
   * - The rotation property must start at `[0, 0, 0]`. To control the initial
   * rotation, wrap the node in one with that rotation instead.
   * - This only creates an approximation, it is not perfect. If this is used
   * with a looping property, the rotation will eventually stray from where it
   * should be. This is likely due to how the angular speed is applied, which is
   * also why high speeds break this.
   * @param rotation The rotation of the node.
   * 
   * **Default**: `[0, 0, 0]`
   * 
   * **Argument**: {@link PropertyArgument.ActiveTime Active time}
   */
  export function animatedNodeRotation(rotation: Vector3Value): Action | NodeSpin {
    if (!(rotation instanceof Property) || rotation instanceof ValueProperty) {
      return new Action
    }

    if (rotation.function === PropertyFunction.Stepped) {
      throw new Error(`The 'rotation' parameter for NodeAnimatedRotation cannot be a stepped property.`)
    }

    const prop: SequenceProperty<ValueType.Vector3, SequencePropertyFunction> =
      rotation instanceof SequenceProperty ? rotation :
      (rotation as ComponentSequenceProperty<ValueType.Vector3>).combineComponents()
    const keyframes = prop.function === PropertyFunction.Linear ?
      prop.keyframes as Keyframe<ValueType.Vector3>[] :
      filterMillisecondDiffs(
        interpolateSegments(prop.keyframes.map(e => e.position), 0.1, 40)
      ).map(pos => new Keyframe<ValueType.Vector3>(pos, prop.valueAt(pos)))
    const speeds: Keyframe<ValueType.Vector3>[] = []

    for (let i = 0; i < keyframes.length; i++) {
      if (i === keyframes.length - 1) {
        speeds.push({ position: keyframes[i].position, value: [0, 0, 0] })
      } else {
        const deltaTime = keyframes[i + 1].position - keyframes[i].position
        const deltaValue = anyValueDiff(keyframes[i + 1].value, keyframes[i].value)
        const speed: Vector3 = anyValueMult(1 / deltaTime, deltaValue)
        speeds.push(new Keyframe(keyframes[i].position, speed))
      }
    }

    const angularSpeed = separateComponents(new LinearProperty<ValueType.Vector3>(prop.loop, speeds))

    return new NodeSpin({
      angularSpeedX: angularSpeed[0],
      angularSpeedY: angularSpeed[1],
      angularSpeedZ: angularSpeed[2],
    }).minify()
  }

}

export {
  Game,
  FXRVersion,
  ValueType,
  PropertyFunction,
  ModifierType,
  FieldType,
  ExternalValue,
  Operator,
  OperandType,
  ResourceType,

  Nodes,
  ConfigActionSlots,
  ActionData,
  DataActions,

  anyValueMult,
  anyValueSum,
  anyValueDiff,
  combineComponents,
  separateComponents,
  setVectorComponent,
  randomSeed,
  getValueType,

  FXR,

  State,
  StateCondition,

  Node,
  GenericNode,
  NodeWithConfigs,
  RootNode,
  ProxyNode,
  LevelsOfDetailNode,
  BasicNode,
  NodeEmitterNode,

  NodeConfig,
  LevelsOfDetailConfig,
  BasicConfig,
  NodeEmitterConfig,

  Action,
  DataAction,
  getActionGameData,
  NodeMovement,
  NodeTransform,
  ParticleMovement,
  /*#ActionsExport start*/
  NodeAcceleration,
  NodeTranslation,
  NodeSpin,
  StaticNodeTransform,
  RandomNodeTransform,
  NodeAttachToCamera,
  ParticleAcceleration,
  ParticleSpeed,
  ParticleSpeedRandomTurns,
  ParticleSpeedPartialFollow,
  NodeSound,
  EmissionSound,
  NodeAccelerationRandomTurns,
  ParticleAccelerationRandomTurns,
  ParticleAccelerationPartialFollow,
  NodeAccelerationPartialFollow,
  NodeAccelerationSpin,
  NodeSpeed,
  NodeSpeedRandomTurns,
  NodeSpeedPartialFollow,
  NodeSpeedSpin,
  NodeAttributes,
  ParticleAttributes,
  Unk130,
  ParticleModifier,
  SFXReference,
  LevelsOfDetailThresholds,
  StateConfigMap,
  SelectAllNodes,
  SelectRandomNode,
  PeriodicEmitter,
  EqualDistanceEmitter,
  OneTimeEmitter,
  PointEmitterShape,
  DiskEmitterShape,
  RectangleEmitterShape,
  SphereEmitterShape,
  BoxEmitterShape,
  CylinderEmitterShape,
  NoSpread,
  CircularSpread,
  EllipticalSpread,
  RectangularSpread,
  PointSprite,
  Line,
  QuadLine,
  BillboardEx,
  MultiTextureBillboardEx,
  Model,
  LegacyTracer,
  Distortion,
  RadialBlur,
  PointLight,
  SimulateTermination,
  FadeTermination,
  InstantTermination,
  NodeForceSpeed,
  ParticleForceSpeed,
  NodeForceAcceleration,
  ParticleForceAcceleration,
  ParticleForceCollision,
  GPUStandardParticle,
  GPUStandardCorrectParticle,
  LightShaft,
  GPUSparkParticle,
  GPUSparkCorrectParticle,
  Tracer,
  WaterInteraction,
  LensFlare,
  RichModel,
  Unk10100,
  CancelForce,
  WindForce,
  GravityForce,
  ForceCollision,
  TurbulenceForce,
  Unk10400,
  Unk10500,
  SpotLight,
  /*#ActionsExport end*/

  Field,
  BoolField,
  IntField,
  FloatField,
  Vector2Field,
  Vector3Field,
  Vector4Field,

  Keyframe,
  BezierKeyframe,
  HermiteKeyframe,

  Property,
  ValueProperty,
  SequenceProperty,
  ComponentSequenceProperty,
  ConstantProperty,
  SteppedProperty,
  LinearProperty,
  BezierProperty,
  HermiteProperty,
  RandomDeltaProperty,
  RandomRangeProperty,
  RandomFractionProperty,
  RainbowProperty,
  BloodVisibilityProperty,

  Modifier,
  GenericModifier,
  RandomDeltaModifier,
  RandomRangeModifier,
  RandomFractionModifier,
  ExternalValue1Modifier,
  ExternalValue2Modifier,
  BloodVisibilityModifier,
  PrecipitationModifier,

  Recolor,
  hex,

  FXRUtility,
}
